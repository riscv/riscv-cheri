[#section_ext_cheri_levels]
== "{cheri_levels_ext_name}" Extension for Capability Levels

{cheri_levels_ext_name} is an optional extension to {cheri_base_ext_name} that adds support for associating a level with capabilities and limiting flow of capabilities to specific memory region subsets.
This extension allows assigning a level to capabilities, which in conjunction with two new permissions allows enforcing invariants on capability propagation.
For example, this can be used to ensure that a callee cannot store a copy of the passed in argument to memory or to avoid sharing of compartment-local data between compartments.
The number of supported levels is configurable, but this specification currently only requires supporting two levels (_local_ and _global_).

=== Capability format changes
The {cheri_levels_ext_name} adds a new `LVLBITS`-bit field to the <<section_cap_encoding,capability encoding>>, the _<<section_cap_level>>_.
It also adds two new permission fields, <<el_perm>> and <<sl_perm>>.

- For `XLEN=64` <<section_cap_encoding,capability encoding>>, the AP field is widened by `LVLBITS+1` bits (i.e. 2 bits for `LVLBITS=1`)
- For `XLEN=32` the <<section_cap_perms,AP>> field of the capability is able to encoding these permissions without increasing in size (currently up to `LVLBITS=2`).

NOTE: Support for {cheri_levels_ext_name} requires support for at least `LVLBITS=1`, and `LVLBITS>1` is considered an experimental enhancement of this extension.
See <<section_ext_cheri_multiple_levels>> for the mechanics when `LVLBITS>1`.


[#section_cap_level,reftext="capability level"]
==== Capability Level (CL)

With `LVLBITS=1`, the _Capability Level_ can hold two values: when set to 1 the capability is _global_ (in general allowing it to be stored using any authorizing capability), and when set to 0 the capability is _local_, and can only be stored by authorizing capabilities with the <<sl_perm>> set.
Furthermore, the <<el_perm>> can be used to restrict loading of _global_ capabilities -- causing the loaded value to be _local_ instead.

NOTE: This specification only defines the implementation of this feature, for further information on how this can be used by software please refer to cite:[cheri-v9-spec].

NOTE: The current specification only defines two levels, equivalent to _local_ and _global_ capabilities from CHERI v9, Morello and CHERIoT.

As with permissions, the capability level can only be reduced but never increased (without deriving from a capability with a higher level).
Therefore, the capability level is adjusted using the <<ACPERM>> instruction (see <<section_cap_level_change>>) and are queried using <<GCPERM>>.

==== New capability permissions
{cheri_levels_ext_name} introduces two new capability permissions:
[#sl_perm,reftext="SL-permission"]
Store Level Permission (SL):: This is a `LVLBITS` wide field that allows limiting the propagation of capabilities using the following logic: capabilities with a <<section_cap_level>> less than the inverse of <<sl_perm>> will be stored with the tag cleared.
With `LVLBITS=1`, i.e. one bit for SL and CL each, this permission functions as follows:
// This awkward wording above allows a multi-bit scheme where capabilities as low as level = ~store_level can be stored.
// The one bit scheme simplifies to:
// 1 -> allow storing as low as level ~1 = 0 -> level 0 (local) and 1 (global) is okay
// 0 -> allow storing as low as level ~0 = 1 -> only level 1 (global)
- If this field (as well as <<c_perm>> and <<w_perm>>) is set to 1 then capabilities may be stored via this capability regardless of their associated <<section_cap_level>>.
- If this field is zero, then any capability with a <<section_cap_level>> of zero (i.e. _local_), will be stored with the tag cleared.

[#el_perm,reftext="EL-permission"]
Elevate Level Permission (EL):: If this permission is not set then any tagged capabilities loaded via this capability will have the <<el_perm>> cleared and the <<section_cap_level>> restricted to the <<section_cap_level>> of the authorizing capability.
This permission is similar to the existing <<lm_perm>>, but instead of applying to the <<w_perm>> on the loaded capability it restricts the <<section_cap_level,CL>> field.

.Encoding of architectural permissions for MXLEN=32 when {cheri_levels_ext_name} is implemented
[#cap_perms_encoding_levels32,width="100%",options=header,cols="^2,^1,^1,^1,^1,^1,^1,^1,^1,^2,4",align="center"]
|==============================================================================
|Bits[4:3]| R | W | C | LM | EL | SL | X | ASR | Mode^1^ | Notes
11+| *Quadrant 0: Non-capability data read/write*
11+| bit[2] - write, bit[1] - reserved (0), bit[0] - read
11+| _Reserved bits for future extensions are 0 so new permissions are not implicitly granted_
| 0   |   |   |   |   |   |   |   |   | N/A | No permissions
| 1   | ✔ |   |   |   |   |   |   |   | N/A | Data RO
| 2-3   10+| reserved
| 4   |   | ✔ |   |   |   |   |   |   | N/A | Data WO
| 5   | ✔ | ✔ |   |   |   |   |   |   | N/A | Data RW
| 6-7   10+| reserved
11+| *Quadrant 1: Executable capabilities*
11+| bit[0] - <<m_bit>> ({CAP_MODE_VALUE}-{cheri_cap_mode_name}, {INT_MODE_VALUE}-{cheri_int_mode_name})
|Bits[4:3]| R | W | C | LM | EL | SL  | X | ASR | Mode^1^ |
| 0-1   | ✔ | ✔ | ✔ | ✔  | ✔  | ∞   | ✔ |  ✔  | Mode^1^  | Execute + ASR (see <<infinite-cap>>)
| 2-3   | ✔ |   | ✔ | ✔  | ✔  | ∞   |   |     | Mode^1^  | Execute + Data & Cap RO
| 4-5   | ✔ | ✔ | ✔ | ✔  | ✔  | ∞   | ✔ |     | Mode^1^  | Execute + Data & Cap RW
| 6-7   | ✔ | ✔ |   |    |    | N/A |   |     | Mode^1^  | Execute + Data RW
11+| *Quadrant 2: Restricted capability data read/write*
11+| bit[2] - write. R and C implicitly granted, LM dependent on W permission.
11+| _Reserved bits for future extensions must be 1 so they are implicitly granted_
|Bits[4:3]| R | W | C | LM | EL | SL    | X | ASR | Mode^1^ |
| 0-2   10+| reserved
| 3       | ✔ |   | ✔ |    |    | N/A   |   |     | N/A | Data & Cap R0 (without <<lm_perm>>)
| 4       | ✔ | ✔ | ✔ | ✔  |    | _(3)_ |   |     | N/A | Reserved for `LVLBITS=2`
| 5       | ✔ | ✔ | ✔ | ✔  |    | _(2)_ |   |     | N/A | Reserved for `LVLBITS=2`
| 6       | ✔ | ✔ | ✔ | ✔  |    | 1     |   |     | N/A | Data & Cap RW (with store _local_, no <<el_perm>>)
| 7       | ✔ | ✔ | ✔ | ✔  |    | 0     |   |     | N/A | Data & Cap RW (no store _local_, no <<el_perm>>)
11+| *Quadrant 3: Capability data read/write*
11+| [2] - write. R and C implicitly granted.
11+| _Reserved bits for future extensions must be 1 so they are implicitly granted_
|Bits[4:3]| R | W | C | LM | EL | SL    | X | ASR | Mode^1^ |
| 0-2   10+| reserved
| 3       | ✔ |   | ✔ | ✔  | ✔  | N/A   |   |     | N/A | Data & Cap R0
| 4       | ✔ | ✔ | ✔ | ✔  | ✔  | _(3)_ |   |     | N/A | Reserved for `LVLBITS=2`
| 5       | ✔ | ✔ | ✔ | ✔  | ✔  | _(2)_ |   |     | N/A | Reserved for `LVLBITS=2`
| 6       | ✔ | ✔ | ✔ | ✔  | ✔  | 1     |   |     | N/A | Data & Cap RW (with store _local_)
| 7       | ✔ | ✔ | ✔ | ✔  | ✔  | 0     |   |     | N/A | Data & Cap RW (no store _local_)
|==============================================================================

[#section_cap_level_change]
=== Changing capability levels and permissions
While capability levels are conceptually a label on the capability rather than a permission granted by the capability, they are adjusted using the <<ACPERM>> instruction.
This avoids the need for a dedicated instruction and allows reducing the level and removing <<el_perm>> in a single instruction as this is a common code sequence.


=== Example use cases for {cheri_levels_ext_name}

FIXME: Add something here before merging.

[#section_ext_cheri_multiple_levels]
=== Extending {cheri_levels_ext_name} to more than two levels
When `LVLBITS>1`, the behaviour of <<ACPERM>> can no longer use masking to adjust the <<section_cap_level>> or <<sl_perm>>, but instead must perform an integer minimum operation on those `LVLBITS`-wide fields.
The <<section_cap_level,CL>> field of the resulting capability is set to `min(rs2[CL], cs1[CL])`  (equivalent to `rs2[CL] & cs1[CL]` for `LVLBITS=1`).
Similarly, <<sl_perm>> is set to `min(rs2[SL], cs1[SL])` (equivalent to `rs2[SL] & cs1[SL]` for `LVLBITS=1`).

When storing capabilities, the <<sl_perm>> checks need to perform a `LVLBITS`-wide integer comparison instead of just testing a single bit.
Considering for an example `LVLBITS=2`:

[grid=rows,cols="2,3,6"]
|===
|<<sl_perm>> | Permitted for levels| Resulting semantics
|3 | As low as `~0b11=0` | Authorizes stores of capabilities with any level
|2 | As low as `~0b10=1` | Strip tag for level 0 (most _local_), keep for 1,2,3
|1 | As low as `~0b01=2` | Strip tag for level 0&1, keep for 2&3
|0 | As low as `~0b00=3` | Strip tag for level 0,1,2, i.e. only the most _global_ can be stored
|===

NOTE: While this extra negation is non-intuitive, it is required such that <<ACPERM>> can use a monotonically decreasing operation for both <<section_cap_level,CL>> <<sl_perm>>.
