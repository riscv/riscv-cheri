:cheriot_auicgp_name: AUICGP
:cheriot_auicgp_name_lc: auicgp

:cheriot_gettop_name: YTOPR
:cheriot_setbounds_round_down_name: YBNDSRDW
:cheriot_setbounds_big_imm_name: YBNDSWBI

:cheriot_sentry_ot_min: 1
:cheriot_sentry_ot_bd: 4
:cheriot_sentry_ot_be: 5
:cheriot_sentry_ot_fd: 2
:cheriot_sentry_ot_fe: 3
:cheriot_sentry_ot_fi: 1
:cheriot_sentry_ot_max: 5

= RVY Specializations for Microcontroller Systems

[#sec_zycheriot, reftext={cheriot_ext_name}]
== The {cheriot_ext_name} ISA Extension

This section defines a series of small changes to the
{cheri_base_ext_name} and {cheri_base_ext_name}E base architectures
that serve to specialize it for microcontroller environments.
These changes are based on, but are not exactly isomorphic to,
the prior link:https://cheriot.org[CHERIoT] RV32E-based ISA.

[NOTE]
====
While most likely of use only in the context of the
{cheri_base32_ext_name} and {cheri_base32_ext_name}E base architectures,
there is no intrinsic incompatibility with 64-bit or wider machines.
====

=== Required Extensions

{cheriot_ext_name} requires the presence of all of:

* <<section_priv_cheri,{cheri_priv_m_ext}>>,

* <<section_zylevels1>>, and

* <<section_zyseal>>.

The present specification presumes the *absence* of all of:

* any execution mode other than M-mode
  (such as VS, HS, VU, S, or U),

* <<section_cheri_hybrid_ext,{cheri_default_ext_name}>>,

* <<section_cheri_disable,{cheri_priv_m_reg_enable_ext}>>, and

* <<section_rvy_sentry_insn_ext>>.

[NOTE]
=====
While {cheriot_ext_name} is nominally compatible with
<<section_cheri_hybrid_ext,{cheri_default_ext_name}>> and
<<section_cheri_disable,{cheri_priv_m_reg_enable_ext}>>,
and particular instantiations may opt to permit disabling CHERI,
we have not yet found a compelling reason to formally specify this composition.
=====

[NOTE]
=====
While {cheriot_ext_name} is nominally compatible with
<<section_rvy_sentry_insn_ext>>,
the operating system written for {cheriot_ext_name} has a security model
that presumes the absence of ambient sealing,
and this specification does not
define any <<sec_cap_type_ambient,ambiently available>> sentry types.
=====

=== Refining CHERI Capabilities

==== Software Defined Permissions

{cheriot_ext_name} defines SDPLEN, the number of software-defined permissions,
to be `1`.
We denote this one user permission as `U0`.

[#sec_zycheriot_permission_roots]
==== Root Permission Sets

{cheriot_ext_name} defines _three_ <<root-cap>> capability values:

* Its <<root-rx-cap>> capability value is defined as
  having <<zylevels1_gl_perm>> set and granting exactly all of
  <<x_perm>>, <<r_perm>>, <<c_perm>>, <<lm_perm>>, <<asr_perm>>,
  and <<zylevels1_lg_perm>>.

* Its <<root-rw-cap>> capability value is defined as
  having <<zylevels1_gl_perm>> set and granting exactly all of
  <<r_perm>>, <<w_perm>>, <<c_perm>>, <<lm_perm>>,
  <<zylevels1_lg_perm>>, and <<zylevels1_sl_perm>>.

* It defines a _root sealing_ capability value that has a set {ctag},
  is unsealed,
  has full address space bounds,
  has <<zylevels1_gl_perm>> set,
  and grants exactly all of <<zyseal_se_perm>>, <<zyseal_us_perm>>, and `U0`.

These root capabilities satisfy the following properties by construction.
They will necessarily remain true through any series of <<CLRPERM>> transitions:

[[perm_req:zycheriot:w-nand-x,w-nand-x]]w-nand-x::
  At most one of <<x_perm>> or <<w_perm>> may be set.

[[perm_req:zycheriot:mem-nand-ct,mem-nand-ct]]mem-nand-ct::
  The <<zyseal_se_perm>>, <<zyseal_us_perm>>, and `U0`
  collectively conflict with
  either of the <<r_perm>> or <<w_perm>> permissions.
+
That is, a capability may grant permissions
from at most one of these two sets;
this serves to partition capabilities that refer to memory addresses
from those that refer to <<sec_cap_type>> values
(those granting <<zyseal_se_perm>> and/or <<zyseal_us_perm>>)
or uninterpreted integers (those granting `U0`).
Capabilities granting no permissions from the union of these sets
are not distinguished.

[#sec_zycheriot_permission_transitions]
==== Permission Transition Constraints

{cheriot_ext_name} requires a {cheri_base_ext_name} base that is using
a compressed permission scheme
(that is, one has its `_Ly` `p` parameter set to `pc`).

In addition to the constraints on
<<sec_permission_transitions,permission transitions>>
defined across the base {cheri_base_ext_name} ISA
and the <<section_zylevels1>> extension,
{cheriot_ext_name} adds two additional constraints:
+
[float="center",align="center",cols="2,2,4",options="header"]
|===
| <<CLRPERM>> Rule     | Permission            | Valid only if
| {cheriot_ext_name}-1 | <<x_perm>>            | <<c_perm>> and <<r_perm>>
| {cheriot_ext_name}-2 | <<zylevels1_sl_perm>> | <<r_perm>>
|===

==== CSR Reset States

The {cheri_base_ext_name} base privileged ISA tends to define
M-mode CSRs' reset values either as <<root-rx-cap>> capabilities or
as otherwise unspecified values with clear {ctag}s.
To make available {cheriot_ext_name}'s multiple
<<sec_zycheriot_permission_roots,root>> capability values,
we redefine two CSRs' reset values:

<<mtidc>>::
The <<mtidc>> register's reset value is changed to be
{cheriot_ext_name}'s <<root-rw-cap>> capability value (with set {ctag}).

<<mscratch>>::
The <<mscratch>> register's reset value is changed to be
{cheriot_ext_name}'s _sealing_ capability value (with set {ctag}).

==== Additional CSR Legalization Requirements

All of <<pcc>>, <<mtvec>>, and <<mepc>> will clear their {ctag} if the
capability they would come to hold after an update
would be sealed or would not grant <<x_perm>>.

[NOTE]
=====
All three of these CSRs reset to <<root-rx-cap>> capabilities
(with unspecified addresses), which satisfy this legalization requirement.
Neither architecture nor software expects to be able
to place capabilities thereby prohibited in these CSRs.
=====

[#sec_zycheriot_sentries]
==== New Sentry Types

{cheriot_ext_name} uses <<sentry_cap>> capabilities to
enforce structured control flow by atomically changing
the value of `mstatus.MIE` during a <<JALR_CHERI>>.
The purpose of this is to enable calls to short per-core atomic sequences
without granting the right to modify `mstatus.MIE` arbitrarily.

These rules ensure both

* that functions that are called with a new interrupt stance
  can return to the caller's stance, and

* a degree of control flow integrity.

Non-standard control flow transfers such as tail calls and calls to compiler
outlined functions using a non-standard link register are still possible.

Towards this end, {cheriot_ext_name} defines
_five_ <<sentry_cap>> <<sec_cap_type>> values
({cheriot_sentry_ot_min} through {cheriot_sentry_ot_max}, inclusive):

* Any of these values may be passed as inputs to <<JALR_CHERI>>.
  When such a <<JALR_CHERI>> instruction retires,
  the hart's `mstatus.MIE` bit is updated as per <<tab_cheriot_sentry_irq>>.

* Two values, {cheriot_sentry_ot_bd} and {cheriot_sentry_ot_be},
  are used by <<JALR_CHERI>> to seal the return capability when `rd` is `ra`.
  If the hart's `mstatus.MIE` bit is `0`
  after the prior instruction has retired,
  the return capability is sealed with {cheriot_sentry_ot_bd};
  otherwise, {cheriot_sentry_ot_be} is used.

* <<JALR_CHERI>> is given conditional behavior
  based on the register selectors used,
  as detailed in <<tab_cheriot_jalr_regs>>.
  Prohibited combinations of register selectors and <<sec_cap_type>> value
  will cause the target <<pcc>> to have a clear {ctag} and so raise a
  {cheri_excep_name_pc}.

[NOTE]
=====
All of the <<sentry_cap>> <<sec_cap_type>> values defined herein
need be encodable only if the capability grants <<x_perm>>.
=====

.Additional <<JALR_CHERI>> Architectural Semantics
[#tab_cheriot_sentry_irq,width="100%",options=header,halign=center,cols="1,5"]
|===
| <<sec_cap_type>>       | IRQs at Retirement (`mstatus.MIE`)
| {cheriot_sentry_ot_fi} | Unchanged (as is)
| {cheriot_sentry_ot_fd}, {cheriot_sentry_ot_bd} | Deferred (`0`)
| {cheriot_sentry_ot_fe}, {cheriot_sentry_ot_be} | Enabled (`1`)
|===

.<<JALR_CHERI>> Conditional Behavior
[#tab_cheriot_jalr_regs,width="100%",options=header,halign=center,cols="1,2,4,4"]
|===
| {cs1} | {cd}   | Permitted {cs1} <<sec_cap_type>>-s | Comments
| `ra`  | `null` | {cheriot_sentry_ot_bd}, {cheriot_sentry_ot_be} | Function return
| ≠`ra` | `null` | 0, {cheriot_sentry_ot_fi} | Tail call
| any   | ∉{ `null`, `ra` } | 0, {cheriot_sentry_ot_fi} | Code outlining
| any   | `ra`   | 0, {cheriot_sentry_ot_fi}, {cheriot_sentry_ot_fd}, {cheriot_sentry_ot_fe} | Function call
|===

=== New Instructions

[#sec_zycheriot_auicgp,reftext="{cheriot_auicgp_name}"]
==== {cheriot_auicgp_name}

{cheriot_ext_name} defines a new U-type instruction, {cheriot_auicgp_name},
which shifts (by the AUIPC shift)
and adds its 20-bit immediate to the address of <<mtidc>>
(using the semantics of the <<CADD>> instruction)
and stores the resulting capability in a target register,
analogously to <<AUIPC_CHERI>> and <<pcc>>.

[NOTE]
=====
See `AUICGP` in {cheriot_v1_isa}.
Therein, a compartment's globals pointer
is not held in a CSR, but rather the `x2` GPR;
the use of a CSR is presently experimental.
The impact of lowering register pressure is yet to be measured.
=====

////
==== {cheriot_setbounds_big_imm_name}

[NOTE]
=====
TODO: setbounds immediate as an I-type instruction w/ 12-bit immediate rather
than the base's R-type w/ (scaled) 5-bit immediate, <<SCBNDSI>>.
See `CSetBoundsImm` in {cheriot_v1_isa}.

Maybe this should be some non-{cheriot_ext_name} extension.
=====

[NOTE]
=====
TODO, research required:
While this instruction exists in the CHERIoT ISA,
the {cheri_base_ext_name} <<SCBNDSI>> form does not.
What is the best way to take advantage of having both
an I-type and R-type instruction available?

Should the I-type instruction's immediate be a length and a shift,
since our encoding's mantissas are smaller than 12 bits wide?

=====
////

==== {cheriot_setbounds_round_down_name}

[NOTE]
=====
TODO: setbounds register that fixes base and rounds length down for
representability.
(Contrast the rounding behavior of <<SCBNDS>>.)
See `CSetBoundsRoundDown` in {cheriot_v1_isa}.

Maybe this should be some non-{cheriot_ext_name} extension.
=====

==== {cheriot_gettop_name}

[NOTE]
=====
TODO: Two-operand instruction that fuses <<GCBASE>>, <<GCLEN>>, and ADD.
Easy for microarchitecture given how we unpack capabilities in registers.
See `CGetTop` in {cheriot_v1_isa}.

Maybe this should be some non-{cheriot_ext_name} extension.
=====

=== Capability Load Filter and The Revocation Bitmap

As part of providing _heap temporal_ safety,
{cheriot_ext_name} extends the semantics of `{load_cap_name_lc}`
to introduce a _capability load filter_.
The memory block(s) in which software's dynamic allocation heap(s) are to reside
are paired with a _revocation bitmap_,
a bit-vector wherein each bit corresponds to a capability-sized memory granule.
(That is, with each capability-sized and -aligned region of the primal memory.)
Such memory block(s) are said to be _revokable_.
These revocation bitmaps are also exposed (as memory) to software.

When `{load_cap_name_lc}` transfers a valid capability (one with a set {ctag})
from memory into a hart's register file,
it checks whether the _base_ (lower bound) of that capability is within
a revokable memory block and, if so,
fetches the corresponding bit in the associated revocation bitmap.
If that bit is set, then the {ctag} stored in the hart's register file
as part of this transfer is cleared.

Software dynamic memory allocators can set bits in a revocation bitmap
to ensure that additional copies of capabilities to particular objects
cannot be constructed (into register files and, so, into memory, too).
This facilitates particularly straightforward global revocation of pointers to
freed heap objects.

[NOTE]
=====
The location, size, and number of revokable memory blocks,
as well as the mapping function from primal memory address to revocation bitmap
address and bit index, are all platform-defined.
=====

=== Stack High Watermark CSRs

{cheriot_ext_name} introduces two new XLEN CSRs: `mshwm` and `mshwmb`.  Both are
freely read but require <<asr_perm>> for explicit writes from software.  Writes
are WARL, with legal values being addresses with capability alignment (that is,
multiples of YLEN bits in octet bytes).  Store instructions targeting addresses
between the values held in `mshwm` and `mshwmb` cause `mshwm` to be updated to
the lowest targeted address (rounded down to capability alignment).

[NOTE]
=====
The intended software use of these CSRs is, as the section title suggests,
to track the "high watermark" of a thread's C stack
(that is, the lowest address written to, because "stacks grow down").
The thread context switching code should context switch these registers,
having initialized `mshwmb` to the lower bound of the thread's stack capability
and `mshwm` to its upper bound.
Privileged stack zeroing code can be used to lower `mshwm`, so that all bytes
between the addresses held in `mshwm` and `mshwmb` are known to be zero.
=====

== A {cheri_base32_ext_name}{rvy_cheriot_common_base_suffix} Common Base Architecture

It is intended that {cheriot_ext_name} be instantiated atop a
{cheri_base32_ext_name} base architecture at least as expressive as
{rvy_cheriot_common_base_suffix}, in combination with
one of the capability encoding schemes discussed below
or a future, possibly vendor-specific, capability encoding.
Software written for this (partially specified) base architecture
will be source compatible across encoding formats
and with more expressive variants of {cheri_base32_ext_name}.

The parameters set by this common architecture are:

- `mw{cap_cheriot_mw_width}` and `e{cap_cheriot_exp_range_max}`:
  A mantissa width of {cap_cheriot_mw_width} and
  expressibility of capability exponents from 0 (inclusive)
  to {cap_cheriot_exp_range_max} (inclusive).
  Together, these ensure that capabilities can precisely capture capabilities
  whose lengths are between 1 and 2^9^ - 1 times a power of 2
  between 1 (inclusive) and 2^{cap_cheriot_exp_range_max}^ (inclusive) or
  is 2^{cap_cheriot_exp_max}^.
+
[NOTE]
====
The latter of these is sufficient to represent the entire 32-bit address space
at a granularity (that is, bounds alignment) of 16MiB.
====

- `r0`: Software must not presume that taking a capability out of bounds,
  other than the "one past the end" position required by C,
  will leave it tagged.

- `as11`: The shift used by <<AUIPC_CHERI>> (and similar instructions, such as
  <<sec_zycheriot_auicgp>>, above) is `11`.

- `pc`: The set of capabiality permissions that can be expressed is subject to
  compression.  For these bases, the only compression used is a consequence of
  the roots and permission transition rules found in the base architecture and
  present extensions (such as {cheriot_ext_name}).

TODO: Can we refactor RV32Y's compression scheme out to something like the
Zycheriot ISA perspective, too?

[NOTE]
=====
As a reminder, these parameters constrain the behavior
of {cheri_base_ext_name} instructions such as <<SCBNDS>> and <<CLRPERM>>.
=====

include::./rvy-cheriot-enc1.adoc[]
include::./rvy-cheriot-enc2.adoc[]
include::./rvy-cheriot-enc3.adoc[]
