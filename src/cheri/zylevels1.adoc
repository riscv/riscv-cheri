[#section_zylevels1,reftext="{cheri_levels1_ext_name}"]
== "{cheri_levels1_ext_name}" Extension for CHERI 2-Level Information Flow Control

{cheri_levels1_ext_name} introduces a simple _Information Flow Control_ (IFC) mechanism to CHERI.
// It is mutually exclusive with <<section_zylevelsN>>, which introduces more elaborate IFC.

In this simple IFC system, capabilities are said to be either _global_ or _local_.
While the distinction between _global_ and _local_ is not one of _authority_
(that is, the distinction is not one of _permission_),
_global_ capabilities may attenuate into _local_ capabilities.
The distinction refines the behavior of capability store and load instructions:

* Capability-write-permissive capabilities are refined to authorize stores of _any_ capability or _global_ capabilities only.
  The former may attenuate into the latter.
  Attempting to store a local capability through an insufficiently permissive authority clears the {ctag} of the value written to memory, if any.

* Capability-load-permissive capabilities are refined to authorize loads of _any_ capabilities or _local_ capabilities only.
  Again, the former may attenuate to the latter.
  Attempting to load a global capability through an insufficiently permissive authority instead _attenuates_ the load result as described below.

=== Added Architectural Permissions (AP) Bits

[#zylevels1_ap_field_summary,width="100%",options=header,halign=center,cols="2,2,5"]
|==============================================================================
| Permission   | Type | Comment
| <<zylevels1_sl_perm>>  | Data memory permission         | Used to filter the permissions of loaded capabilities.
| <<zylevels1_lg_perm>>  | Data memory permission         | Used to filter the permissions of loaded capabilities.
|==============================================================================

[#zylevels1_sl_perm,reftext="SL-permission"]
Store Local Permission (SL):: This field allows limiting the propagation of _local_ capabilities.
+
A capability without <<zylevels1_gl_perm>> set stored through an authorizing capability lacking <<zylevels1_sl_perm>> will be stored with a zero {ctag}.
+
<<zylevels1_sl_perm>> is a _refinement of_ <<c_perm>> and <<w_perm>>.
That is, if either of the latter are clear, then <<zylevels1_sl_perm>> has no effect.

[#zylevels1_lg_perm,reftext="LG-permission"]
Load Global Permission (LG):: This field allows limiting the propagation of _global_ capabilities.
+
When a capability is loaded through an authorizing capability that lacks <<zylevels1_lg_perm>>, the resulting capability value has its <<zylevels1_gl_perm>> bit cleared.
Additionally, if the loaded capability value is _unsealed_, its <<zylevels1_lg_perm>> is also cleared in the result.
+
This permission is similar to the base <<lm_perm>> and its effects on loaded capabilities' <<w_perm>> and <<lm_perm>> (but note the difference in interaction with seals).
+
<<zylevels1_lg_perm>> is a _refinement of_ <<c_perm>> and <<r_perm>>.
That is, if either of the latter are clear, then <<zylevels1_lg_perm>> has no effect.

[#zylevels1_gl_perm,reftext="GL(obal) Flag"]
=== The Capability Global (GL) Flag

The _Capability Global_ (GL) flag is a permission-like single-bit field which allows enforcing invariants on capability propagation in combination with the <<zylevels1_lg_perm>> and <<zylevels1_sl_perm>> bits described above.

NOTE: For example, the software TCB may enforce that software has access to capabilities with <<zylevels1_sl_perm>> only to (subsets of) its runtime stack,
and may ensure that all stack pointers lack <<zylevels1_gl_perm>>.
In such a system, capabilities without <<zylevels1_gl_perm>>, including all those derived from the stack, are confined to registers and stack memory.
Global capabilities, say, into heap memory, may be _attenuated_ to being local before being passed across a call;
the callee will be unable to capture this pointer outside its stack.
This specification defines only the architectural mechanics of this feature, for further information on how this can be used by software please refer to cite:[cheri-v9-spec].

The _Capability Global_ flag holds one of two values:

* 1: the capability is _global_.
* 0: the capability is _local_.

As with permissions, the _Capability Global_ flag can be cleared when creating a new capability value from an existing one, but it can never be set (without deriving it from a global superset capability).

=== Interaction with <<root-cap>> Capabilities

The <<root-cap>> capabilities used in the system are extended thus:

* The definitions of <<root-rx-cap>> and <<root-rw-cap>> capabilities are
  both augmented to require <<zylevels1_gl_perm>> be set to _global_.

* A <<root-rx-cap>> capability is required to grant <<zylevels1_lg_perm>>.

* A <<root-rw-cap>> capability is required to grant both <<zylevels1_lg_perm>>, and <<zylevels1_sl_perm>>.

=== Interaction with <<CLRPERM>> and <<GCPERM>>

.Extended capability permissions bit field (see <<acperm_bit_field>>)
[#zylevels1_acperm_bit_field]
include::./img/zylevels1-acperm_bit_field.edn[]

The <<zylevels1_gl_perm>>, <<zylevels1_sl_perm>>, and <<zylevels1_lg_perm>> fields
are mapped into the <<acperm_bit_field,capability permissions bitfield>> (<<acperm_bit_field>>),
used by <<CLRPERM>> and <<GCPERM>>,
as shown in <<zylevels1_acperm_bit_field>>.

==== <<CLRPERM>> and the Capability Global (GL) Flag
<<CLRPERM>> can produce a new capability value with its <<zylevels1_gl_perm>> cleared, even if the source capability is sealed.
This is unlike architectural and software permissions.
This applies to both "implicit <<CLRPERM>>s" in loads from memory and explicit <<CLRPERM>> instructions.

==== Additional <<CLRPERM>> rules

As mentioned, the <<zylevels1_sl_perm>> and <<zylevels1_lg_perm>> permissions
are dependent on (refinements of) base permissions.
<<CLRPERM>> (including "implicit <<CLRPERM>>" operations) and/or the capability encoding
therefore clear these permissions when their dependencies clear.
Specifically, we add the following rules to those of <<sec_permission_transitions>>:

[float="center",align="center",cols="2,2,4",options="header"]
|===
| <<CLRPERM>> Rule | Permission | Valid only if
| [[perm_req:zylevels1:lg:c-and-r,{cheri_levels1_ext_name}-1]]{cheri_levels1_ext_name}-1 +
                   | <<zylevels1_lg_perm>> | <<c_perm>> and <<r_perm>>
| [[perm_req:zylevels1:sl:c-and-w,{cheri_levels1_ext_name}-2]]{cheri_levels1_ext_name}-2 +
                   | <<zylevels1_sl_perm>> | <<c_perm>> and <<w_perm>>
|===

=== Interaction with <<LOAD_CAP>>

As outlined above, {cheri_levels1_ext_name} introduces two new constraints on capabilities loaded from memory,
as part of a <<LOAD_CAP>> instruction (`{load_cap_name_lc} {cd}, offset({cs1})`).
Analogous requirements apply for other instructions that inherit semantics from `<<LOAD_CAP>>`.
These may be phrased as "implicit <<CLRPERM>>-s" performed on the loaded capability thus:

* If `{cd}.tag=1`, `{cd}` *is not* sealed, and `{cs1}` does not grant <<zylevels1_lg_perm>>,
  then an implicit <<CLRPERM>> is performed, clearing both <<zylevels1_gl_perm>> and <<zylevels1_lg_perm>> of `{cd}`.

* If `{cd}.tag=1`, `{cd}` *is* sealed, and `{cs1}` does not grant <<zylevels1_lg_perm>>,
  then an implicit <<CLRPERM>> is performed, clearing <<zylevels1_gl_perm>> of `{cd}`.

NOTE: Missing <<zylevels1_lg_perm>> also affects the <<zylevels1_gl_perm>> of sealed capabilities,
since notionally the latter is not a permission but rather a data flow label attached to the loaded value.

NOTE: Because <<zylevels1_sl_perm>> is relevant only to capabilities granting <<w_perm>>,
the attenuation performed by a load whose authority (`{cs1}`) does not grant <<lm_perm>>
will necessarily also clear <<zylevels1_sl_perm>>.

=== Interaction with <<STORE_CAP>>

As outlined above, {cheri_levels1_ext_name} introduces a new constraint on capabilities stored to memory,
as part of a <<STORE_CAP>> instruction (`{store_cap_name_lc} {cs2}, offset({cs1})`).
Analogous requirements apply for other instructions that inherit semantics from `<<STORE_CAP>>`.
The written {ctag} may be set _only if_ either

* `{cs2}` 's <<zylevels1_gl_perm>> is set or
* `{cs1}` 's <<zylevels1_sl_perm>> is set.

NOTE: While <<zylevels1_lg_perm>> attenuates by reducing <<zylevels1_gl_perm>> and <<zylevels1_lg_perm>>,
<<zylevels1_sl_perm>> attenuates by clearing {ctag}s.

=== Interaction with <<SCSS>>

Implementations of {cheri_levels1_ext_name} must ensure that a <<SCSS>> instruction `{SCSS_LC} rd, {cs1}, {cs2}`
indicates that `{cs1}` is a subset of `{cs2}` (that is, sets `rd` to 1) only if either

* `{cs2}` 's <<zylevels1_gl_perm>> is clear or
* `{cs1}` 's <<zylevels1_gl_perm>> is set.

The existing permission subset logic applies to the new <<zylevels1_sl_perm>> and <<zylevels1_lg_perm>>.

=== Interaction with <<CBLD>>

A <<CBLD>> instruction `{CBLD_LC} {cd}, {cs1}, {cs2}` may yield `{cd}.tag=1` only if either

* `{cs2}` 's <<zylevels1_gl_perm>> is clear or
* `{cs1}` 's <<zylevels1_gl_perm>> is set.

The existing permission subset logic applies to the new <<zylevels1_sl_perm>> and <<zylevels1_lg_perm>>.

=== Interaction with <<YSUNSEAL>>

A <<YSUNSEAL>> instruction `{YSUNSEAL_LC} {cd}, {cs1}, {cs2}`
must ensure that `{cd}` grants <<zylevels1_gl_perm>> only if
`{cs1}` also grants <<zylevels1_gl_perm>>.
(That is, `{cd}` grants <<zylevels1_gl_perm>> if and only if both
the unsealing authority in `{cs1}` and
the unsealed form of the capability in `{cs2}` grant <<zylevels1_gl_perm>>.)

The existing permission subset logic applies to the new <<zylevels1_sl_perm>> and <<zylevels1_lg_perm>>.

=== Summary Of System Behavior

.<<zylevels1_sl_perm>> effects for stored capabilities
[#zylevels1_store_summary,width="100%",options=header,halign=center,cols="1,1,1,1,5"]
|==============================================================================
   3+|Auth cap field       | Data cap field |
    h|*W*    h|*C* h|*SL* h|*GL*           h| Notes
.3+.^|1  .3+.^| 1   | 1    | X              | Store data capability unmodified
               .2+.^| 0    | 0              | Store data capability unmodified
                           | 1              | Store data capability with {ctag} cleared
|==============================================================================

NOTE: <<zylevels1_sl_perm>> is relevant only to capabilities granting both <<w_perm>> and <<c_perm>>.

.<<zylevels1_gl_perm>> effects for loading capabilities
[#zylevels1_load_summary,width="100%",options=header,align=center,cols="1,1,1,1,1,6"]
|==============================================================================
   3+|Auth cap field         2+| Data cap field |
    h|*R*   h|*C*    h|*LG*   h| Tag h| Sealed h| Action
.3+.^|1 .3+.^| 1 .2+.^| 0 .2+.^| 1    | Yes     | Load data capability with its <<zylevels1_gl_perm>> cleared
                                      | No      | Load data capability with both its <<zylevels1_gl_perm>> and <<zylevels1_lg_perm>> cleared
                    3+| All other cases         | Load data capability with both its <<zylevels1_gl_perm>> and <<zylevels1_lg_perm>> unmodified
|==============================================================================

NOTE: <<zylevels1_lg_perm>> is relevant only to capabilities granting both <<r_perm>> and <<c_perm>>.

ifdef::cheri_v9_annotations[]
NOTE: The <<zylevels1_gl_perm>> and <<zylevels1_sl_perm>> are as in CHERI v9, Morello and CHERIoT v1.  The <<zylevels1_lg_perm>> is as in CHERIoT v1.
endif::[]
