[#section_zylevels1,reftext="{cheri_levels1_ext_name}"]
== "{cheri_levels1_ext_name}" Extension for CHERI 2-Level Information Flow Control

{cheri_levels1_ext_name} introduces a simple _Information Flow Control_ (IFC) mechanism to CHERI.
// It is mutually exclusive with <<section_zylevelsN>>, which introduces more elaborate IFC.

In this simple IFC system, capabilities are said to be either _global_ or _local_.
While the distinction between _global_ and _local_ is not one of _authority_
(that is, the distinction is not one of _permission_),
_global_ capabilities may attenuate into _local_ capabilities.
The distinction refines the behavior of capability store and load instructions:

* Capability-write-permissive capabilities are refined to authorize stores of _any_ capability or _global_ capabilities only.
  The former may attenuate into the latter.
  Attempting to store a local capability through an insufficiently permissive authority clears the tag of the value written to memory, if any.

* Capability-load-permissive capabilities are refined to authorize loads of _any_ capabilities or _local_ capabilities only.
  Again, the former may attenuate to the latter.
  Attempting to load a global capability through an insufficiently permissive authority instead _attenuates_ the load result as described below.

=== Added Architectural Permissions (AP) Bits

[#zylevels1_ap_field_summary,width="100%",options=header,halign=center,cols="2,2,5"]
|==============================================================================
| Permission   | Type | Comment
| <<zylevels1_sl_perm>>  | Data memory permission         | Used to filter the permissions of loaded capabilities.
| <<zylevels1_lg_perm>>  | Data memory permission         | Used to filter the permissions of loaded capabilities.
|==============================================================================

[#zylevels1_sl_perm,reftext="SL-permission"]
Store Local Permission (SL):: This field allows limiting the propagation of _local_ capabilities.
+
A capabilty without <<zylevels1_gl_perm>> set stored through an authorizing capability lacking <<zylevels1_sl_perm>> will be stored with a zero valid tag.
+
<<zylevels1_sl_perm>> is a _refinement of_ <<c_perm>> and <<w_perm>>.
That is, if either of the latter are clear, then <<zylevels1_sl_perm>> has no effect.

[#zylevels1_lg_perm,reftext="LG-permission"]
Load Global Permission (LG):: This field allows limiting the propagation of _global_ capabilities.
+
A capability loaded through an authorizing capability lacking <<zylevels1_lg_perm>> will have its <<zylevels1_gl_perm>> bit cleared.
Additionally, if the loaded capability is _unsealed_, its <<zylevels1_lg_perm>> is cleared.
+
This permission is similar to the base <<lm_perm>> and its effects on loaded capabilties' <<w_perm>> and <<lm_perm>> (but note the difference in interaction with seals).
+
<<zylevels1_lg_perm>> is a _refinement of_ <<c_perm>> and <<r_perm>>.
That is, if either of the latter are clear, then <<zylevels1_lg_perm>> has no effect.

[#zylevels1_gl_perm,reftext="GL(obal) Flag"]
=== The Capability Global (GL) Flag

The _Capability Global_ (GL) flag is a permission-like single-bit field which allows enforcing invariants on capability propagation in combination with the <<zylevels1_lg_perm>> and <<zylevels1_sl_perm>> bits described above.

NOTE: For example, the software TCB may enforce that software has access to capabilities with <<zylevels1_sl_perm>> only to (subsets of) its runtime stack,
and may ensure that all stack pointers lack <<zylevels1_gl_perm>>.
In such a system, capabilties without <<zylevels1_gl_perm>>, including all those derived from the stack, are confined to registers and stack memory.
Global capabilities, say, into heap memory, may be _attenuated_ to being local before being passed across a call;
the callee will be unable to capture this pointer outside its stack.
This specification defines only the architectural mechanics of this feature, for further information on how this can be used by software please refer to cite:[cheri-v9-spec].

The _Capability Global_ flag holds one of two values:

* 1: the capability is _global_.
* 0: the capability is _local_.

As with permissions, the _Capability Global_ flag of a valid capability can be cleared but never set (without reconstruction from a global superset capability).

=== Interaction with <<infinite-cap,Infinite Capabilities>>

As expected, <<infinite-cap,Infinite capabilities>> have both new permissions, <<zylevels1_lg_perm>> and <<zylevels1_sl_perm>> set.
Further, Infinite caps have <<zylevels1_gl_perm>> set to _global_.

=== Interaction with <<ACPERM>> and <<GCPERM>>

.Extended capability permissions bit field (see <<acperm_bit_field>>)
[#zylevels1_acperm_bit_field]
include::./img/zylevels1-acperm_bit_field.edn[]

The <<zylevels1_gl_perm>>, <<zylevels1_sl_perm>>, and <<zylevels1_lg_perm>> fields
are mapped into the <<acperm_bit_field,capability permissions bitfield>> (<<acperm_bit_field>>),
used by <<ACPERM>> and <<GCPERM>>,
as shown in <<zylevels1_acperm_bit_field>>.

.ACPERM and the Capability Global (GL) Flag

<<ACPERM>> is permitted to clear the _Capability Global_ flag can be cleared,
even if the capability is sealed,
unlike architectural and software permissions.
This applies to both "implicit <<ACPERM>>s" in loads from memory and explicit <<ACPERM>> instructions.

Implementations _are permitted but not mandated_ to require that an explicit <<ACPERM>> instruction wishing to clear <<zylevels1_gl_perm>>
has an input mask that is _entirely 1s_ except for <<zylevels1_gl_perm>>
(or else clear the tag of the resulting capability).

.Additional ACPERM rules (see <<acperm_rules>>)

As mentioned, the <<zylevels1_sl_perm>> and <<zylevels1_lg_perm>> permissions
are dependent on (refinements of) base permissions.
<<ACPERM>> (including "implicit <<ACPERM>>" operations) and/or the capability encoding
therefore clear these permissions when their dependencies clear.
Specifically, we add the following rules to the <<acperm_rules>> table:

[float="center",align="center",cols="2,2,4",options="header"]
|===
| Rule                       | Permission            | Valid only if
| {cheri_levels1_ext_name}-1 | <<zylevels1_lg_perm>> | <<c_perm>> and <<r_perm>>
| {cheri_levels1_ext_name}-2 | <<zylevels1_sl_perm>> | <<c_perm>> and <<w_perm>>
|===

=== Interaction with <<LOAD_CAP>> and <<LOAD_RES_CAP>>

As outlined above, {cheri_levels1_ext_name} introduces two new constraints on capabilities loaded from memory,
as part of a <<LOAD_CAP>> instruction `{load_cap_name_lc} cd, offset(cs1)`
or <<LOAD_RES_CAP>> instruction `lr{ld_st_dot_cap_lc} cd, offset(cs1)`.
These may be phrased as "implicit <<ACPERM>>-s" performed on the loaded capability thus:

* If `cd.tag=1`, `cd` *is not* sealed, and `cs1` does not grant <<zylevels1_lg_perm>>,
  then an implicit <<ACPERM>> is performed, clearing both <<zylevels1_gl_perm>> and <<zylevels1_lg_perm>> of `cd`.

* If `cd.tag=1`, `cd` *is* sealed, and `cs1` does not grant <<zylevels1_lg_perm>>,
  then an implicit <<ACPERM>> is performed, clearing <<zylevels1_gl_perm>> of `cd`.

NOTE: Missing <<zylevels1_lg_perm>> also affects the <<zylevels1_gl_perm>> of sealed capabilities,
since notionally the latter is not a permission but rather a data flow label attached to the loaded value.

NOTE: Because <<zylevels1_sl_perm>> is relevant only to capabilities bearing <<w_perm>>,
the attenuation performed by a load whose authority (`cs1`) does not convey <<lm_perm>>
will necessarily also clear <<zylevels1_sl_perm>>.

=== Interaction with <<STORE_CAP>> and <<STORE_COND_CAP>>

As outlined above, {cheri_levels1_ext_name} introduces a new constraint on capabilities stored to memory,
as part of a <<STORE_CAP>> instruction `{store_cap_name_lc} cs2, offset(cs1)`
or <<STORE_COND_CAP>> instruction `sc{ld_st_dot_cap_lc} cs2, offset(cs1)`:
the written valid tag may be set _only if_ either

* `cs2` 's <<zylevels1_gl_perm>> is set or
* `cs1` 's <<zylevels1_sl_perm>> is set.

NOTE: While <<zylevels1_lg_perm>> attenuates by reducing <<zylevels1_gl_perm>> and <<zylevels1_lg_perm>>,
<<zylevels1_sl_perm>> attenuates by clearing valid tags.

=== Interaction with <<SCSS>>

Implementations of {cheri_levels1_ext_name} must ensure that a <<SCSS>> instruction `scss rd, cs1, cs2`
indicates that `cs1` is a subset of `cs2` (that is, sets `rd` to 1) only if either

* `cs2` 's <<zylevels1_gl_perm>> is clear or
* `cs1` 's <<zylevels1_gl_perm>> is set.

The existing permission subset logic applies to the new <<zylevels1_sl_perm>> and <<zylevels1_lg_perm>>.

=== Interaction with <<CBLD>>

A <<CBLD>> instruction `cbld cd, cs1, cs2` may yield `cd.tag=1` only if either

* `cs2` 's <<zylevels1_gl_perm>> is clear or
* `cs1` 's <<zylevels1_gl_perm>> is set.

The existing permission subset logic applies to the new <<zylevels1_sl_perm>> and <<zylevels1_lg_perm>>.

=== Summary Of System Behavior

.<<zylevels1_sl_perm>> effects for stored capabilities
[#zylevels1_store_summary,width="100%",options=header,halign=center,cols="1,1,1,1,5"]
|==============================================================================
   3+|Auth cap field       | Data cap field |
    h|*W*    h|*C* h|*SL* h|*GL*           h| Notes
.3+.^|1  .3+.^| 1   | 1    | X              | Store data capability unmodified
               .2+.^| 0    | 0              | Store data capability unmodified
                           | 1              | Store data capability with valid tag cleared
|==============================================================================

NOTE: <<zylevels1_sl_perm>> is relevant only to capabilities bearing both <<w_perm>> and <<c_perm>>.

.<<zylevels1_gl_perm>> effects for loading capabilities
[#zylevels1_load_summary,width="100%",options=header,align=center,cols="1,1,1,1,1,6"]
|==============================================================================
   3+|Auth cap field         2+| Data cap field |
    h|*R*   h|*C*    h|*LG*   h| Tag h| Sealed h| Action
.3+.^|1 .3+.^| 1 .2+.^| 0 .2+.^| 1    | Yes     | Load data capability with its <<zylevels1_gl_perm>> cleared
                                      | No      | Load data capability with both its <<zylevels1_gl_perm>> and <<zylevels1_lg_perm>> cleared
                    3+| All other cases         | Load data capability with both its <<zylevels1_gl_perm>> and <<zylevels1_lg_perm>> unmodified
|==============================================================================

NOTE: <<zylevels1_lg_perm>> is relevant only to capabilities bearing both <<r_perm>> and <<c_perm>>.

ifdef::cheri_v9_annotations[]
NOTE: The <<zylevels1_gl_perm>> and <<zylevels1_sl_perm>> are as in CHERI v9, Morello and CHERIoT v1.  The <<zylevels1_lg_perm>> is as in CHERIoT v1.
endif::[]
