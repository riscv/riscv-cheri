[#app_cap_description, reftext="{rvy_uni_base_name}"]
== {rvy_uni_base_name} - The University of Cambridge Capability Encoding in {cheri_base_ext_name}

This chapter describes the University of Cambridge capability encoding for both {rvy64_uni_base_name} and {rvy32_uni_base_name}.
It covers the following configurations:

* <<uycfg>>.base=0, and
* <<uycfg>>.features=0 (no levels support) or 1 (<<section_zylevels1>> support)

NOTE: No levels support is specified as an option to allow flexibility for future extensions to reuse the architectural permissions allocated to <<section_zylevels1>> in {rvy32_uni_base_name}. It is not recommended to exclude <<section_zylevels1>> until a better alternative exists.

This minimal encoding is indicated by <<uycfg>>.base=0, <<uycfg>>.features=1.


If {cheri_default_ext_name} is implemented, the specification includes encoding the <<cheri_execution_mode>> in the capability format.

ifdef::cheri_standalone_spec[]
WARNING: This chapter will appear as an appendix in the unpriv specification.
endif::[]

ifdef::support_varxlen[]
The value of XLEN may
change dynamically at run-time depending on the values written to CSRs, so we
define capability behavior in terms of MXLEN, which is the value of XLEN used
in machine mode and the widest XLEN the implementation supports.

NOTE: {cheri_base_ext_name} assumes a version of the privileged architecture
which defines MXLEN as constant and requires higher privilege modes to have at
least the same XLEN as lower privilege modes; these changes are present in the
current draft and expected to be part of privileged architecture 1.13.
endif::support_varxlen[]

[#section_cap_encoding]
=== Capability Encoding

ifdef::cheri_v9_annotations[]
NOTE: *CHERI v9 Note:* The encoding changes eliminate the concept of the
in-memory format, and also increase precision for RV32.
endif::[]

The components of a capability, except the {ctag}, are encoded as shown in
xref:cap_encoding_xlen32[xrefstyle=short] for {rvy32_uni_base_name} and
xref:cap_encoding_xlen64[xrefstyle=short] for {rvy64_uni_base_name}. Each memory location
or register able to hold a capability must also store the {ctag} as _out of band_ or _hidden_
information that software cannot directly set or clear. The capability metadata
is held in the most significant bits and the address is held in the least
significant bits.

.Capability encoding for {rvy32_uni_base_name}
[#cap_encoding_xlen32]
include::img/cap-encoding-xlen32.edn[]

.Capability encoding for {rvy64_uni_base_name}
[#cap_encoding_xlen64]
include::img/cap-encoding-xlen64.edn[]

Reserved bits are available for future extensions to {rvy_uni_base_name}.

NOTE: The <<zylevels1_gl_perm,GL>> flag is only available if <<section_zylevels1>> is implemented, otherwise it is reserved

NOTE: Reserved bits must be 0 in valid capabilities.

The encoding of capabilities depends on the extensions supported by the current environment.
The following extensions affect the capability encoding:

<<section_cheri_hybrid_ext>>::
When {cheri_default_ext_name} is supported, capabilities include an <<m_bit>> which is included in the specification below.
If not supported the <<m_bit>> is reserved and reads as zero.

<<section_zylevels1>>::
The base definition of capabilities in {rvy_uni_base_name} does not have capability-mediated Information Flow Control (IFC) mechanisms.
<<section_zylevels1>> is available for this and other schemes are likely in the future to add more levels.

[#AP-field-encoding, reftext="AP-field encoding"]
==== Architectural Permissions (AP) Encoding

The bit width of the permissions field depends on the value of MXLEN as shown
in xref:perms_bit_width[xrefstyle=short]. A {cap_rv32_perms_width}-bit vector
encodes the permissions when {rvy32_uni_base_name}. For this case, the legal encodings of
permissions are listed in xref:cap_perms_encoding32[xrefstyle=short]. Certain
combinations of permissions are impractical. For example, <<c_perm>> is
superfluous when the capability does not grant either <<r_perm>> or <<w_perm>>.
Therefore, it is only possible to encode a subset of all combinations.

.Permissions widths depending on MXLEN
[#perms_bit_width,options=header,align="center",width="80%",cols="^13%,^27%,<60%"]
|==============================================================================
^| MXLEN | <<AP-field>> width     | Comment
^| 32    | {cap_rv32_perms_width} | Encodes some combinations of {cap_rv64_perms_width} permission bits, including the <<m_bit>> if {cheri_default_ext_name} is supported.
^| 64    | {cap_rv64_perms_width} | Separate bits for each architectural permission.
|==============================================================================

For {rvy32_uni_base_name}, the permissions encoding is split into four quadrants.
The quadrant is taken from bits [4:3] of the permissions encoding.
The meaning for bits [2:0] are shown in <<cap_perms_encoding32>> for each quadrant.

Quadrants 2 and 3 are arranged to implicitly grant future permissions which may be added with the existing allocated encodings.
Quadrant 0 does the opposite - the encodings are allocated _not_ to implicitly add future permissions, and so granting future permissions will require new encodings.
Quadrant 1 encodes permissions for executable capabilities and the <<m_bit>>.

<<<
[#default-cap-AP-no-zylevels1]
==== AP encoding and rules without <<section_zylevels1>> for {rvy32_uni_base_name}

.Encoding of architectural permissions for {rvy32_uni_base_name} without <<section_zylevels1>>
[#cap_perms_encoding_nolevels32,width="100%",options=header,cols="^2,^1,^1,^1,^1,^1,^1,^1,4",align="center"]
|==============================================================================
9+| *Quadrant 0: Non-capability data read/write*
9+| bit[2] - write, bit[1] - reserved (0), bit[0] - read
9+| _Reserved bits for future extensions are 0 so new permissions are not implicitly granted_
| Field[2:0] | R | W | C | LM | X | ASR | Mode^1^ | Notes
| 0   |   |   |   |   |     |   | N/A | No permissions
| 1   | ✔ |   |   |   |     |   | N/A | Data RO
| 2-3   8+| reserved
| 4   |   | ✔ |   |   |     |   | N/A | Data WO
| 5   | ✔ | ✔ |   |   |     |   | N/A | Data RW
| 6-7   8+| reserved
9+| *Quadrant 1: Executable capabilities*
9+| bit[0] - <<m_bit>> ({CAP_MODE_VALUE}-{cheri_cap_mode_name}, {INT_MODE_VALUE}-{cheri_int_mode_name})
| Field[2:0] | R | W | C | LM | X | ASR | Mode^1^ | Notes
| 0-1   | ✔ | ✔ | ✔ | ✔ | ✔ |  ✔  | Mode^1^  | Execute + Data & Cap RW + ASR
| 2-3   | ✔ |   | ✔ | ✔ | ✔ |     | Mode^1^  | Execute + Data & Cap RO
| 4-5   | ✔ | ✔ | ✔ | ✔ | ✔ |     | Mode^1^  | Execute + Data & Cap RW
| 6-7   | ✔ | ✔ |   |   | ✔ |     | Mode^1^  | Execute + Data RW
9+| *Quadrant 2: Restricted capability data read/write*
9+| R and C implicitly granted, LM dependent on W permission.
9+| _Reserved bits for future extensions must be 1 so they are implicitly granted_
9+| _bit[2] is reserved to mean write for future encodings_
| Field[2:0] | R | W | C | LM | X | ASR | Mode^1^ | Notes
| 0-2   8+| reserved
| 3       | ✔ |   | ✔ |   |   |     | N/A | Data & Cap RO (no LM)
| 4-7   8+| reserved
9+| *Quadrant 3: Capability data read/write*
9+| bit[2] - write, R and C implicitly granted.
9+| _Reserved bits for future extensions must be 1 so they are implicitly granted_
| Field[2:0] | R | W | C | LM | X | ASR | Mode^1^ | Notes
| 0-2   8+| reserved
| 3       | ✔ |   | ✔ | ✔ |   |     | N/A | Data & Cap RO
| 4-6   8+| reserved
| 7       | ✔ | ✔ | ✔ | ✔ |   |     | N/A | Data & Cap RW
|==============================================================================

^1^ _Mode (<<m_bit>>) can only be set on a valid capability when {cheri_default_ext_name}
is supported. Despite being encoded here it is *not* an architectural permission._

NOTE: When {rvy32_uni_base_name} there are many reserved permission encodings (see
xref:cap_perms_encoding32[xrefstyle=short]). It is not possible for a valid
capability to have one of these values since <<CLRPERM>> will never create it. It is
possible for invalid capabilities to have reserved values. <<GCPERM>> will interpret
reserved values as if they were 0b00000 (no permissions). Future extensions may assign
meanings to the reserved bit patterns, in which case <<GCPERM>> is allowed to report a
non-zero value.

NOTE: Mode is encoded with permissions for {rvy32_uni_base_name}, but is not a permission. It is
orthogonal to permissions as it can vary arbitrarily using <<SCMODE>>.

This encoding's compressed permission format
specifies a _particular procedure_ for encoding architectural permissions,
which is used _instead of_ <<CLRPERM>>'s default fixed-pointing procedure.
If <<section_zylevels1>> is absent, the following rules are run once _in order_:

[#clrperm-rules-no-zylevels1]
.{rvy32_uni_base_name} <<CLRPERM>> rules if <<section_zylevels1>> is absent.
[float="center",align="center",cols="2,2,4",options="header"]
|===
| <<CLRPERM>> Rule | Permission   | Valid only if
| RV32-base-1      | <<c_perm>>   | <<r_perm>> (supersedes <<perm_req:base:c:r-or-w>>)
| RV32-base-2      | <<x_perm>>   | <<r_perm>>
| RV32-base-3      | <<w_perm>>   | not(<<c_perm>>) or <<lm_perm>>
| RV32-base-4      | <<x_perm>>   | <<w_perm>> or <<c_perm>>
| RV32-base-5      | <<lm_perm>>  | <<c_perm>> (supersedes <<perm_req:base:lm:c-and-r>>)
| RV32-base-6      | <<x_perm>>   | (<<c_perm>> and <<lm_perm>>) or not (<<c_perm>> or <<lm_perm>>)
| RV32-base-7      | <<asr_perm>> | <<w_perm>> and <<c_perm>> and <<x_perm>> (supersedes <<perm_req:base:asr:x>>)
| RV32-base-8      | <<m_bit>>    | <<x_perm>> and {cheri_default_ext_name} is implemented
|===

[#default-cap-AP-zylevels1]
==== AP encoding and rules with <<section_zylevels1>> for {rvy32_uni_base_name}

.Encoding of architectural permissions for {rvy32_uni_base_name} with <<section_zylevels1>>
[#cap_perms_encoding32,width="100%",options=header,cols="^2,^1,^1,^1,^1,^1,^1,^1,^1,^1,4",align="center"]
|==============================================================================
11+| *Quadrant 0: Non-capability data read/write*
11+| bit[2] - write, bit[1] - reserved (0), bit[0] - read
11+| _Reserved bits for future extensions are 0 so new permissions are not implicitly granted_
|Field[2:0]| R | W | C | LM | LG | SL | X | ASR | Mode^1^ | Notes
| 0   |   |   |   |   |   |   |   |   | N/A | No permissions
| 1   | ✔ |   |   |   |   |   |   |   | N/A | Data RO
| 2-3   10+| reserved
| 4   |   | ✔ |   |   |   |   |   |   | N/A | Data WO
| 5   | ✔ | ✔ |   |   |   |   |   |   | N/A | Data RW
| 6-7   10+| reserved
11+| *Quadrant 1: Executable capabilities*
11+| bit[0] - <<m_bit>> ({CAP_MODE_VALUE}-{cheri_cap_mode_name}, {INT_MODE_VALUE}-{cheri_int_mode_name})
|Field[2:0]| R | W | C | LM | LG | SL | X | ASR | Mode^1^ | Notes
| 0-1   | ✔ | ✔ | ✔ | ✔  | ✔  | ✔ | ✔ |  ✔  | Mode^1^  | Execute + Data & Cap RW + ASR
| 2-3   | ✔ |   | ✔ | ✔  | ✔  |   | ✔ |     | Mode^1^  | Execute + Data & Cap RO
| 4-5   | ✔ | ✔ | ✔ | ✔  | ✔  | ✔ | ✔ |     | Mode^1^  | Execute + Data & Cap RW
| 6-7   | ✔ | ✔ |   |    |    |   | ✔ |     | Mode^1^  | Execute + Data RW
11+| *Quadrant 2: Restricted capability data read/write*
11+| bit[2] = write, bit[1] reserved, bit[0] = !SL. R and C implicitly granted, LM dependent on W permission.
|Field[2:0]| R | W | C | LM | LG | SL | X | ASR | Mode^1^ | Notes
| 0-2   10+| reserved
| 3       | ✔ |   | ✔ |    |    |   |   |     | N/A | Data & Cap R0 (without <<lm_perm>>)
| 4-5  10+| reserved
| 6       | ✔ | ✔ | ✔ | ✔  |    | ✔ |   |     | N/A | Data & Cap RW (with <<zylevels1_sl_perm>>, no <<zylevels1_lg_perm>>)
| 7       | ✔ | ✔ | ✔ | ✔  |    |   |   |     | N/A | Data & Cap RW (no <<zylevels1_sl_perm>>, no <<zylevels1_lg_perm>>)
11+| *Quadrant 3: Capability data read/write*
11+| bit[2] = write, bit[1] reserved, bit[0] = !SL. R and C implicitly granted.
11+| _Reserved bits for future extensions must be 1 so they are implicitly granted_
|Field[2:0]| R | W | C | LM | LG | SL | X | ASR | Mode^1^ | Notes
| 0-2   10+| reserved
| 3       | ✔ |   | ✔ | ✔  | ✔  |   |   |     | N/A | Data & Cap R0
| 4-6   10+| reserved
| 6       | ✔ | ✔ | ✔ | ✔  | ✔  | ✔ |   |     | N/A | Data & Cap RW (with <<zylevels1_sl_perm>>)
| 7       | ✔ | ✔ | ✔ | ✔  | ✔  |   |   |     | N/A | Data & Cap RW (no <<zylevels1_sl_perm>>)
|==============================================================================

^1^ _Mode (<<m_bit>>) can only be set on a valid capability when {cheri_default_ext_name}
is supported, otherwise such encodings are reserved. Despite being encoded here it is *not* an architectural permission._

The following rules are run once _in order_:

[#clrperm-rules-zylevels1]
.{rvy32_uni_base_name} <<CLRPERM>> rules if <<section_zylevels1>> is present.
[float="center",align="center",cols="2,2,4",options="header"]
|===
| <<CLRPERM>> Rule | Permission            | Valid only if
| RV32-l1-1        | <<c_perm>>            | <<r_perm>> (supersedes <<perm_req:base:c:r-or-w>>)
| RV32-l1-2        | <<x_perm>>            | <<r_perm>>
| RV32-l1-3        | <<w_perm>>            | not(<<c_perm>>) or <<lm_perm>>
| RV32-l1-4        | <<x_perm>>            | <<w_perm>> or <<c_perm>>
| RV32-l1-5        | <<lm_perm>>           | <<c_perm>> (supersedes <<perm_req:base:lm:c-and-r>>)
| RV32-l1-6        | <<lm_perm>>           | <<w_perm>> or <<zylevels1_lg_perm>>
| RV32-l1-7        | <<zylevels1_lg_perm>> | <<lm_perm>> (supersedes <<perm_req:zylevels1:lg:c-and-r>>)
| RV32-l1-8        | <<zylevels1_sl_perm>> | <<lm_perm>> and <<w_perm>> (supersedes <<perm_req:zylevels1:sl:c-and-w>>)
| RV32-l1-9        | <<x_perm>>            |
  (<<c_perm>> and <<lm_perm>> and <<zylevels1_lg_perm>> and <<zylevels1_sl_perm>>) or +
  (<<c_perm>> and <<lm_perm>> and <<zylevels1_lg_perm>> and not <<w_perm>>) or +
  not (<<c_perm>> or <<lm_perm>> or <<zylevels1_lg_perm>> or <<zylevels1_sl_perm>>)
| RV32-l1-10       | <<asr_perm>>          | <<w_perm>> and <<c_perm>> and <<x_perm>> (supersedes <<perm_req:base:asr:x>>)
| RV32-l1-11       | <<m_bit>>             | <<x_perm>> and {cheri_default_ext_name} is implemented
|===

For RV32, the encodings which have the <<m_bit>> set to {int_mode_value} for {cheri_int_mode_name}
are only valid if {cheri_default_ext_name} is implemented.
Otherwise those encodings represent invalid permissions.

When {rvy64_uni_base_name}, there is a bit per permission as shown in xref:cap_perms_encoding64[xrefstyle=short].
A permission is granted if its corresponding bit, and those of any dependent permissions, are set;
otherwise, the capability does not grant that permission.

<<<

.Encoding of architectural permissions for {rvy64_uni_base_name}
[#cap_perms_encoding64,align="center",options=header,cols="^10%,90%",width="75%"]
|==============================================================================
| Bit | Encoded permission
| 0   | <<c_perm>>
| 1   | <<w_perm>>
| 2   | <<r_perm>>
| 3   | <<x_perm>>
| 4   | <<asr_perm>>
| 5   | <<lm_perm>>
| 6   | <<zylevels1_lg_perm>> if <<section_zylevels1>> is implemented; reserved otherwise.
| 7   | <<zylevels1_sl_perm>> if <<section_zylevels1>> is implemented; reserved otherwise.
|==============================================================================

The <<m_bit>> is only assigned meaning when the
implementation supports {cheri_default_ext_name} _and_ <<x_perm>> is set.

. For {rvy64_uni_base_name}, the bit assigned to the <<m_bit>> must be zero if <<x_perm>> isn't set.
. For {rvy32_uni_base_name}, the <<m_bit>> is only encoded in quadrant 1 and does _not_ exist in the other quadrants.

NOTE: Future extensions may allow more combinations of permissions, especially for {rvy64_uni_base_name}.

NOTE: Future extensions may define new dependent permissions and, if so, must augment the above table.

[#SDP-field, reftext="SDP-field"]
==== Software-Defined Permissions (SDP) Encoding

ifdef::cheri_v9_annotations[]
NOTE: *CHERI v9 Note:* CHERI v9 had no software-defined permissions for RV32
endif::[]

The width of the <<SDP-field>> depends on the underlying base architecture.
The value of the <<SDP-field>> bits of the <<GCPERM>> result maps 1:1 to the <<SDP-field>> in the capability.

.SDP widths depending on MXLEN
[#sdp_bit_width,options=header,align="center",width="55%"]
|==============================================================================
^| MXLEN   ^| SDPLEN
^| 32      ^| {cap_rv32_sdp_width}
^| 64      ^| {cap_rv64_sdp_width}
|==============================================================================

NOTE: Software is completely free to define the usage of these bits.

[#section_cap_sealed]
==== Capability Type (CT) Encoding

ifdef::cheri_v9_annotations[]
WARNING: *CHERI v9:* There is now a 1-bit otype (sentry or unsealed) and the old CHERI v9 otype no longer exists.
The base CHERI-RISC-V standard does not have support for CHERI v9 CSEAL for sealed capabilities with object types and only has <<SENTRY>> for sealed entry (sentry) capabilities.
endif::[]

#Begin changed since last ARC review#

The capabilities of this chapter define a 1-bit field for <<sec_cap_type>> values;
this field directly encodes the values `0` and `1`.
The value `1` is...

* considered <<sec_cap_type_ambient,ambiently available>> for <<CBLD>>,

* used as the type for capabilities sealed by <<SENTRY>> instructions,
  regardless of the input capability's permission,
  if <<section_rvy_sentry_insn_ext>> is present in the platform.

Additionally, <<JALR_CHERI>> both

* unseals input capabilities of type 1 and

* seals its return capabilities with type 1.

<<JALR_CHERI>> places no constraints on the triple of input <<sec_cap_type>> value, `{cd}` selector, and `{cs1}` selector.
That is, <<JALR_CHERI>> will, as directed, attempt to jump to any unsealed or sealed capability in any register regardless of which register comes to hold the sealed return pointer.

ifdef::cheri_standalone_spec[]
[NOTE]
=====
The permission encodings of <<AP-field-encoding>> do not provide mappings for
the <<section_zyseal>> extension's <<zyseal_se_perm>> or <<zyseal_us_perm>>.
Thus, without further revision, the encodings of this chapter
are incompatible with the <<section_zyseal>> extension.
=====
endif::[]

#End changed since last ARC review#

[#section_cap_bounds]
==== Bounds (EF, T, TE, B, BE) Encoding

===== Concept

ifdef::cheri_v9_annotations[]
NOTE: *CHERI v9 Note:* The bounds mantissa width is different in {rvy32_uni_base_name}.
Also, the old IE bit is renamed to Exponent Format (EF); the function of IE
is the inverse of EF, i.e., IE=0 has the same effect as EF=1.

NOTE: *CHERI v9 Note:* The mantissa width for RV32 was increased to 10.

NOTE: *CHERI v9 Note:* The sense of the exponent is reversed, so an encoded
value of 0 represents CAP_MAX_E, and CAP_MAX_E represents 0 from the previous
specification.
endif::[]

The bounds encode the base and top addresses that constrain memory accesses.
The capability can be used to access any memory location A in the range base
&#8804; A < top. The bounds are encoded in a compressed format, so it is not
possible to encode any arbitrary combination of base and top addresses. An
invalid capability with {ctag} cleared is produced when attempting to construct a
capability that is not _representable_ because its bounds cannot be correctly
encoded. The bounds are decoded as described in
xref:section_cap_encoding[xrefstyle=short].

The bounds field has the following components:

* *T:* Value substituted into the capability's address to decode the top
address
* *B:* Value substituted into the capability's address to decode the base
address
* *E:* Exponent that determines the position at which B and T are substituted
into the capability's address
* *EF:* Exponent format flag indicating the encoding for T, B and E
    ** The exponent is stored in T and B if EF=0, so it is 'internal'
    ** The exponent is zero if EF=1

The bit width of T and B are defined in terms of the mantissa width (MW) which
is set depending on the value of MXLEN as shown in
xref:mantissa_bit_width[xrefstyle=short].

.Mantissa width (MW) values depending on MXLEN
[#mantissa_bit_width,options=header,align="center",width="55%"]
|==============================================================================
^| MXLEN   ^| MW
^| 32      ^| {cap_rv32_mw_width}
^| 64      ^| {cap_rv64_mw_width}
|==============================================================================

The exponent E indicates the position of T and B within the capability's
address as described in xref:section_cap_encoding[xrefstyle=short]. The bit
width of the exponent (EW) is set depending on the value of MXLEN. The
maximum value of the exponent is calculated as follows:

```
CAP_MAX_E = MXLEN - MW + 2
```

The possible values for EW and CAP_MAX_E are shown in
xref:exp_bit_width[xrefstyle=short].

.Exponent widths and CAP_MAX_E depending on MXLEN
[#exp_bit_width,options=header,align="center",width="55%"]
|==============================================================================
^| MXLEN   ^| EW                   ^| CAP_MAX_E
^| 32      ^| {cap_rv32_exp_width} ^| 24
^| 64      ^| {cap_rv64_exp_width} ^| 52
|==============================================================================

NOTE: The address and bounds must be representable in valid capabilities i.e.,
when the {ctag} is set (see xref:section_cap_malformed[xrefstyle=short]).

[#section_cap_bounds_decoding]
===== Decoding

The metadata is encoded in a compressed format termed CHERI Concentrate cite:[woodruff2019cheri]. It
uses a floating point representation to encode the bounds relative to the
capability address. The base and top addresses from the bounds are decoded as
shown below.

WARNING: The pseudocode below does not have a formal notation.
It is a place-holder until the sail implementation has been integrated in the specification.
In this notation, `/` means "integer division", `[]` are the bit-select operators, and arithmetic is signed.

ifdef::cheri_v9_annotations[]
NOTE: *CHERI v9 Note:* The IE bit from CHERI v9 is renamed EF and its value is
inverted to ensure that the <<null-cap>> capability is encoded as zero without the
need for CHERI v9's in-memory format. +
When EF=1, the exponent E=0, so the address bits a[MW - 1:0] are replaced
with T and B to form the top and base addresses respectively. +
When EF=0, the exponent `E=CAP_MAX_E - ( (MXLEN == 32) ? { L8, TE, BE } : { TE, BE } )`,
so the address bits a[E + MW - 1:E] are replaced with T and B to form the top
and base addresses respectively. E is computed by subtracting from the maximum
possible exponent CAP_MAX_E which can be efficiently implemented in hardware
assuming that T and B are at bit CAP_MAX_E and performing a logical bitwise
shift right by E. In contrast, CHERI v9 implementations computed the top and
base addresses by assuming that T and B are at bit 0 and performing a logical
bitwise shift left by E.
endif::[]

```
EW        = (MXLEN == 32) ? 5 : 6
CAP_MAX_E = MXLEN - MW + 2

If EF = 1:
    E               = 0
    T[EW / 2 - 1:0] = TE
    B[EW / 2 - 1:0] = BE
    LCout           = (T[MW - 3:0] < B[MW - 3:0]) ? 1 : 0
    LMSB            = (MXLEN == 32) ? L8 : 0
else:
    E               = CAP_MAX_E - ( (MXLEN == 32) ? { L8, TE, BE } : { TE, BE } )
    T[EW / 2 - 1:0] = 0
    B[EW / 2 - 1:0] = 0
    LCout           = (T[MW - 3:EW / 2] < B[MW - 3:EW / 2]) ? 1 : 0
    LMSB            = 1
```

Reconstituting the top two bits of T:

```
T[MW - 1:MW - 2] = B[MW - 1:MW - 2] + LCout + LMSB
```

The bounds are decoded as shown in xref:top_bound_dec[xrefstyle=short] and
xref:base_bound_dec[xrefstyle=short].

.Decoding of the MXLEN+1 wide top (_t_) bound
[#top_bound_dec]
include::img/top-bound-dec.edn[]

.Decoding of the MXLEN wide base (_b_) bound
[#base_bound_dec]
include::img/base-bound-dec.edn[]

xref:top_bound_dec[xrefstyle=short] and xref:base_bound_dec[xrefstyle=short]
include ranges which may not be present when the bounds are decoded:

* If E = 0 the lower section does not exist.
* If E+MW=MXLEN then the top section is only the least signification bit of
 c~t~ for the top bound, and top section doesn't exist for the bottom bound.
* If E+MW>MXLEN then neither top section exists, and so the bounds are calculated
 with no depending on the address field _a_.

The corrections c~t~ and c~b~ are calculated as as shown below using the
definitions in xref:cap_encoding_ct[xrefstyle=short] and
xref:cap_encoding_cb[xrefstyle=short].

[subs="quotes"]
----
A[MW-1:0] = a[E + MW - 1:E]
R[MW-1:0] = B - 2^MW-2^
----

NOTE: The comparisons in xref:cap_encoding_ct[xrefstyle=short] and
xref:cap_encoding_cb[xrefstyle=short] are _unsigned_.

.Calculation of top address correction
[#cap_encoding_ct,options=header,cols="^1,^1,^1",width="40%",align="center"]
|==============================================================================
| A < R    | T < R    | c~t~
| false    | false    | 0
| false    | true     | +1
| true     | false    | -1
| true     | true     | 0
|==============================================================================

.Calculation of base address correction
[#cap_encoding_cb,options=header,cols="^1,^1,^1",width="40%",align="center"]
|==============================================================================
| A    < R | B    < R | c~b~
| false    | false    | 0
| false    | true     | +1
| true     | false    | -1
| true     | true     | 0
|==============================================================================

The base, _b_, and top, _t_, addresses are derived from the address by
substituting _a_[E + MW - 1:E] with B and T respectively and clearing the
lower E bits.  The most significant bits of _a_ may be adjusted up or down by 1
using corrections _c~b~_ and _c~t~_ to allow encoding memory regions that span
alignment boundaries.

The EF bit selects between two cases:

1. EF = 1: The exponent is 0. When {rvy32_uni_base_name}, L~8~ encodes the MSB of the length,
which can be used to derive T[MW-1:MW-2], forming a full MW-wide T field.
2. EF = 0: The exponent is _internal_ with E stored in the lower bits of T and
B, with L~8~ used for the MSB of E when {rvy32_uni_base_name}. E is chosen so that the most
significant non-zero bit of the length of the region aligns with T[MW - 2] such
that this bit is implied by E.

The most significant two bits of T can be derived from B using
the equality `T = B + L`, where L[MW - 2] is known from the values of EF and E
(as well as L~8~ when {rvy32_uni_base_name}).
A carry out is implied if `T[MW - 3:0] < B[MW - 3:0]` since it is
guaranteed that the top is larger than the base.

The compressed bounds encoding allows the address to roam over a large
_representable_ region while maintaining the original bounds. This is enabled by
defining a lower boundary R from the out-of-bounds values that allows us to
disambiguate the location of the bounds with respect to an out-of-bounds address.
R is calculated
relative to the base by subtracting 2^MW-2^ from B.
If B, T or _a_[E + MW - 1:E] is less than R, it is inferred that they lie in the
2^E+MW^ aligned region above R labeled space~U~ in
xref:cap_bounds_map[xrefstyle=short] and the corrections _c~t~_ and _c~b~_ are
computed accordingly. The overall effect is that the address can roam
2^E+MW^/4 bytes below
the base address and at least 2^E+MW^/4 bytes above the top address
while still allowing the bounds to be correctly decoded.

//[#cap_bounds_map] moved to intro chapter
//.Memory address bounds encoded within a capability
//image::../cheri/img/cap-bounds-map.png[width=80%,align=center]

[#t_bound_msb_inversion]
===== Top bound MSB correction

A capability has _infinite_ bounds if its bounds cover the entire address space
such that the base address _b_=0 and the top address _t_&#8805;2^MXLEN^,
i.e., _t_ is an MXLEN + 1 bit value. However, _b_ is an
MXLEN-bit value and the size mismatch introduces additional complications
when decoding, so the following condition is required to correct _t_ for
capabilities whose <<section_cap_representable_check>> wraps the edge of the address
space:D

```
if ( (E < (CAP_MAX_E - 1)) & (t[MXLEN: MXLEN - 1] - b[MXLEN - 1] > 1) )
    t[MXLEN] = !t[MXLEN]
```
NOTE: The comparison is _unsigned_.

That is, invert the most significant bit of _t_ if the decoded length of the
capability is larger than E.

NOTE: A capability has infinite bounds if E=CAP_MAX_E and it is not
malformed (see xref:section_cap_malformed[xrefstyle=short]); this check is
equivalent to _b_=0 and _t_&#8805;2^MXLEN^.

[#section_cap_malformed]
===== Malformed Capability Bounds

A capability is _malformed_ if its bounds cannot be correctly decoded.
The following check
indicates whether a capability is malformed. `enableL8` is true when {rvy32_uni_base_name}
and false otherwise, indicating whether the `L8` bit is available for extra
precision when `EF=1`.

```
malformedMSB =  (E == CAP_MAX_E     && B         != 0)
             || (E == CAP_MAX_E - 1 && B[MW - 1] != 0)
malformedLSB =  (E  < 0) || (E == 0 && enableL8)
malformed    =  !EF && (malformedMSB || malformedLSB)
```

Capabilities with malformed bounds:

. Return both base and top bounds as zero, which affects instructions like <<GCBASE>>.
. Cause certain manipulation instructions like <<CADDI>> to always set the {ctag} of the result to zero.

===== <<AUIPC_CHERI>> Shift

#Begin new since last ARC review#

For the capabilities of this chapter, the <<section_auipc_shift>> value is 12.
The bounds encodings just described, for both 32- and 64-bit addresses,
have sufficient <<section_rep_check_concept,representability>> that no
<<AUIPC_CHERI>> instruction used to reach an in-bounds offset
will clear the {ctag}.

#End new since last ARC review#

[#section_cap_integrity]
=== Integrity of Capabilities

CHERI enforces the following rules for all valid capabilities:

. The bounds are not <<section_cap_malformed,malformed>>.
. No reserved bit in the capability encoding is set.
. The permissions can be legally produced by <<CLRPERM>>.

In all cases the capability could not have been legally created, and so either:

* There has been a corruption of capability state due to memory or logic faults
* There is an incompatible or faulty CHERI IP within the system

NOTE: These checks are much less rigorous than parity or ECC protection, and are only
 used to detect simple problems with the capability metadata.

NOTE: Even though valid capabilities which fail the integrity check could not have been legally generated by the local hart,
 defining the handling in the architecture allows the behavior to be precisely specified for all 2^(YLEN+1)^ input values.

Implementing these checks is optional unless otherwise noted in instruction descriptions, as integrity failures are most likely due to IP compatibility issues.

NOTE: Currently only {CBLD} _must_ perform an integrity check on an invalid input capability in `{cs2}` before setting the {ctag} of the output.
 This is because this is the only currently defined instruction which sets the `{ctag}` of an invalid capability.

[#section_special_caps_encoding]
=== Encoding of Special Capabilities

[#section_null_cap_encoding]
==== NULL Capability Encoding

ifdef::cheri_v9_annotations[]
NOTE: *CHERI v9 Note:* Encoding <<null-cap>> as zeros removes the need for
the difference between in-memory and architectural format.
endif::[]

The <<null-cap>> capability is represented with 0 in all fields. This implies
that it has no permissions and its exponent E is CAP_MAX_E (52 for {rvy64_uni_base_name},
24 for {rvy32_uni_base_name}), so its bounds cover the entire address space such that the
expanded base is 0 and top is 2^MXLEN^.

.Field values of the NULL capability
[#null-cap-encoding,reftext="NULL",options=header,align=center,width="70%",cols="25,23,52"]
|==============================================================================
| Field    | Value  | Comment
| {ctag_title}             | zero   | Capability is not valid
| <<SDP-field,SDP>>        | zeros  | Grants no permissions
| <<AP-field,AP>>          | zeros  | Grants no permissions
| <<M-bit,M>>              | zero   | No meaning since non-executable ({rvy64_uni_base_name} and {cheri_default_ext_name} only)
| CT       | zero   | Unsealed
| EF       | zero   | Internal exponent format
| L~8~     | zero   | Top address reconstruction bit ({rvy32_uni_base_name} only)
| T        | zeros  | Top address bits
| T~E~     | zeros  | Exponent bits
| B        | zeros  | Base address bits
| B~E~     | zeros  | Exponent bits
| Address  | zeros  | Capability address
| Reserved | zeros  | All reserved fields
|==============================================================================

Permissions added by extensions (such as those of <<section_zylevels1>>) are presumed absent in NULL capabilities.

[#section_infinite_cap_encoding]
==== Infinite Capability Encoding

This encoding is for an _Infinite_ capability value, which
grants all permissions while its bounds also cover the whole address space.
It includes <<x_perm>> and so includes the <<m_bit>> if {cheri_default_ext_name} is supported.
This infinite capability is both a <<root-rx-cap>> and a <<root-rw-cap>> capability.

// Added note here for CHERIoT which enforces W xor X.
NOTE: This capability format has a single encoding for the _Infinite_ capability. The CHERIoT encoding format has separate roots for code and for data, and will be included in a future version of this specification.

.Field values of the Infinite capability
[#infinite-cap-encoding,reftext="Infinite"]
[options=header,align=center,width="90%",cols="25,23,52"]
|==============================================================================
| Field         | Value | Comment
| {ctag_title}  | one   | Capability is valid
| SDP           | ones  | Grants all permissions
| AP ({rvy32_uni_base_name}) | 0x8/0x9^1^  (see xref:cap_perms_encoding32[xrefstyle=short])
                        | Grants all permissions
| AP ({rvy64_uni_base_name}) | 0xFF (see xref:cap_perms_encoding64[xrefstyle=short])
                        | Grants all permissions
| CT            | zero  | Unsealed
| EF            | zero  | Internal exponent format
| L~8~          | zero  | Top address reconstruction bit ({rvy32_uni_base_name} only)
| T             | zeros | Top address bits
| T~E~          | zeros | Exponent bits
| B             | zeros | Base address bits
| B~E~          | zeros | Exponent bits
| Address       | zeros^2^ | Capability address
| Reserved      | zeros | All reserved fields
|==============================================================================

^1^If {cheri_default_ext_name} is supported, then the infinite capability must represent
{cheri_int_mode_name} for compatibility with standard RISC-V code. Therefore:

* For {rvy32_uni_base_name}, the <<m_bit>> is set to {INT_MODE_VALUE} in the <<AP-field>>, giving the value 0x9
* For {rvy64_uni_base_name}, the <<m_bit>> is set to {INT_MODE_VALUE} in a separate M field which is _not shown_ in the table above.

^2^If an infinite capability is used as a constant in either hardware or software, then the address field will typically be set to zero.
 If the address field is non-zero then it is still referred to as an infinite capability, and it still has the authority to authorize all memory accesses.

Permissions added by extensions (such as those of <<section_zylevels1>>) are presumed present in Infinite capabilities.

=== Memory space

A hart supporting {rvy_uni_base_name} has a single byte-addressable address
space of 2^XLEN^ bytes for all memory accesses. Each memory region capable of
holding a capability also stores a {ctag} bit for each naturally aligned YLEN bits
(e.g., 16 bytes in RV64), so that capabilities with their {ctag} set can only be
stored in naturally aligned addresses. {ctag_cap}s must be atomically bound to the
data they protect.

The memory address space is circular, so the byte at address
2^XLEN^ - 1 is adjacent to the byte at address zero. A capability's
<<section_cap_representable_check>> described in xref:section_cap_encoding[xrefstyle=short] is
also circular, so address 0 is within the <<section_cap_representable_check>> of a capability
where address 2^MXLEN^ - 1 is within the bounds.
However, the decoded top address of a capability is MXLEN + 1 bits wide and does *not* wrap, so
a capability with base 2^MXLEN^ - 1 and top 2^MXLEN^ + 1 is not a subset of the
infinite capability and does not authorize access to the byte at address 0.
Like malformed bounds (see xref:section_cap_malformed[xrefstyle=short]), it is impossible for
a CHERI core to generate a valid capability with top > 2^MXLEN^.
If such a capability exists then it must have been caused by a logic or memory fault.
Unlike malformed bounds, the top overflowing is not treated as a special case in the
architecture: normal bounds check rules should be followed.

[#section_cap_representable_check, reftext="Representable Range"]
=== Representable Range Check

The concept of the _representability check_ was introduced in <<section_rep_check_concept>>.

The definition of the check is:

* A source capability with address _a_, metadata _m_ that decodes to give the bounds _b_ and _t_.
* A derived capability with arbitrary address _a'_ with the same metadata _m_ that decodes to give the bounds _b'_ and _t'_.

The address _a'_ is within the source capability's _representable range_ if `b == b' && t == t'`.

If the address _a'_ is outside the _representable range_, then the derived capability has the {ctag} set to zero.

==== Practical Information

An artifact of the bounds encoding is that if the new address
causes `t != t'`, then it is also the case that `b != b'`.

The inverse is also true, if `b != b'` then `t != t'`.

Therefore, for representable range checking, it is acceptable
to either check `t == t'` or `b == b'`.

The top and bottom capability bounds are formed of two or three sections:

* Upper bits from the address
** This is only if the other sections do not fill the available bits (E + MW < MXLEN)
* Middle bits from T and B decoded from the metadata
* Lower bits are set to zero
** This is only if there is an internal exponent (EF=0)

.Composition of the decoded top address bound
[#comp_addr_bounds,options=header,align="center",cols="2,4,2,2"]
|==============================================================================
| Configuration   | Upper Section (if E + MW < MXLEN) | Middle Section | Lower Section
| EF=0            | address[MXLEN-1:E + MW] + ct | T[MW - 1:0] | {E{1'b0}}
| EF=1, i.e., E=0 | address[MXLEN-1:MW] + ct   2+| T[MW - 1:0]
|==============================================================================

The _representable range_ defines the range of addresses which do not corrupt
the bounds encoding. The encoding was first introduced in
xref:section_cap_encoding[xrefstyle=short], and is repeated in a different
form in xref:comp_addr_bounds[xrefstyle=short] to aid this description.

For the address to be valid for the current bounds encoding, the value
in the _Upper Section_ of xref:comp_addr_bounds[xrefstyle=short] _must
not change_ as this will change the meaning of the bounds.  This
is because `T`, `B` and `E` will be unchanged for the source and
destination capabilities.  Therefore, the Middle and Lower sections
of the bounds calculation are also unchanged for source and
destination capabilities.

When E > CAP_MAX_E - 2, the calculation of the top bound is entirely derived
from `T` and `E` which will be identical for both the source and destination
capabilities, thus guaranteeing that `t == t'`.  Likewise, with such values of E, the
base bound is entirely derived from `B` and `E` and therefore `b == b'`.

The calculation of the MSB of the top bound maybe inverted as specified
xref:t_bound_msb_inversion[xrefstyle=short].
Assuming `(E < (CAP_MAX_E - 1))`, the truth-table for this inversion is as follows:

.Top bound MSB inversion truth table
[#t_bound_msb_inversion_truth_table]
[options=header,align=center,width="100%"]
|==============================================================================
| input_t[MXLEN:MXLEN-1]  | b[MXLEN-1]  | output_t[MXLEN:MXLEN-1]
|      00                 |      0      | 00
|      01                 |      0      | 01
|      10                 |      0      | 00
|      11                 |      0      | 01
|     *00*                |     *1*     | *10*
|      01                 |      1      | 01
|     *10*                |     *1*     | *10*
|      11                 |      1      | 01
|==============================================================================

Inspection of xref:t_bound_msb_inversion_truth_table[xrefstyle=short] shows
that `output_t[MXLEN]` does not depend on `input_t[MXLEN]` as:

* `output_t[MXLEN] = {input_t[MXLEN-1], b[MXLEN-1]} == 2'b01`.

This leads to the conclusions:

* If `t[MXLEN-1] == t'[MXLEN-1]` and `b[MXLEN-1] == b'[MXLEN-1]`, then it is guaranteed `t[MXLEN] == t'[MXLEN]`.
* If `t[MXLEN-1] != t'[MXLEN-1]` or `b[MXLEN-1] != b'[MXLEN-1]`, then the representable check will fail regardless of checking `t[MXLEN] == t'[MXLEN]`.

Therefore, for the purpose of representable range checking, it is not
required to check that `t[MXLEN]==t'[MXLEN]`.

Given that `t[MXLEN]` is not part of the representable range check:

* when `E == CAP_MAX_E - 2`, `t[MXLEN-1:E] == T[MW-1:0]` and `b[MXLEN-1:E] == B[MW-1:0]`.

Therefore, `T` and `B` are both derived from the capabilities metadata and are
therefore constant.  Which means that in this case too, the representable
range check always passes.

As a result:

* If E > CAP_MAX_E - 3, then the representability check always passes, _even
though the bounds are only infinite if E = CAP_MAX_E_

This gives a range of `s=2^E+MW^`, as shown in
xref:cap_bounds_map[xrefstyle=short].

The gap between the object bounds and the bound of the representable range
is always guaranteed
to be at least 1/4 of `s`. This is represented by `R = B - 2^MW-2^` in
xref:section_cap_encoding[xrefstyle=short].
This gives useful guarantees, such that if an executed instruction is in
<<pcc>> bounds, then it is also guaranteed that the next linear instruction
is _representable_.
