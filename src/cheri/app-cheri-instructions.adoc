[#app_cheri_instructions]
== {cheri_base_ext_name} ISA Extension Summary

include::cheri_isa_tables.adoc[]

ifdef::cheri_standalone_spec[]

=== "Zcmp", "Zcmt" ({cheri_base_ext_name})

IMPORTANT: {not_v1_ratification_package}

[#ZCMP_CHERI,reftext="Zcmp ({cheri_base32_ext_name})"]
=== "Zcmp" Standard Extension For Code-Size Reduction

The push (<<CM_PUSH_CHERI>>) and pop (<<CM_POP_CHERI>>, <<CM_POPRET_CHERI>>, <<CM_POPRETZ_CHERI>>) instructions are redefined in {cheri_cap_mode_name} to save/restore capability data.

The double move instructions (<<CM_MVSA01_CHERI>>, <<CM_MVA01S_CHERI>>) are redefined in {cheri_cap_mode_name} to move capability data between registers. The saved register mapping is as shown in <<saved_register_mapping>>.

.saved register mapping for Zcmp
[#saved_register_mapping]
[width="100%",options=header, align="center"]
|====================================
| saved register specifier | xreg | integer ABI | {cheri_base32_ext_name} ABI
| 0                       | x8  | s0 | {abi_creg}s0
| 1                       | x9  | s1 | {abi_creg}s1
| 2                       | x18 | s2 | {abi_creg}s2
| 3                       | x19 | s3 | {abi_creg}s3
| 4                       | x20 | s4 | {abi_creg}s4
| 5                       | x21 | s5 | {abi_creg}s5
| 6                       | x22 | s6 | {abi_creg}s6
| 7                       | x23 | s7 | {abi_creg}s7
|====================================

include::insns/zcmp_cmpush.adoc[]

include::insns/zcmp_cmpop.adoc[]

include::insns/zcmp_cmpopret.adoc[]

include::insns/zcmp_cmpopretz.adoc[]

include::insns/zcmp_cmvsa01.adoc[]

include::insns/zcmp_cmva01s.adoc[]

<<<
[#ZCMT_CHERI,reftext="Zcmt ({cheri_base32_ext_name})"]
=== "Zcmt" Standard Extension For Code-Size Reduction

The table jump instructions (<<CM_JT_CHERI>>, <<CM_JALT_CHERI>>) are _not_ redefined in {cheri_cap_mode_name} to have capabilities in the jump table. This is to prevent the code-size growth caused by doubling the size of the jump table.

In the future, new jump table modes or new encodings can be added to have capabilities in the jump table.

The jump vector table CSR <<jvt_y>> is a full capability so that it can only be configured to point to accessible memory.
All accesses to the jump table are checked against <<jvt_y>> in {cheri_cap_mode_name}, and against <<pcc>> bounds in {cheri_int_mode_name}.
This allows the jump table to be accessed when the <<pcc>> bounds are set narrowly to the local function only in {cheri_cap_mode_name}.

NOTE: In {cheri_cap_mode_name} the instruction fetch bounds check is authorized by two different capabilities - <<jvt_y>> for the table access and <<pcc>> for the <<CM_JALT_CHERI>>/<<CM_JT_CHERI>> instruction, and target instruction.

NOTE: In {cheri_cap_mode_name} the implementation doesn't need to expand and bounds check against <<jvt_y>> on every access, it is sufficient to decode the valid accessible range of entries after every write to <<jvt_y>>, and then check that the accessed entry is in that range.

[#jvt_y,reftext="jvt ({cheri_base_ext_name})"]
==== Jump Vector Table CSR (jvt)

The Zcmt <<jvt>> CSR is extended to be a full capability.

.Jump Vector Table Capability register
include::img/jvtcreg.edn[]

All instruction fetches from the jump vector table are checked against <<jvt_y>> in {cheri_cap_mode_name}.
In {cheri_int_mode_name} the address field gives the base address of the table, and the access is checked against <<pcc>> bounds.

See <<CM_JALT_CHERI>>, <<CM_JT_CHERI>>.

If the access to the jump table succeeds, then the instructions execute as follows:

** <<CM_JT_CHERI>>   executes as <<JAL_CHERI,J>>   or <<AUIPC_CHERI,AUIPC>>+<<JALR_CHERI,JR>>
** <<CM_JALT_CHERI>> executes as <<JAL_CHERI,JAL>> or <<AUIPC_CHERI,AUIPC>>+<<JALR_CHERI,JALR>>

As a result the capability metadata is retained in <<pcc>> during execution.

include::insns/zcmt_cmjalt.adoc[]

include::insns/zcmt_cmjt.adoc[]

endif::[]

ifdef::cheri_standalone_spec[]

== ISA changes since 0.9.5

Many mnemonics have been renamed since v0.9.5 of the specification a shown in <<ISA_renames_095>>.

.ISA renames since 0.9.5
[#ISA_renames_095]
[width="100%",options=header,cols="2,2,2",]
|==============================================================================
include::generated/old_and_new_mnemonics_table_body.adoc[]
|==============================================================================

Some instructions have been added as shown in <<ISA_added_095>>.

.Instructions added since 0.9.5
[#ISA_added_095]
[width="100%",options=header,cols="2,2,2",]
|==============================================================================
include::generated/new_instructions_table_body.adoc[]
|==============================================================================

WARNING: {YSEAL} and {YUNSEAL} are not included in the v1.0 ratification package.

[NOTE]
====

. {SCHI_BASE} and {GCHI_BASE} are actual instructions. {SCHI} and {GCHI} are pseudoinstructions.
. ACPERM was replaced by {CLRPERM}. The difference being that the mask is used to clear, not retain, permission bits.
.. Clearing bits makes it much simpler to form the necessary constant compared to retaining bits, and so gives better code-size.
. 0.9.5 had SH[123]ADD, and the .UW forms, replaced by capability versions.
.. This is no longer the case, so now the capability versions have new encodings.
. There is no longer an SH4ADD instruction (i.e. the integer version).
. The <<{SENTRY}>> instruction is now in a separate extension {rvy_sentry_insn_ext_name}.

====

[NOTE]
====

The following changes are for forwards compatibility with {cheriot_ext_name}:

. Capability encodings are now the naming authorities for capability types (only 0/unsealed exists in the base architecture).
. Capability encodings are now in a separate extension - the default being <<app_cap_description,{rvy_uni_base_name}>>.
. <<JALR_CHERI>> has been given explicit hooks for sentry handling (especially for future forward/backward arc distinction).

====

endif::[]
