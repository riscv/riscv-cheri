[appendix]
[#app_cheri_instructions]
== {cheri_base_ext_name} ISA Extension Summary

include::cheri_isa_tables.adoc[]

ifdef::cheri_standalone_spec[]

=== "Zcmp", "Zcmt" ({cheri_base_ext_name})

{not_v1_ratification_package}

[#ZCMP_CHERI,reftext="Zcmp ({cheri_base32_ext_name})"]
=== "Zcmp" Standard Extension For Code-Size Reduction

The push (<<CM_PUSH_CHERI>>) and pop (<<CM_POP_CHERI>>, <<CM_POPRET_CHERI>>, <<CM_POPRETZ_CHERI>>) instructions are redefined in {cheri_cap_mode_name} to save/restore capability data.

The double move instructions (<<CM_MVSA01_CHERI>>, <<CM_MVA01S_CHERI>>) are redefined in {cheri_cap_mode_name} to move capability data between registers. The saved register mapping is as shown in <<saved_register_mapping>>.

.saved register mapping for Zcmp
[#saved_register_mapping]
[width="100%",options=header, align="center"]
|====================================
| saved register specifier | xreg | integer ABI | {cheri_base32_ext_name} ABI
| 0                       | x8  | s0 | {abi_creg}s0
| 1                       | x9  | s1 | {abi_creg}s1
| 2                       | x18 | s2 | {abi_creg}s2
| 3                       | x19 | s3 | {abi_creg}s3
| 4                       | x20 | s4 | {abi_creg}s4
| 5                       | x21 | s5 | {abi_creg}s5
| 6                       | x22 | s6 | {abi_creg}s6
| 7                       | x23 | s7 | {abi_creg}s7
|====================================

include::insns/zcmp_cmpush.adoc[]

include::insns/zcmp_cmpop.adoc[]

include::insns/zcmp_cmpopret.adoc[]

include::insns/zcmp_cmpopretz.adoc[]

include::insns/zcmp_cmvsa01.adoc[]

include::insns/zcmp_cmva01s.adoc[]

<<<
[#ZCMT_CHERI,reftext="Zcmt ({cheri_base32_ext_name})"]
=== "Zcmt" Standard Extension For Code-Size Reduction

The table jump instructions (<<CM_JT_CHERI>>, <<CM_JALT_CHERI>>) are _not_ redefined in {cheri_cap_mode_name} to have capabilities in the jump table. This is to prevent the code-size growth caused by doubling the size of the jump table.

In the future, new jump table modes or new encodings can be added to have capabilities in the jump table.

The jump vector table CSR <<jvt_y>> is a full capability so that it can only be configured to point to accessible memory.
All accesses to the jump table are checked against <<jvt_y>> in {cheri_cap_mode_name}, and against <<pcc>> bounds in {cheri_int_mode_name}.
This allows the jump table to be accessed when the <<pcc>> bounds are set narrowly to the local function only in {cheri_cap_mode_name}.

NOTE: In {cheri_cap_mode_name} the instruction fetch bounds check is authorized by two different capabilities - <<jvt_y>> for the table access and <<pcc>> for the <<CM_JALT_CHERI>>/<<CM_JT_CHERI>> instruction, and target instruction.

NOTE: In {cheri_cap_mode_name} the implementation doesn't need to expand and bounds check against <<jvt_y>> on every access, it is sufficient to decode the valid accessible range of entries after every write to <<jvt_y>>, and then check that the accessed entry is in that range.

[#jvt_y,reftext="jvt ({cheri_base_ext_name})"]
==== Jump Vector Table CSR (jvt)

The Zcmt <<jvt>> CSR is extended to be a full capability.

.Jump Vector Table Capability register
include::img/jvtcreg.edn[]

All instruction fetches from the jump vector table are checked against <<jvt_y>> in {cheri_cap_mode_name}.
In {cheri_int_mode_name} the address field gives the base address of the table, and the access is checked against <<pcc>> bounds.

See <<CM_JALT_CHERI>>, <<CM_JT_CHERI>>.

If the access to the jump table succeeds, then the instructions execute as follows:

** <<CM_JT_CHERI>>   executes as <<JAL_CHERI,J>>   or <<AUIPC_CHERI,AUIPC>>+<<JALR_CHERI,JR>>
** <<CM_JALT_CHERI>> executes as <<JAL_CHERI,JAL>> or <<AUIPC_CHERI,AUIPC>>+<<JALR_CHERI,JALR>>

As a result the capability metadata is retained in <<pcc>> during execution.

include::insns/zcmt_cmjalt.adoc[]

include::insns/zcmt_cmjt.adoc[]

endif::[]
