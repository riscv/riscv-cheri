[[rv32y]]
== {cheri_base32_ext_name} and {cheri_base64_ext_name} Base Capability Instruction Sets, Version 1.0

ifdef::cheri_standalone_spec[]
WARNING: This chapter will appear in the unpriv spec after the RV32I chapter.
endif::[]

This chapter describes the {cheri_base32_ext_name} and {cheri_base64_ext_name} base capability instruction sets, that extend the RV32I and RV64I integer instruction sets with CHERI.

CHERI enhances the base ISA to add hardware memory access control.
It has an additional memory access mechanism that protects _references to code and data_ (pointers), rather than the _location of code and data_ (integer addresses).
This mechanism is implemented by providing a new primitive, called a *capability*, that software components can use to implement strongly protected pointers within an address space.
Capabilities are unforgeable and delegatable tokens of authority that grant software the ability to perform a specific set of operations.
In CHERI, integer-based pointers are replaced by capabilities to provide memory access control.

=== CHERI protection model

The CHERI model is motivated by the _principle of least privilege_, which
argues that greater security can be obtained by minimizing the privileges
accessible to running software. A second guiding principle is the _principle of
intentional use_, which argues that, where many privileges are available to a
piece of software, the privilege to use should be explicitly named rather than
implicitly selected. While CHERI does not prevent the expression of vulnerable
software designs, it provides strong vulnerability mitigation: attackers have a
more limited vocabulary for attacks, and should a vulnerability be successfully
exploited, they gain fewer rights, and have reduced access to further attack
surfaces.

Protection properties for capabilities include the ISA ensuring that
capabilities are always derived via valid manipulations of other capabilities
(_provenance_), that corrupted^1^ in-memory capabilities cannot be dereferenced
(_integrity_), and that rights associated with capabilities shall only ever be
equal or less permissive (_monotonicity_). Tampering or modifying capabilities
in an attempt to elevate their rights will yield an invalid capability.
Attempting to dereference via an invalid capability
will result in a hardware exception.

^1^ #Not all possible corrupted states are detected, see XXX.#

CHERI capabilities may be held in registers or in memories, and are loaded,
stored, and dereferenced using CHERI-aware instructions that expect capability
operands rather than integer addresses. On system initialization, initial capabilities
are made available to software by the execution environment via general purpose
registers. All other capabilities will be derived from these initial valid
capabilities through valid capability transformations.

Developers can use CHERI to build fine-grained spatial and temporal memory
protection into their system software and applications and significantly
improve their security.

[#sec_capability_registers]
=== General purpose registers

#ARC note - CLEN will become YLEN#

{cheri_base_ext_name} extends the general purpose registers to `2*XLEN-bit` (hereafter referred to as CLEN), adding metadata to protect its integrity, limit how it is manipulated, and control its use.
In addition to widening to CLEN, each register also gains one-bit valid tag which is defined below.

{cheri_base_ext_name} specify the fields which the capability format supports, and how those fields behave for XLEN=32 and XLEN=64.

The exact encoding format of the capability is described in <<app_cap_description>>.

NOTE: Future extensions may redefine the capability format providing they follow the rules defined by the {cheri_base_ext_name} base ISA.

.CHERI Capability structure
[#cap_structure]
[bytefield]
----
(defattrs :plain [:plain {:font-family "M+ 1p Fallback" :font-size 25}])
(def row-height 80)
(def row-header-fn nil)
(def boxes-per-row 32)
(draw-column-headers {:height 50 :font-size 18 :labels (reverse (concat ["0"] (repeat 28 "") ["XLEN-1" "" ""]))})

(draw-box "V"    {:span 1})
(draw-box "" {:span 1 :borders {}})
(draw-box "Metadata (bounds, permissions, etc.)"    {:span 30})
(draw-box "" {:span 2 :borders {}})
(draw-box "Address"     {:span 30})
(draw-box "" {:span 2 :borders {}})
(draw-box "XLEN" {:span 30 :borders {}})
----

==== Address

The lower XLEN-bits of a capability encode the address of where the capability points.
This is also referred to as the integer part of the capability.
For registers that are extended but currently only hold integer data, all other fields are zero.

[#cap_validity_tag,reftext="valid tag"]
==== Valid Tag

#ARC note C registers will become Y registers#

The valid tag is an additional bit added to addressable memory and all CLEN-bit registers.
It is stored separately and may be referred to as _out of band_ or _hidden_, and is _hardware managed_.
It indicates whether a CLEN-bit register or CLEN-aligned memory location contains a valid capability.
If the valid tag is set, the capability is valid and can be dereferenced (contingent on checks such as permissions or <<sec_cap_bounds_overview,bounds>>).

All registers or memory locations able to hold a capability are CLEN-bits wide including the valid tag bit.
These are referred as being _CLEN-bit_ in this specification.

The valid tag cannot be directly set to 1 by software, it is _not_ a conventionally accessible bit of state.
If the tag valid is set then it shows that the capability has been derived correctly according to the principles listed above (_provenance_, _integrity_, _monotonicity_).
If the rules are followed then the valid tag will propagate through the instructions which modify, load or store the capability.

Therefore, for capability manipulation in registers:

* Any instruction which wrote the capability to a register had at least one valid tag set in its input operands.
** This is the _provenance_ check.
* Any instruction which wrote the capability to a register requested a legal operation which does not increase bounds or permissions, and set the valid tag on the output.
** This is the _monotonicity_ check.
* Any instruction which wrote the capability to a register detected any corrupted values.
** This is the _integrity_ check.

Capability load/store require the _provenance_ check:

* Any store which wrote the capability to memory was correctly authorized
* Any load which read the capability from memory was correctly authorized

When an operation fails a check, either due to software error or malicious intent, then the valid tag will be set to zero.

Using an invalid capability to dereference memory or authorize any operation raises an exception.
All capabilities derived from invalid capabilities are themselves invalid, i.e., their valid tags are zero.

NOTE: When the valid tag is zero, the register or memory location may be used to store non-capability data.

[#sec_cap_bounds_overview]
==== Capability Bounds

Capabilities encode memory bounds, i.e. the lowest and highest byte in memory that it is permitted to access when dereferenced for data memory access, or for instruction execution.

Checking is on a byte-by-byte basis, so that it is possible for a memory access to be fully in-bounds, partially out-of-bounds or fully out-of-bounds.

It is not permitted to make any partially or fully out-of-bounds memory accesses.

Every capability has two memory address bounds - _base_ representing the lowest accessible byte, and _top_ representing one byte above the highest accessible byte.

* The _base_ is XLEN-bits and is _inclusive_.
* The _top_ is XLEN+1-bits and is _exclusive_.
** The extra bit is required to allow the bounds to include the top byte of memory.
* The _length_ is XLEN+1-bits and is defined to be _top - base_.

Therefore a memory location `A` in the range `base &#8804; A < top` is within bounds, and so valid to access.

NOTE: Inclusive _top_, with XLEN-bits, was considered but rejected in favor of the exclusive _top_.

NOTE: Checking every byte of every executed instruction and every byte of every data memory access is fundamental to the memory safety which CHERI provides.
 In a typical load/store unit, the expansion of the bounds from `cs1` and bounds checking is in parallel with the address calculation, the memory translation and/or the PMA/PMP checking.

A compressed format is used to encode the bounds with a scheme similar to floating-point using an exponent and a mantissa.
Therefore small exponents can allow byte granularity on the bounds, but larger exponents give coarser granularity.

The bounds encoding format is defined in <<section_cap_bounds>>.

NOTE: Future extensions may redefine the bounds encoding format.

Software can query the capability bounds:

* The _base_ is returned by <<GCBASE>>.
* The _length_ is returned by <<GCLEN>>.
** <<GCLEN>> saturates the _length_ to XLEN-bits
* The _top_ can be calculated via <<GCBASE>>+<<GCLEN>>

NOTE: A future extension may add an instruction to directly read the _top_ if needed for performance.

==== Updating The Bounds

On system initialization the <<infinite-cap>> capability is available which has bounds which cover all of memory, and maximum permissions set.
All smaller capabilities are derived from this.

The ISA does not allow the bounds (and permissions) of a capability with its valid tag set to be increased (_monotonicity_).

Bounds can be programmed using the <<SCBNDS>>,<<SCBNDSI>> and <<SCBNDSR>> instructions, which set the current address to be the _base_ bound and the _length_ to be the operand (`rs1` or `imm` value).
The granularity constraints means that not all requested bounds can be encoded exactly.

* <<SCBNDS>> sets the _base_ to `cs1.address`, and the _length_ to `rs1`. Set the valid tag to zero if the bounds cannot be encoded exactly.
* <<SCBNDSI>> sets the _base_ to `cs1.address`, and the _length_ to the immediate value. Set the valid tag to zero if the bounds cannot be encoded exactly.
* <<SCBNDSR>> sets the _base_ to `cs1.address`, and the _length_ to `rs1`. The bounds may be rounded up if they cannot be encoded exactly.
** If <<SCBNDSR>> rounds up the requested bounds, they must still be no larger than the initial bounds.

<<CRAM>> can be used to determine the granularity which is possible to encode.

#some example usage here of CRAM+SCBNDSR would be good#

NOTE: Instructions like <<SCBNDS>> can be reused to reduce the bounds of am existing capability while retaining the valid tag, or they can be used to construct a new capability which is then validated using <<CBLD>>.

The bounds are encoded relative to the address field, sharing some upper bits of the address.
The number of shared bits depends on the exponent, see xref:section_cap_bounds[xrefstyle=short].

NOTE: Early versions of CHERI encoded the top and bottom bounds as full width addresses.
 This proved to be impractical for real systems, and so the https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/2019tc-cheri-concentrate.pdf[CHERI-concentrate] compressed system was developed to reduce the overhead.

Because CHERI concentrate encoding scheme shares the upper bits of the address with the bounds, the address of a capability cannot be arbitrary modified without risking changing the meaning of the bounds.
This means that whenever a capability address is updated, the semantics of the <<SCADDR>> instruction are required to check that the decoding of the bounds hasn't changed.
If the bounds _have_ changed, then the valid tag is set to zero, so that the capability is invalid for use.

NOTE: <<SCADDR>> updates the address field of a capability and then checks that the updated capability is still valid.

==== Representability

Capabilities allow the address pointer to be outside of the bounds by a small amount.

NOTE: Behavior was observed in software which allows pointers to legitimately move outside of arrays, and then only come back into the valid range on dereference.

The maximum range of address values that the pointer can take is defined by the <<section_cap_representable_check, representable region>>, which is checked on every update by <<SCADDR>>.

NOTE: CHERI versions which use a different encoding scheme to the default may specify an alternative to the representable region check, and may never allow the address to be out of bounds.
 Therefore the rest of the specification uses the phrase *represented exactly* for the check performed by <<SCADDR>>.

The bounds and representable region (or space) are illustrated in <<cap_bounds_map>>.
E, MW and R in the figure are all introduced in xref:section_cap_bounds_decoding[xrefstyle=short] along with the bounds decoding.

[#cap_bounds_map]
.Memory address bounds encoded within a capability
image::../cheri/img/cap-bounds-map.png[width=80%,align=center]

In the presence of memory corruption, fault injection, or hardware bugs, bounds can theoretically become <<section_cap_malformed,malformed>> (representing a lack of _integrity_).
Instructions which decode bounds will typically set the output valid tag to zero if the input is found to be <<section_cap_malformed,malformed>>.

NOTE: CHERI requires that the capability is correctly formed if the valid tag is set.
 Including handling of malformed bounds, and invalid settings of reserved bits, in the architecture allows the behavior to be clearly specified for all 2^(CLEN+1)^ input values.

[#sec_cap_type]
==== Capability Type (CT)

This metadata field indicates the type of the capability.
The type determines which operations the capability authorizes.
The following capability types are defined in {cheri_base_ext_name}:

.Capability types in {cheri_base_ext_name}
[#tab_cap_types,width="50%",options=header,align="center"]
|===
|Type |Hardware interpretation

|0    | Unsealed capability
|1    | Sealed entry (sentry) capability
|===

[#unsealed_cap,reftext="unsealed capability]
Unsealed capabilities::
When `CT=0`, the capability authorizes access to a region of memory as defined by the permissions and bounds.

[#sentry_cap,reftext="sentry capability"]
Sentry capabilities::
Capabilities with `CT≠0` are sealed against modification.
They cannot be dereferenced to access memory and it is not permitted to change the address, bounds or permissions.
Modifications are restricted to _reducing_ the <<section_cap_level, CL>> field using <<ACPERM>>.
+
Sealed entries (also known as sentries) describe secure function entry points.
They are used as the target of <<JALR_CHERI>>, which must have a zero offset for the use of a sentry to be valid.
+
Sentry capabilities can establish a form of control-flow integrity between mutually distrusting code.
<<JALR_CHERI>> with zero offset automatically unseals a sentry target capability and installs it in the <<pcc,program counter capability>>.
+
<<JALR_CHERI>> also seals the return register, so the callee can return to the caller but cannot access the memory pointed at by the return register, and cannot return elsewhere.
+
NOTE: In addition to using them for secure entry points, sentry capabilities can also be useful to software as secure software tokens.
 They can be converted to an unsealed capability by extracting the metadata with <<GCHI>>, zeroing the `CT` field, reapplying it with <<SCHI>> and then rebuilding via a superset capability with the <<CBLD>> instruction.
 A future extension may add an unseal instruction for performance.

[#sec_cap_ap]
==== Architectural Permissions (AP)

This metadata field encodes architecturally defined permissions of the capability.
Permissions grant access subject to the <<cap_validity_tag>> being set, the capability being unsealed, and bounds checks passing.
Any operation is also contingent on requirements imposed by other RISC-V architectural features, such as virtual memory, PMP and PMAs, even if the capability grants sufficient permissions.
The permissions currently defined in {cheri_base_ext_name} are listed below.

Permissions can only be removed using <<ACPERM>>, they cannot be added.

[#r_perm,reftext="R-permission"]
Read Permission \(R):: Allow reading data from memory. Tags are always
read as zero when reading non-capability data.

[#w_perm,reftext="W-permission"]
Write Permission (W):: Allow writing data to memory. Valid tags are always
written as zero when writing non-capability data. Every CLEN aligned word in memory
has a valid tag, if any byte is overwritten with non-capability data then the valid tag for all
CLEN-bits is cleared.

[#c_perm,reftext="C-permission"]
Capability Permission \(C):: Allow reading capability data from memory if the
authorizing capability also grants <<r_perm>>. Allow writing capability data to
memory if the authorizing capability also grants <<w_perm>>.

[#x_perm,reftext="X-permission"]
Execute Permission (X):: Allow instruction execution.

[#lm_perm,reftext="LM-permission"]
Load Mutable Permission (LM):: Allow preserving the <<w_perm>> of capabilities loaded from memory.
If a capability grants <<r_perm>> and <<c_perm>>, but no <<lm_perm>>, then a capability loaded via this authorizing capability will have <<w_perm>> and <<lm_perm>> removed.
The permission stripping behavior only applies to loaded capabilities that have their valid tag set and are not sealed; loaded capabilities that are sealed or invalid do not have their permissions changed.
  This ensures that capability loads/stores of non-capability data do not modify the stored value.

NOTE: Clearing a capability's <<lm_perm>> and <<w_perm>> allows sharing a read-only version of a data structure (e.g., a tree or linked list) without making a copy.

[#asr_perm,reftext="ASR-permission"]
Access System Registers Permission (ASR):: Allow read and write access to privileged CSRs as well as some privileged instructions.
In {cheri_base_ext_name}, the only affected CSR is the unprivileged <<utidc>> CSR, which requires <<asr_perm>> for writing (but not for reading).

NOTE: This permission is important in privileged execution environments.
  Removing this permission allows constraining privileged software to a sandbox that cannot be subverted by changing privileged state.

NOTE: Extensions may add additional non-privileged CSRs that require <<asr_perm>>.

[#sl_perm,reftext="SL-permission"]
Store Level Permission (SL):: This is a variable width field that allows limiting the propagation of capabilities using the following logic: capabilities with a <<section_cap_level>> less than the inverse of the authorizing capability's <<sl_perm>> will be stored with the valid tag cleared.
With `LVLBITS=1` there is a single bit comparison, so it behaves as follows:
- If this field (as well as <<c_perm>> and <<w_perm>>) is set to 1 then capabilities may be stored via this capability regardless of their associated <<section_cap_level>>.
- If this field is zero, then any capability with a <<section_cap_level>> of zero (i.e., _local_), will be stored with the valid tag cleared.

ifdef::cheri_v9_annotations[]
NOTE: For `LVLBITS=1` this permission is equivalent to _StoreLocal_ in CHERI v9, Morello and CHERIoT.
endif::[]

[#el_perm,reftext="EL-permission"]
Elevate Level Permission (EL):: Any unsealed capability with its valid tag set to 1 that is loaded from memory has its <<el_perm>> cleared and its <<section_cap_level>> restricted to the authorizing capability's <<section_cap_level>> if the authorizing capability does not grant <<el_perm>>.
If sealed, then only <<section_cap_level,CL>> is modified, <<el_perm>> is unchanged.
This permission is similar to the existing <<lm_perm>>, but instead of applying to the <<w_perm>> on the loaded capability it restricts the <<section_cap_level,CL>> field.

ifdef::cheri_v9_annotations[]
NOTE: *CHERI v9 Note:* This permission does not exist in CHERI v9, but is similar to CHERIoT's _LoadGlobal_ permission, except that any _global_ capability implicitly grants _LoadGlobal_.
endif::[]

[#section_cap_level,reftext="Capability Level (CL)"]
==== Capability Level (CL)

The _Capability Level_ (CL) is a variable width field that allows enforcing invariants on capability propagation.
For example, the _Capability Level_ can be used to ensure that a callee can only write a copy of the passed-in argument capability to specific locations in memory (e.g., the callee's stack frame but not the heap).
It can also be used to avoid sharing of compartment-local data (such as pointers to a stack object) between compartments.

NOTE: This specification only defines the architectural mechanics of this feature, for further information on how this can be used by software please refer to cite:[cheri-v9-spec].

The width of this field depends on whether the {cheri_0levels_ext_name} or {cheri_1levels_ext_name} extension is implemented:

===== {cheri_0levels_ext_name}
In this case the field is hardwired to 1 and all checks based on the _Capability Level_ can be omitted (since they always pass).

===== {cheri_1levels_ext_name}
The _Capability Level_ can hold two values: when set to 1 the capability is _global_ (in general allowing it to be stored using any authorizing capability), and when set to 0 the capability is _local_, and can only be stored by authorizing capabilities with the <<sl_perm>> set.
  Furthermore, the <<el_perm>> can be used to restrict loading of _global_ capabilities -- causing the hardware to automatically set the level of loaded capabilities to _local_ instead.

As with permissions, the capability level can only be decreased but never increased (without deriving from a capability with a higher level).
// Therefore, the capability level is adjusted using the <<ACPERM>> instruction (see <<section_cap_level_change>>) and are queried using <<GCPERM>>.
But unlike architectural permissions, CL can be reduced even if the capability is sealed.

NOTE: A capability with <<section_cap_level,CL>>=1 is referred to as _global_ and with <<section_cap_level,CL>>=0 as _local_.

.{cheri_1levels_ext_name} summary table for stored capabilities
[#cap_level_store_summary,width="100%",options=header,halign=center,cols="1,1,1,1,5"]
|==============================================================================
   3+|Auth cap field       | Data cap field |
    h|*W*    h|*C* h|*SL* h|*CL* h| Notes
.3+.^|1  .3+.^| 1   | 1    | X    | Store data capability unmodified
               .2+.^| 0    | 1    | Store data capability unmodified (`CL ≥ ~SL`)
                           | 0    | Store data capability with valid tag cleared (`CL < ~SL`)
|==============================================================================

NOTE: if W=0 or C=0 then SL is irrelevant

.{cheri_1levels_ext_name} additional rules for loading capabilities
[#cap_level_load_summary,width="100%",options=header,align=center,cols="1,1,1,1,1,1,6"]
|==============================================================================
   4+|Auth cap field                  2+| Data cap field |
    h|*R*   h|*C* h|*EL*      h|*CL*   h| Tag h| Sealed h|Action
.2+.^|1 .2+.^| 1 .2+.^| 0 .2+.^| X .2+.^| 1    | Yes     |Load data capability with `CL=min(auth.CL, data.CL)`, EL unchanged
                                               | No      |Load data capability with `EL=0, CL=min(auth.CL, data.CL)`
   6+| All other cases                                   |Load data capability with EL, CL unmodified
|==============================================================================

ifdef::cheri_v9_annotations[]
NOTE: The current specification only defines up to two levels, equivalent to _local_ and _global_ capabilities from CHERI v9, Morello and CHERIoT.
endif::[]
Future extensions are permitted to add more levels.

[#sec_cap_sdp]
==== Software-Defined Permissions (SDP)
The metadata also contains an encoding-dependent number of software-defined permission (SDP) bits.
They can be inspected by the kernel or application programs to enforce restrictions on API calls (e.g. permit/deny system calls, memory allocation, etc.).
They can be cleared by <<ACPERM>> but are not interpreted by the CPU otherwise.

While these bits are not used by the hardware as architectural permissions, modification follows the same rules: SDP bits can only be cleared and never set.

NOTE: This property is required to ensure restricted programs cannot forge capabilities that would pass the software-enforced checks.

[#section_special_caps]
==== Special Capabilities

[#infinite-cap,reftext="Infinite"]
===== Infinite Capability

The _Infinite_ capability grants all permissions while its bounds also cover the whole address space.
All capability checks pass when performed against an <<infinite-cap>> capability.
The in-memory encoding of the _Infinite_ capability is described in <<section_infinite_cap_encoding>>.

NOTE: The _Infinite_ capability is also known as 'default', 'almighty', or 'root' capability in other CHERI documentation.

[#null-cap,reftext="NULL"]
===== NULL Capability
A capability with all-zeroes metadata, an unset valid tag, and an address of zero is referred to as the _NULL_ capability.
This capability grants no permissions and any dereference results in a CHERI exception.
The memory representation of the <<null-cap>> capability is all zeroes.

=== Added State

A CHERI core adds state to allow capabilities to be used from within integer (X) registers, and to ensure they are not corrupted as they flow through the system.
This means the following state is added by {cheri_base_ext_name}:

.CHERI *c* registers extending existing *x* registers in {cheri_base_ext_name}
[#base_cap_registers]
[bytefield]
----
(defattrs :plain [:plain {:font-family "M+ 1p Fallback" :font-size 40}])
(def row-height 100)
(def row-header-fn nil)
(def boxes-per-row 65)
(draw-column-headers {:height 30 :font-size 25 :labels (concat ["" "2*XLEN (CLEN)"] (repeat 31 "") ["XLEN"] (repeat 30 "") ["0"])})

(draw-box "" [:box-first {:span 1}]) (draw-box "c0" [:box-related {:span 32}]) (draw-box "x0" [:box-last {:span 32 }])
(draw-box "" [:box-first {:span 1}]) (draw-box "c1" [:box-related {:span 32}]) (draw-box "x1" [:box-last {:span 32 }])
(draw-gap "Same layout for c2-c30 (extending x2-x30)" {:height 100})
(draw-box "" [:box-first {:span 1}]) (draw-box "c31" [:box-related {:span 32}]) (draw-box "x31" [:box-last {:span 32 }])
(draw-box nil [:box-first {:span 1}]) (draw-box "pcc" [:box-related {:span 32}]) (draw-box "pc" [:box-last {:span 32 }])
(draw-box "V" {:span 1 :borders {}}) (draw-box "Metadata" {:span 32 :borders {}}) (draw-box "Address" {:span 32 :borders {}})
----

==== Extended general purpose integer registers
The <<gprs,XLEN-wide integer registers>> (e.g., `sp`, `a0`) are all extended with another XLEN-bits of capability metadata plus a valid tag bit.
When referring to the extended register, the `x` prefix is replaced with a `c`: i.e. the capability extended version of `x0` becomes `c0`.
The existing integer register names refer to the address part of the capability.
For the ABI register names the `c` prefix is added, i.e., `csp`, `ca0`.
The zero register is extended with zero metadata and a cleared valid tag: this is called the <<null-cap>> capability.

NOTE: Instruction encodings refer to *c* registers when they use `cs1`, `cd`, etc. instead of `rs1`, `rd` (which reads/writes the XLEN-bit subset of the register).

==== Extended CSRs
All registers that store addresses are extended to contain capabilities.
In the base {cheri_base_ext_name} ISA, only the program counter (`pc`) register is extended to become the Program Counter Capability (<<pcc>>).

NOTE: All CSRs that hold pointers are extended to CLEN-bits, but since no CSRs are defined in the RV32I/RV64I base instruction set, any such change is described in the corresponding chapters.

[#pcc,reftext="pcc"]
==== The Program Counter Capability (`pcc`)

The `pc` is extended to be the Program Counter Capability.
Extending the `pc` allows the range of branches, jumps and linear execution for currently executing code to be restricted.
The <<pcc>> address field is the `pc` in the base RISC-V ISA so that the
hardware automatically updates it as instructions are executed.

The hardware performs the following checks on <<pcc>> for each instruction
executed in addition to the checks already required by the base RISC-V ISA. A
failing check causes a CHERI exception.

CAUTION: #ARC suggest that this become a software check exception, which would need a CHERI specific value in Xtval2#

* The valid tag must be set
* The capability must not be sealed
* The capability must grant execute permission
* All bytes of the instruction must be in bounds

On startup <<pcc>> bounds and permissions must be set such that the program can run successfully (e.g., by setting it to <<infinite-cap>> to ensure _all_ instructions are in bounds).

.Program Counter Capability
[#pcc-format]
include::img/pccreg.edn[]

//move to priv section
//<<pcc>> is a code capability, so it does not need to be able to hold all possible invalid addresses.
//FIXME! ref to priv here, need associated text there instead?
// (see <<section_invalid_addr_conv>>).

==== Valid tags in registers

Every register has a one-bit valid tag, indicating whether the capability in the register is valid to be dereferenced.
This valid tag is cleared whenever an invalid capability operation is performed.
Examples of such invalid operations include writing only the integer portion (the address field) of the register or attempting to increase bounds or permissions.

==== Valid tags in memory

The valid tags are tracked through the memory subsystem: every aligned CLEN-bit wide region has a non-addressable one-bit valid tag, which the hardware manages atomically with the data.
The valid tag is cleared if any byte in the CLEN/8 aligned memory region is ever written using an operation other than a store of a capability operand with <<c_perm>> granted.

NOTE: All system memory and caches that store capabilities must preserve this abstraction, handling the valid tags atomically with the data.

[#sec_cap_checks]
=== Capability checks

With {cheri_base_ext_name}, every memory access performed by a CHERI core must be authorized by a capability.

Instruction fetches, branches, jumps, and data memory accesses may result in a fatal exception if the access is out of <<sec_cap_bounds_overview,bounds>>, or if the authorizing capability is missing the required <<sec_cap_ap,permissions>>. I.e.:

* all load instructions requires <<r_perm>>
* all store instructions require <<w_perm>>
* all indirect jumps require <<x_perm>> on the target capability

See <<sec_cheri_exception_handling,_CHERI Exception handling_ in the privileged specification>> for further details on the exception reporting mechanism.

Instruction fetch is also authorized by a capability: the program counter capability (<<pcc>>) which extends the PC.
This allows code fetch to be bounded, preventing a wide range of attacks that subvert control flow with non-capability data.

The authorizing capability is either named explicitly (the base register of a load/store operation) or implicitly (when executing a branch, <<pcc>> is used for authorization).

E.g., `lw t0, 16(csp)` loads a word from memory, getting the address, bounds, and permissions from the `csp` (capability stack pointer) register.

No other exception paths are added by {cheri_base_ext_name}: in particular, capability manipulations do not except, but may set valid tag of the resulting capability to zero if the operation is not permitted.

NOTE: Branches and jumps may raise exceptions, reusing the Instruction Address Misaligned exception path.

=== Instructions Which Update The Capability Pointer

Updating the value of the pointer (i.e., the address field) of a capability requires specific instructions instead of integer ADD/ADDI.
They all include a check that the result can be <<section_cap_representable_check,represented exactly>>.

.Instructions which update the address field summary in {cheri_base_ext_name}
[#tab_cap_ptr_summary,%autowidth,options=header,align="center",cols="1,4"]
|=======================
|Mnemonic     |Description
|<<CADDI>>    |Increment capability address by immediate, <<section_cap_representable_check,represented exactly>> check
|<<CADD>>     |Increment capability address by register, <<section_cap_representable_check,represented exactly>> check
|<<SCADDR>>   |Replace capability address, <<section_cap_representable_check,represented exactly>> check
|=======================

include::insns/cadd_32bit.adoc[]
include::insns/scaddr_32bit.adoc[]

<<<

=== Instructions Which Manipulate Capability Data

For security, capabilities can only be modified in restricted ways.
Special instructions are provided to copy capabilities or perform manipulations such as _shrinking_ the bounds (<<SCBNDS>>), _reducing_ the permissions (<<ACPERM>>) or _authorizing_ a capability with another one which has a superset (or identical) bounds and permissions (<<CBLD>>).

.Other instructions which manipulate capability data summary in {cheri_base_ext_name}
[#tab_cap_manip_summary,%autowidth,options=header,align="center",cols="1,4"]
|=======================
|Mnemonic     |Description
|<<ACPERM>>   |AND capability permissions (expand to 1-bit per permission before ANDing)
|<<CMV>>      |Move capability register
|<<SCHI>>     |Set metadata and clear valid tag
|<<SCBNDSI>>  |Set immediate bounds on capability with rounding, clear valid tag if rounding is required
|<<SCBNDS>>   |Set register bounds on capability with rounding, clear valid tag if rounding is required
|<<SCBNDSR>>  |Set bounds on capability with rounding up as required
|<<SENTRY>>   |Seal capability
|<<CBLD>>     |Set cd to cs2 with its tag set after checking that cs2 is a subset of cs1
|=======================

include::insns/acperm_32bit.adoc[]
include::insns/cmv_32bit.adoc[]
include::insns/schi_32bit.adoc[]
include::insns/scbnds_32bit.adoc[]
include::insns/scbndsr_32bit.adoc[]
include::insns/sentry_32bit.adoc[]
include::insns/cbld_32bit.adoc[]

<<<

=== Instructions Which Inspect Capability Data

==== Instructions Which Decode Capability Bounds

The _bounds_ describing the range of addresses the capability gives access to are stored in a compressed format.
These instructions query the bounds and related information.

.Instructions which decode capability bounds summary in {cheri_base_ext_name}
[#tab_cap_inspection_bounds_summary,%autowidth,options=header,align="center",cols="1,4"]
|=======================
|Mnemonic   |Description
|<<GCBASE>> |Get capability base
|<<GCLEN>>  |Get capability length
|=======================

include::insns/gcbase_32bit.adoc[]
include::insns/gclen_32bit.adoc[]

<<<

==== Instructions Which Extract Capability Fields

These instructions either directly read bit fields from the metadata or valid tag, or only apply simple transformations on the metadata.

.Instructions which extract capability fields summary in {cheri_base_ext_name}
[#tab_cap_inspection_fields_summary,%autowidth,options=header,align="center",cols="1,4"]
|=======================
|Mnemonic   |Description
|<<GCTAG>>  |Get tag field
|<<GCPERM>> |Get hperm and uperm fields as 1-bit per permission, packed together
|<<GCTYPE>> |Get capability type
|<<GCHI>>   |Get metadata
|=======================

include::insns/gctag_32bit.adoc[]
include::insns/gcperm_32bit.adoc[]
include::insns/gctype_32bit.adoc[]
include::insns/gchi_32bit.adoc[]

<<<

=== Miscellaneous Instructions Which Handle Capability Data

.Miscellaneous capability instruction summary in {cheri_base_ext_name}
[#tab_cap_misc_summary,%autowidth,options=header,align="center",cols="1,4"]
|=======================
|Mnemonic   |Description
|<<SCEQ>>   |Full capability bitwise compare, set result true if both are fully equal
|<<SCSS>>   |Set result true if cs1 and cs1 tags match and cs2 bounds and permissions are a subset of cs1
|<<CRAM>>   |Representable Alignment Mask: Return mask to apply to address to get the requested bounds
|=======================

include::insns/sceq_32bit.adoc[]
include::insns/scss_32bit.adoc[]
include::insns/cram_32bit.adoc[]

<<<

[#sec_cap_load_store]
=== Instructions Which Load and Store Capability Data

New loads and stores are introduced to handle capability data, <<LC>> and <<SC>>.
They atomically access CLEN-bits of data and the associated valid tag.

All capability memory accesses check for <<c_perm>> in the authorizing capability in `cs1`.

If <<c_perm>> is granted then:

* <<LC>> reads CLEN-bits of data from memory, and returns the associated valid tag.
* <<SC>> writes CLEN-bits of data to memory, and writes the associated valid tag.

If <<c_perm>> is not granted then:

* <<LC>> reads CLEN-bits from memory, but does not return the associated valid tag, instead zero is returned.
* <<SC>> writes CLEN-bits to memory, and writes zero to the associated valid tag.

//NOTE: Future extensions to {cheri_base_ext_name} may add mechanisms that cause
//stores of capabilities to raise exceptions when the authorizing capability does not grant both
//<<w_perm>> and <<c_perm>> and the stored capability has the valid tag set.

All capability data memory access instructions require CLEN-aligned addresses, and will
take a misaligned exception if this requirement is not met.
They cannot be emulated.

CAUTION: #ARC request that this become an access fault#

All memory accesses, of any type, require permission from the authorizing capability in `cs1`.

* All loads require <<r_perm>>, otherwise they raise an exception
* All stores require <<w_perm>>, otherwise they raise an exception

//NOTE: Misaligned capability memory accesses cannot be emulated.
//  To transfer CLEN misaligned bits without a valid tag, use integer loads and stores.

Under some circumstances <<LC>> will _modify_ metadata before returning the value.
See <<LC>> for details.

.Capability load/store instruction summary in {cheri_base_ext_name}
[#tab_cap_ldst_summary,%autowidth,options=header,align="center",cols="1,4"]
|=======================
|Mnemonic   |Description
|<<LC>>     |Load capability
|<<SC>>     |Store capability
|=======================

include::insns/load_32bit_cap.adoc[]
include::insns/store_32bit_cap.adoc[]

<<<

[#section_existing_riscv_insns]
=== Changes to Existing RISC-V Base ISA Instructions

{cheri_base_ext_name} extend existing instructions which are used for handling addresses so that they manipulate a whole capability.
The affected operands change type from *x* to *c* to represent this, and/or the PC is replaced by the <<pcc>>

In the base ISA this affects <<AUIPC_CHERI>> and all jumps and branches as well as all loads and stores.

The rules for modifying the behavior of such instructions are:

* The result written to the target register is always unchanged.
** The lower XLEN-bits are always written with the value from RV32I/RV64I.
* Whenever the PC is handled, it is _always_ the <<pcc>>.
* Any instruction that has a base address register (generally `rs1`) reads the full capability register (`cs1`) instead.
** This capability register is used to <<sec_cap_checks,authorize the access>>.
* Any instruction writes back an address (e.g., <<AUIPC_CHERI>>), writes a full capability register instead.
* Whenever the address field of any capability (including the <<pcc>>) is modified, it is _always_ updated using <<SCADDR>> semantics.
** This includes adding an offset to the <<pcc>> from jumps and branches for both the target address and the link register.
 In this case, e.g., `new_pcc = SCADDR(old_pcc, offset)`
* All jumps and branches check that a minimum sized instruction is in bounds of the target <<pcc>>.
** An exception is taken by the branch or jump on failure.
* <<JALR_CHERI>> copies _all_ of `cs1` into the <<pcc>>. If `cs1` is not suitable for execution then an exception is taken on the <<JALR_CHERI>> (see <<pcc>> for the definition of suitability).
* Any memory access instruction that has a base address register (generally `rs1`) reads the full capability register (`cs1`) instead which is used to <<sec_cap_checks,check whether the access is permitted>>, taking an exception if it is not.
* Whenever the address field of any capability (including the <<pcc>>) is modified, it is _always_ updated using <<SCADDR>> semantics.
** This includes adding an offset to the <<pcc>> from jumps and branches for both the target address and the link register.
 In this case, e.g., `new_pcc = SCADDR(old_pcc, offset)`
* All jumps and branches check that a minimum sized instruction is in bounds of the target <<pcc>>.
** An exception is taken by the branch or jump on failure.
* <<JALR_CHERI>> copies _all_ of `cs1` into the <<pcc>>. If `cs1` is not suitable for execution then an exception is taken on the <<JALR_CHERI>> (see <<pcc>> for the definition of suitability).

These rules affect the following <<rv32,base ISA>> instructions listed in <<tab_cap_base_summary>>, and also apply to instructions added by other extensions (e.g. floating-point/vector loads/stores or the shift-and-add instruction from <<zba,Zba>>).

IMPORTANT: These rules also apply to instructions added by other extensions (e.g., floating-point/vector loads/stores or the shift-and-add instruction from <<zba,Zba>>).

NOTE: Exceptions are taken on the branch or jump which cause an exception, not at the target, to reduce the attack surface and also to aid with debugging.
 Therefore it is _not_ possible to execute from a memory location without having _already_ checked that execution of that location is authorized.


.Changed RISC-V base ISA instructions summary in {cheri_base_ext_name}
[#tab_cap_base_summary,%autowidth,options=header,align="center",cols="2,4"]
|=======================
|Mnemonic                   |Description
|<<AUIPC_CHERI>>            |Add immediate to PCC address, return capability
|<<JAL_CHERI>>              |Jump to PC+offset, bounds check minimum size target instruction, link to cd
|<<JALR_CHERI>>             |Indirect jump and link, bounds check minimum size target instruction.
|<<insns-conbr-32bit_CHERI,BEQ, BNE, BLT[U], BGE[U]>>|Conditional branches (checked by <<pcc>>)
|<<section_int_load_store_insns,LD, LW[U], LH[U], LB[U]>>|Integer loads (authorized by the capability in `cs1`)
|<<section_int_load_store_insns,SD, SW, SH, SB>>|Integer stores (authorized by the capability in `cs1`)
|=======================

include::insns/auipc_32bit.adoc[]
include::insns/jal_32bit.adoc[]
include::insns/jalr_32bit.adoc[]

//==== Unconditional Jumps
//
//Unconditional jumps operate as described in <<ct-insns,the base RISC-V ISA>> but with added bounds and permission checks.
//For jump-and-link instructions, the value written to the link register is a full capability derived from <<pcc>> with the address updated //to the link address.
// //CHERIoT compatiblity
//If the resulting capability cannot be <<section_cap_representable_check,<<section_cap_representable_check,represented exactly>> then the valid tag is cleared.
//The resulting jump address is checked against <<pcc>> as described below.
//Additionally, the link register is sealed (as if executing an implicit <<SENTRY>>) to ensure that the callee cannot modify the return //address and (maliciously) return to an incorrect instruction.
//
//For indirect jumps, the authorizing capability is not <<pcc>> but the base capability register in `cs1`.
//
//The target capability is unsealed if it is a sentry and the instructions has a zero immediate offset.
//
//<<JALR_CHERI>> causes a CHERI exception when:
//
//* The target capability's valid tag is zero
//* The target capability is sealed and the immediate is not zero
//* A minimum sized instruction (2 or 4 bytes depending on enabled extensions) at the target capability's address is not
//within bounds
//* The target capability does not grant <<x_perm>>
//
//<<JAL_CHERI>> and <<JALR_CHERI>> can also cause instruction address misaligned exceptions
//following the standard RISC-V rules.


//[#condbr-purecap]
//==== Conditional Branches
//
//Conditional branch instructions compare two *x* registers as described in the base RISC-V
//ISA, so the metadata and tag values are disregarded in the comparison if the
//operand registers hold capabilities. If the comparison evaluates to true, then
//the target address is installed in the <<pcc>>'s address field.
//These instructions cause CHERI exceptions when a minimum sized instruction at the target address is not within the <<pcc>>'s bounds.

include::insns/condbr_32bit.adoc[]

<<<

[#section_int_load_store_insns,reftext="Loads and Stores"]
==== Load and Store Instructions ({cheri_base_ext_name})

All load and store instructions behave as described in <<ldst>> with one fundamental difference:

* For the base operand (`rs1`), the capability source operand `cs1` is used to authorize the resulting memory access.

All load and store instructions authorized by `cs1` cause CHERI exceptions if any of these checks fails:

* `cs1` must not be `c0`^1^
* The valid tag (`cs1.tag`) must be set, and there must be no reserved bits set in `cs1`
* `cs1` must be unsealed
//move to priv spec
//* The virtual address in `cs1` must not be invalid if virtual memory is enabled.
* All bytes of accessed memory must be inside `cs1's` bounds, and the bounds can't be <<section_cap_malformed,malformed>>.
* For loads, the <<r_perm,read permission>> must be set in `cs1`
* For stores, the <<w_perm,write permission>> must be set in `cs1`

^1^ All load/store encodings are _reserved_ if `cs1=c0` (since dereferencing <<null-cap>> always faults).
 This principle is extended to _all_ loads and stores authorized by `cs1`.

Load instructions, except for <<LC>>, always zero the valid tag and metadata of the result register.

Store instructions, except for <<SC>>, always write zero to the valid tag or tags associated with the memory locations that are written to.

Therefore, misaligned stores may clear up to two associated valid tag bits.

The changed interpretation of the base register also applies to all loads, stores and other memory operations defined in later chapters of this specification with a base operands of `rs1` unless stated otherwise.

NOTE: this applies to all existing loads and stores including integer, floating-point and vector.

*Under {cheri_base_ext_name} _all_ loads and stores are authorized by `cs1`.*
