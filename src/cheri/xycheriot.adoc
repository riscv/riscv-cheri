:cheriot_ext_name: Xycheriot

:cheriot_auicgp_name: AUICGP
:cheriot_auicgp_name_lc: auicgp

:cheriot_gettop_name: YTOPR
:cheriot_setbounds_round_down_name: YBNDSRDW
:cheriot_setbounds_big_imm_name: YBNDSWBI

:cheriot_ot_x_min: 1
:cheriot_sentry_ot_min: 1
:cheriot_sentry_ot_bd: 4
:cheriot_sentry_ot_be: 5
:cheriot_sentry_ot_fd: 2
:cheriot_sentry_ot_fe: 3
:cheriot_sentry_ot_fi: 1
:cheriot_sentry_ot_max: 5
:cheriot_ot_x_max: 7
:cheriot_ot_absent: 8
:cheriot_ot_nx_min: 9
:cheriot_ot_nx_max: 15
:cheriot_ot_max: 15

:cheriot_ycfg_value: `0x02`

:cheriot_v1_isa: link:https://cheriot.org/cheriot-sail/cheriot-architecture.pdf[The CHERIoT ISA]

[appendix]
[#section_xycheriot,reftext="{cheriot_ext_name}"]
== "{cheriot_ext_name}" Extension and Capabilities

IMPORTANT: This chapter is not part of the v1.0 ratification package.

link:https://cheriot.org[CHERIoT] is
an existing open-source 32-bit RISC-V CHERI microcontroller ISA
(and associated software ecosystem)
with commercial silicon in development.
This _draft_ section explores how the modular structure of, and hooks within,
the {cheri_base32_ext_name} base ISA and its extensions
could be used to define a future edition of the CHERIoT ISA
atop a ratified RISC-V CHERI.
Much of the CHERIoT-specific _detail_ is not yet imported hereto,
but effort has been made to cite the existing CHERIoT ISA documentation.
At the same time, this chapter ponders
a few proposed incremental changes to the existing CHERIoT ISA;
these are marked as "TODO, research required"
and can be ignored by readers focused on {cheri_base_ext_name}.

=== Required Extensions

{cheriot_ext_name} is specific to {cheri_base32_ext_name}.
It requires the presence of all of:

* <<section_priv_cheri,{cheri_priv_m_ext}>>,

* <<section_zylevels1>>, and

* <<section_zyseal>>.


The present specification presumes the *absence* of all of:

* any execution mode other than M-mode
  (such as VS, HS, VU, S, or U),

* <<section_cheri_hybrid_ext,{cheri_default_ext_name}>>,

* <<section_cheri_disable,{cheri_priv_m_reg_enable_ext}>>, and

* <<section_rvy_sentry_insn_ext>>.

[NOTE]
=====
While {cheriot_ext_name} is nominally compatible with
<<section_cheri_hybrid_ext,{cheri_default_ext_name}>> and
<<section_cheri_disable,{cheri_priv_m_reg_enable_ext}>>,
and particular instantiations may opt to permit disabling CHERI,
we have not yet found a compelling reason to formally specify this composition.
=====

[NOTE]
=====
While {cheriot_ext_name} is nominally compatible with
<<section_rvy_sentry_insn_ext>>,
the operating system written for {cheriot_ext_name} has a security model
that presumes the absence of ambient sealing,
and the present prose explicitly precludes <<section_rvy_sentry_insn_ext>>.
=====

=== Capability Load Filter and The Revocation Bitmap

As part of providing _heap temporal_ safety,
{cheriot_ext_name} extends the semantics of `{load_cap_name_lc}`
to introduce a _capability load filter_.
The memory block(s) in which software's dynamic allocation heap(s) are to reside
are paired with a _revocation bitmap_,
a bit-vector wherein each bit corresponds to a capability-sized memory granule.
(That is, with each capability-sized and -aligned region of the primal memory.)
Such memory block(s) are said to be _revokable_.
These revocation bitmaps are also exposed (as memory) to software.

When `{load_cap_name_lc}` transfers a valid capability (one with a set {ctag})
from memory into a hart's register file,
it checks whether the _base_ (lower bound) of that capability is within
a revokable memory block and, if so,
fetches the corresponding bit in the associated revocation bitmap.
If that bit is set, then the {ctag} stored in the hart's register file
as part of this transfer is cleared.

Software dynamic memory allocators can set bits in a revocation bitmap
to ensure that additional copies of capabilities to particular objects
cannot be constructed (into register files and, so, into memory, too).
This facilitates particularly straightforward global revocation of pointers to
freed heap objects.

[NOTE]
=====
The location, size, and number of revokable memory blocks,
as well as the mapping function from primal memory address to revocation bitmap
address and bit index, are all platform-defined.
=====

[NOTE]
=====
See §7.8 / "Temporal safety" of {cheriot_v1_isa} for further details.
=====

=== Capability Encoding

==== `mycfg` Value

Harts implementing {cheriot_ext_name} must report
a constant {cheriot_ycfg_value} in `mycfg`.
(See <<uycfg>> for the details of this CSR.)

[NOTE]
=====
TODO: That value is, of course, not finalized.
=====

==== Bounds Encoding

CHERIoT's bounds encodings use 9-bit top and bottom mantissa fields
and a compressed 4-bit exponent value.
The resulting encoding significantly differs from the bounds
of the <<app_cap_description>> encoding; CHERIoT's encoding...

- has byte alignment only up to length 511.

- does not guarantee a representable region beyond the authorized base and top
  (except for "one past the end", as required by the C programming language,
   where the capability's address is equal to its upper bound).
+
This requires using a non-default
<<section_xycheriot_auipc_shift,AUIPC shift>> value.

[NOTE]
=====
TODO: As in §7.13.3 / "Capability bounds" in {cheriot_v1_isa}
=====

==== Permissions

{cheriot_ext_name} defines _one_ <<sec_cap_sdp,software defined permission>>,
which we call `U0`.
That is, its `SDPLEN` value is `1`.

There are 11 other architectural permission bits in {cheriot_ext_name},
all of which are from its constituent components:

* <<r_perm>>, <<w_perm>>, <<c_perm>>, <<lm_perm>>, <<x_perm>>, and <<asr_perm>>
  from {cheri_base_ext_name};

* <<zylevels1_lg_perm>>, <<zylevels1_sl_perm>>, and <<zylevels1_gl_perm>>
  from <<section_zylevels1>>; and

* <<zyseal_se_perm>> and <<zyseal_us_perm>> from <<section_zyseal>>.

The aggregate permissions bit field (<<acperm_bit_field>>) used by <<GCPERM>>
and <<CLRPERM>> for {cheriot_ext_name},
which is completely determined by these components, is thus:
include::./img/xycheriot-acperm_bit_field.edn[]

[#section_xycheriot_roots]
==== Roots

{cheriot_ext_name} defines _three_ <<root-cap>> capability values:

* Its <<root-rx-cap>> capability value is defined as
  having <<zylevels1_gl_perm>> set and granting exactly all of
  <<x_perm>>, <<r_perm>>, <<c_perm>>, <<lm_perm>>, <<asr_perm>>,
  and <<zylevels1_lg_perm>>.

* Its <<root-rw-cap>> capability value is defined as
  having <<zylevels1_gl_perm>> set and granting exactly all of
  <<r_perm>>, <<w_perm>>, <<c_perm>>, <<lm_perm>>,
  <<zylevels1_lg_perm>>, and <<zylevels1_sl_perm>>.

* It defines a _root sealing_ capability value that is unsealed,
  has full address space bounds,
  and grants exactly all of <<zyseal_se_perm>>, <<zyseal_us_perm>>, and `U0`.

These root capabilities satisfy the following properties by construction.
They will necessarily remain true through any series of <<CLRPERM>> transitions:

[[perm_req:xycheriot:w-nand-x,w-nand-x]]w-nand-x::
  At most one of <<x_perm>> or <<w_perm>> may be set.

[[perm_req:xycheriot:mem-nand-ct,mem-nand-ct]]mem-nand-ct::
  The <<zyseal_se_perm>>, <<zyseal_us_perm>>, and `U0`
  collectively conflict with
  either of the <<r_perm>> or <<w_perm>> permissions.
+
That is, a capability may grant permissions
from at most one of these two sets;
this serves to partition capabilities that refer to memory addresses
from those that refer to <<sec_cap_type>> values
(those granting <<zyseal_se_perm>> and/or <<zyseal_us_perm>>)
or uninterpreted integers (those granting `U0`).
Capabilities granting permissions from neither set are not distinguished.

==== Permission Encoding

{cheriot_ext_name} uses a compressed 6-bit permission field.
The compression thereof takes advantage of...

- the constraints on <<sec_permission_transitions,permission transitions>>
  defined across the base {cheri_base_ext_name} ISA
  and the <<section_zylevels1>> extension,

- the permission partitioning in {cheriot_ext_name}'s
  <<section_xycheriot_roots,root>> capability values, and

- two additional constraints on permission transitions:
+
[float="center",align="center",cols="2,2,4",options="header"]
|===
| <<CLRPERM>> Rule     | Permission            | Valid only if
| {cheriot_ext_name}-1 | <<x_perm>>            | <<c_perm>> and <<r_perm>>
| {cheriot_ext_name}-2 | <<zylevels1_sl_perm>> | <<r_perm>>
|===

The concrete encoding table is shown in <<tab_cheriot_perms_enc>>.

[NOTE]
=====
This second rule _adds_ <<r_perm>> as a dependency of <<zylevels1_sl_perm>>.
Its sole effect is to exclude local and global capabilities that would otherwise
grant exactly all of <<w_perm>>, <<c_perm>>, and <<zylevels1_sl_perm>>.
These capabilities were judged to be the least useful of the combinations
left after the by-construction properties of the roots and the myriad
<<CLRPERM>> rules had pruned the possible combinations.
It is easy to verify that all other permission bits are determined by
the presence of <<zylevels1_sl_perm>> and the absence of <<r_perm>>:

* Granting <<zylevels1_sl_perm>>
  implies granting both <<w_perm>> and <<c_perm>>
  (by <<perm_req:zylevels1:sl:c-and-w>>).

* Granting <<w_perm>> then implies that none of the following are granted:

** <<x_perm>> (by <<perm_req:xycheriot:w-nand-x>>),

** <<asr_perm>> (by <<perm_req:base:asr:x>>),

** <<zyseal_se_perm>>, <<zyseal_us_perm>>, or the SDP `U0`
   (by <<perm_req:xycheriot:mem-nand-ct>>).

* Not granting <<r_perm>> implies granting neither

** <<lm_perm>> (by <<perm_req:base:lm:c-and-r>>) nor

** <<zylevels1_lg_perm>> (by <<perm_req:zylevels1:lg:c-and-r>>).

The only permission bit left to consider is <<zylevels1_gl_perm>>.
Thus, making <<zylevels1_sl_perm>> depend on <<r_perm>> has the effect of
precluding exactly the two stated capability forms.
=====

.Encoding of permissions for {cheriot_ext_name}
[#tab_cheriot_perms_enc,width="100%",cols="^1,^1,^1,^1,^1,^1,^3,^4",align="center"]
|===
6+h|Bit index           .2+.^h| Implicit permissions .2+.^h| Description
h| 5 h| 4 h| 3 h| 2 h| 1 h| 0

.6+.^| <<zylevels1_gl_perm,GL>>
m| 1 m| 1 | <<zylevels1_sl_perm,SL>> | <<lm_perm,LM>> | <<zylevels1_lg_perm,LG>>
| <<r_perm,R>>, <<w_perm,W>>, <<c_perm,C>> | Memory cap-R/W

m| 1 m| 0 m| 1 | <<lm_perm,LM>> | <<zylevels1_lg_perm,LG>>
| <<r_perm,R>>, <<c_perm,C>> | Memory cap-R/O

m| 1 m| 0 m| 0 m| 0 m| 0
| <<w_perm,W>>, <<c_perm,C>> | Memory cap-W/O

m| 1 m| 0 m| 0 | <<r_perm,R>> | <<w_perm,W>>
| ∅ | Memory data-only

m| 0 m| 1 | <<asr_perm,ASR>> | <<lm_perm,LM>> | <<zylevels1_lg_perm,LG>>
| <<x_perm,X>>, <<r_perm,R>>, <<c_perm,C>> | Memory executable

m| 0 m| 0 | SDP U0 | <<zyseal_se_perm,SE>> | <<zyseal_us_perm,US>>
| ∅ | Sealing
|===

[NOTE]
=====
TODO: See §7.13.1 / "Capability permissions" of {cheriot_v1_isa}.
=====

==== <<sec_cap_type>> Values and Encoding

{cheriot_ext_name} uses a 3-bit field to encode <<sec_cap_type>> values.
Unsealed capabilities, those with type `0`, have an all-zeros type field,
and an all-zeros type field always corresponds to an unsealed capability.
Otherwise, the interpretation of this field
_depends on the capability's <<x_perm>> value_:
field values `0b001` through `0b111` correspond to types...

* {cheriot_ot_x_min} (inclusive) through {cheriot_ot_x_max} (inclusive)
  iff the capability grants <<x_perm>>, or

* {cheriot_ot_nx_min} (inclusive) through {cheriot_ot_nx_max} (inclusive)
  iff the capability does not grant <<x_perm>>.

That is, it is not possible to express a capability with type between
{cheriot_ot_x_min} (inclusive) through {cheriot_ot_x_max} (inclusive)
that does not grant <<x_perm>> or, dually, one with type between
{cheriot_ot_nx_min} (inclusive) through {cheriot_ot_nx_max} (inclusive)
that does grant <<x_perm>>.
Attempts to <<YSEAL>> or otherwise construct such a capability,
or one with type equal to {cheriot_ot_absent} or above {cheriot_ot_max},
will instead result in a cleared {ctag}.

_No_ non-zero <<sec_cap_type>> value is considered
<<sec_cap_type_ambient,ambiently available>>,
even the <<sentry_cap>> types (see below).

[NOTE]
=====
The lack of ambient types has implications:

* The <<section_rvy_sentry_insn_ext>> extension (and its <<SENTRY>> instruction)
  requires an ambiently available type,
  and so <<section_rvy_sentry_insn_ext>> is incompatible with {cheriot_ext_name}.

* If the result of a <<CBLD>> instruction has a set {ctag},
  then it will also be unsealed,
  even if the input bit pattern was one of a sealed capability.
=====

[NOTE]
=====
CHERIoT's RTOS's runtime environment bootstraps,
from the few _architectural capability_ sealing types available herein,
a much larger space of _virtual_ sealing types
which apply to entire software _objects_ rather than pointers to objects.
This virtualization takes advantage of the XLEN-bits space of type identifiers
offered by <<section_zyseal>>, even though most of those types
have no architectural encoding within capabilities.
See https://cheriot.org/book/memory.html#token_apis for details.
=====

[NOTE]
=====
See §7.13.2 / "Sealed capabilities" of {cheriot_v1_isa}.
=====

[#section_xycheriot_auipc_shift]
==== <<AUIPC_CHERI>> Shift

<<AUIPC_CHERI>> and {cheriot_ext_name}'s own <<section_xycheriot_auicgp>>
define their <<section_auipc_shift>> value to be **11**.
That is, these instructions interpret their 20-bit immediate operand
with an 11-bit left shift rather than the traditional 12.
Thus, `auipc {cd}, 0x1` adds `1 << 11` to <<pcc>>'s address
and stores the result in `{cd}`.

[NOTE]
=====
Recall that the {cheriot_ext_name} encoding does not guarantee sufficient
<<section_rep_check_concept,"out-of-bounds representability">>
for the traditional 12-bit interpretation.
(In fact, it _guarantees_ only that one-past-the-end is representable,
as required for capabilities to be suitable lowerings of
pointers as defined by the C programming language.)

=====

=== Sentries

{cheriot_ext_name} defines _five_ <<sentry_cap>> <<sec_cap_type>> values
({cheriot_sentry_ot_min} through {cheriot_sentry_ot_max}, inclusive):

* Any of these values may be passed as inputs to <<JALR_CHERI>>.
  When such a <<JALR_CHERI>> instruction retires,
  the hart's `mstatus.MIE` bit is updated as per <<tab_cheriot_sentry_irq>>.

* Two values, {cheriot_sentry_ot_bd} and {cheriot_sentry_ot_be},
  are used by <<JALR_CHERI>> to seal the return capability.
  If the hart's `mstatus.MIE` bit is `0`
  after the prior instruction has retired,
  the return capability is sealed with {cheriot_sentry_ot_bd};
  otherwise, {cheriot_sentry_ot_be} is used.

* <<JALR_CHERI>> is given conditional behavior
  based on the register selectors used,
  as detailed in <<tab_cheriot_jalr_regs>>.
  Prohibited combinations of register selectors and <<sec_cap_type>> value
  will cause the target <<pcc>> to have a clear {ctag} and so raise a
  {cheri_excep_name_pc}.

[NOTE]
=====
All of the <<sentry_cap>> <<sec_cap_type>> values
are encodable if and only if the capability grants <<x_perm>>.
The remaining two <<x_perm>>-associated <<sec_cap_type>> values
are not <<sentry_cap>> types and remain available for software's use,
as do all of the <<sec_cap_type>> values
associated with capabilities not granting <<x_perm>>.
=====

.Additional <<JALR_CHERI>> Architectural Semantics
[#tab_cheriot_sentry_irq,width="100%",options=header,halign=center,cols="1,5"]
|===
| <<sec_cap_type>>       | IRQs at Retirement (`mstatus.MIE`)
| {cheriot_sentry_ot_fi} | Unchanged (as is)
| {cheriot_sentry_ot_fd}, {cheriot_sentry_ot_bd} | Deferred (`0`)
| {cheriot_sentry_ot_fe}, {cheriot_sentry_ot_be} | Enabled (`1`)
|===

.<<JALR_CHERI>> Conditional Behavior
[#tab_cheriot_jalr_regs,width="100%",options=header,halign=center,cols="1,2,4,4"]
|===
| {cs1} | {cd}   | Permitted {cs1} <<sec_cap_type>>-s | Comments
| `ra`  | `null` | {cheriot_sentry_ot_bd}, {cheriot_sentry_ot_be} | Function return
| ≠`ra` | `null` | 0, {cheriot_sentry_ot_fi} | Tail call
| any   | ∉{ `null`, `ra` } | 0, {cheriot_sentry_ot_fi} | Code outlining
| any   | `ra`   | 0, {cheriot_sentry_ot_fi}, {cheriot_sentry_ot_fd}, {cheriot_sentry_ot_fe} | Function call
|===

[NOTE]
=====
See §7.13.2 / "Sealed capabilities" of {cheriot_v1_isa}.
=====

[NOTE]
=====
TODO, research required:
Can we refine that table to introduce "must be unsealed" and "must be sealed"
forward arc rows, or do we need a second instruction instead?

How hard is it to explain such a thing to LLVM?  Would we need to push type
refinements up onto C / C++ function pointers?

=====

=== Stack High Watermark CSRs

{cheriot_ext_name} introduces two new XLEN CSRs: `mshwm` and `mshwmb`.  Both are
freely read but require <<asr_perm>> for explicit writes from software.  Writes
are WARL, with legal values being addresses with capability alignment (that is,
multiples of YLEN bits in octet bytes).  Store instructions targeting addresses
between the values held in `mshwm` and `mshwmb` cause `mshwm` to be updated to
the lowest targeted address (rounded down to capability alignment).

[NOTE]
=====
The intended software use of these CSRs is, as the section title suggests,
to track the "high watermark" of a thread's C stack
(that is, the lowest address written to, because "stacks grow down").
The thread context switching code should context switch these registers,
having initialized `mshwmb` to the lower bound of the thread's stack capability
and `mshwm` to its upper bound.
Privileged stack zeroing code can be used to lower `mshwm`, so that all bytes
between the addresses held in `mshwm` and `mshwmb` are known to be zero.
=====

[NOTE]
=====
See §7.15 / "Stack high water mark" of {cheriot_v1_isa}.
=====

=== New Instructions

[#section_xycheriot_auicgp,reftext="{cheriot_auicgp_name}"]
==== {cheriot_auicgp_name}

{cheriot_ext_name} defines a new U-type instruction, {cheriot_auicgp_name},
which shifts
(by the <<section_xycheriot_auipc_shift,AUIPC shift>>)
and adds its 20-bit immediate to the address of <<mtidc>>
(using the semantics of the <<CADD>> instruction)
and stores the resulting capability in a target register,
analogously to <<AUIPC_CHERI>> and <<pcc>>.

[NOTE]
=====
See `AUICGP` in {cheriot_v1_isa}.
Therein, a compartment's globals pointer
is not held in a CSR, but rather the `x2` GPR;
the use of a CSR is presently experimental.
The impact of lowering register pressure is yet to be measured.
=====

==== {cheriot_setbounds_big_imm_name}

[NOTE]
=====
TODO: setbounds immediate as an I-type instruction w/ 12-bit immediate rather
than the base's R-type w/ (scaled) 5-bit immediate, <<SCBNDSI>>.
See `CSetBoundsImm` in {cheriot_v1_isa}.

Maybe this should be some non-{cheriot_ext_name} extension.
=====

[NOTE]
=====
TODO, research required:
While this instruction exists in the CHERIoT ISA,
the {cheri_base_ext_name} <<SCBNDSI>> form does not.
What is the best way to take advantage of having both
an I-type and R-type instruction available?

Should the I-type instruction's immediate be a length and a shift,
since our encoding's mantissas are smaller than 12 bits wide?

=====

==== {cheriot_setbounds_round_down_name}

[NOTE]
=====
TODO: setbounds register that fixes base and rounds length down for
representability.
(Contrast the rounding behavior of <<SCBNDS>>.)
See `CSetBoundsRoundDown` in {cheriot_v1_isa}.

Maybe this should be some non-{cheriot_ext_name} extension.
=====

==== {cheriot_gettop_name}

[NOTE]
=====
TODO: Two-operand instruction that fuses <<GCBASE>>, <<GCLEN>>, and ADD.
Easy for microarchitecture given how we unpack capabilities in registers.
See `CGetTop` in {cheriot_v1_isa}.

Maybe this should be some non-{cheriot_ext_name} extension.
=====

==== Loads and Stores With `x0` Authority

Load and store instructions using `x0` as the base register,
such as `{load_cap_name_lc} {cd}, n(x0)`,
would, in the {cheri_base_ext_name} base ISA,
necessarily fault due to the clear {ctag} of the all-zeros `x0`.
{cheriot_ext_name} (re)defines these reserved instruction values
as loads and stores using <<mtidc>> as the authority, instead.

[NOTE]
=====
TODO, research required:
we have yet to have a research implementation with this change in place.
Performance impacts have yet to be evaluated.

Perhaps this should be some non-{cheriot_ext_name} extension.
=====

==== Conditional Branches

{cheri_base_ext_name} reserves uncompressed `beq` and `bne` instruction
encodings in which `rs1≥rs2`.
{cheriot_ext_name} defines such instructions with `rs2=0` to be
conditional branches on the {ctag} of `rs1` being set (`beq`) or clear (`bne`).

[NOTE]
=====
TODO, research required:
we have yet to have a research implementation with this change in place.
The impacts on code size and dynamic instruction count are yet to be measured.

Maybe this should be some non-{cheriot_ext_name} extension.
=====

=== Miscellaneous Changes

==== CSR Reset Values

The {cheri_base_ext_name} base privileged ISA tends to define
M-mode CSRs' reset values either as <<root-rx-cap>> capabilities or
as otherwise unspecified values with clear {ctag}s.
To make available {cheriot_ext_name}'s multiple
<<section_xycheriot_roots,root>> capability values,
we redefine two CSRs' reset values:

<<mtidc>>::
The <<mtidc>> register's reset value is changed to be
{cheriot_ext_name}'s <<root-rw-cap>> capability value (with set {ctag}).

<<mscratch>>::
The <<mscratch>> register's reset value is changed to be
{cheriot_ext_name}'s _sealing_ capability value (with set {ctag}).

==== Additional CSR Legalization Requirements

All of <<pcc>>, <<mtvec>>, and <<mepc>> will clear their {ctag} if the
capability they would come to hold after an update
would be sealed or would not grant <<x_perm>>.

[NOTE]
=====
All three of these CSRs reset to <<root-rx-cap>> capabilities
(with unspecified addresses), which satisfy this legalization requirement.
Neither architecture nor software expects to be able
to place capabilities thereby prohibited in these CSRs.
=====

[NOTE]
=====
TODO, research required:
we can readily additionally require not-<<x_perm>>
of one of <<mtidc>> and <<mscratch>>,
whichever is not involved in the `csrrw` at the start of trap entry.
If we can revise trap entry suitably, we could further require
not-<<x_perm>> of both and not-sealing-root of <<mtidc>>.
=====

==== <<JALR_CHERI>> Exceptions

We permit, but do not require, <<JALR_CHERI>> instructions
which compute target <<pcc>>s with a clear {ctag},
to raise a trap, rather than retiring.
The security of the system is not altered by such behavior,
but raising faults at the <<JALR_CHERI>> instruction improves
the diagnostic and debugging experience.

=== Porting from CHERIoTv1

==== Assembler Register Names

CHERIoTv1 differentiated between register selector operands intended to access
an integer value (`xN`) from those intended to access a capability value (`cN`).
ABI names for registers were similarly differeniated,
using a prefix of `c` when the full capability was intended (`csp`, `ca0`, &c).
{cheri_base_ext_name} does away with the distinction:
all register selectors are `xN` and all ABI names are un-prefixed.

==== `CGetAddr` and `CSub` Replacement

CHERIoTv1 inherited from CHERI v9, and subsequently offered,
a `CGetAddr` instruction which copied a capability while
explicitly zeroing its {ctag} and metadata, preserving only the address.
`CGetAddr` largely dates back to early CHERI research machines,
when capability registers were, like floating registers (without Zfinx),
distinct from integer registers,
and was largely obsolesced by CHERIoTv1 using a merged register file.
Since {cheri_base_ext_name} likewise uses a merged regiser file,
instructions consuming XLEN-width values use the
XLEN-width address field of a capability while ignoring its {ctag} and metadata,
and instructions producing XLEN-width results
write capability values with zero {ctag} and metadata.
Thus, `addi x1, x2, 0` exactly replaces CHERIoTv1's `CGetAddr x1, c2`;
the latter form, and/or a `YADDRR` mnemonic consistent with <<SCADDR>>,
may still be usefully provided by an assembler for documeting programmer intent.

Similarly, CHERIoTv1's `CSub rd, cs1, cs2` instruction for computing
the (integer) differences between two capabilities' address fields,
may be replaced with integer subtraction, `sub rd, rs1, rs2`.

==== Permission Bitfield Semantics

The permissions bit field used by <<GCPERM>> (replacing `CGetPerm`)
is permuted with respect to CHERIoTv1, and permissions are renamed.
Nevertheless, permission *semantics* are in direct correspondence, thus:

|===
| CHERIoTv1 | {cheriot_ext_name}

| EX        | <<x_perm>>
| SR        | <<asr_perm>>
| SE        | <<zyseal_se_perm>>
| US        | <<zyseal_us_perm>>
| U0        | SDP bit 0
| GL        | <<zylevels1_gl_perm>>
| SL        | <<zylevels1_sl_perm>>
| LM        | <<lm_perm>>
| LG        | <<zylevels1_lg_perm>>
| MC        | <<c_perm>>
| SD        | <<w_perm>>
| LD        | <<r_perm>>
|===

The bitwise AND behavior of CHERIoTv1's `CAndPerm` has been replaced with
the bitwise AND NOT behavior of <<CLRPERM>>.
Permission masks should thus be permuted and bitwise negated.

==== Elimination of Special Capability Registers

CHERIoTv1 inherited from University CHERI a notion of
"special capability registers" (SCRs; its §7.10) in addition to CSRs.
The base {cheri_base_ext_name} ISA has instead extended some CSRs to YLEN.
CHERIoTv1's `MTCC`, `MScratchC`, and `MEPCC` SCRs directly correspond with
{cheri_base_ext_name}'s <<mtvec>>, <<mscratch>>, and <<mepc>> YLEN-wide CSRs.
CHERIoTv1 additionally has a `MTDC` SCR, which may yet make an appearance
in {cheriot_ext_name}.

[NOTE]
=====
TODO, research required: should we add/keep a direct `MTDC` replacement CSR
in addition to <<mscratch>>?

=====
