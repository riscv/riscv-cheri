[appendix]
== {cheri_base_ext_name} Extensions Summary

An {cheri_base_ext_name} core imports _all_ instructions from RVI and adds new instructions for CHERI functionality.
Additionally, some RVI instruction (as well as instructions defined in other extensions) have modified behavior.
The following sections detail the list of added/modified instructions per extension.

[#rvy_insn_table, reftext="{cheri_base_ext_name}"]
=== {cheri_base_ext_name} added instructions

.{cheri_base_ext_name} added instructions
[#{rvy_file_name}]
[width="100%",options=header,cols="2,1,1,5",]
|==============================================================================
include::generated/{rvy_file_name}.adoc[]
|==============================================================================

[#rvy_i_mod_insn_table, reftext="{rvy_i_mod_ext_name}"]
=== {rvy_i_mod_ext_name}

The following RVI instructions have _modified_ behavior due to adding CHERI functionality.
In general, this is restricted to changing whether input/output operands read/write XLEN or YLEN bits.

.{rvy_i_mod_ext_name} instructions
[#{rvy_i_mod_file_name}]
[width="100%",options=header,cols="2,1,1,5",]
|==============================================================================
include::generated/{rvy_i_mod_file_name}.adoc[]
|==============================================================================


[#rvy_zicsr_mod_insn_table, reftext="{rvy_zicsr_mod_ext_name}"]
=== {rvy_zicsr_mod_ext_name}

The following RVI instructions have _modified_ behavior due to adding CHERI functionality.
In general, this is restricted to changing whether input/output operands read/write XLEN or YLEN bits.

.{rvy_zicsr_mod_ext_name} instructions
[#{rvy_zicsr_mod_file_name}]
[width="100%",options=header,cols="2,1,1,5",]
|==============================================================================
include::generated/{rvy_zicsr_mod_file_name}.adoc[]
|==============================================================================

[#rvy_sentry_insn_table, reftext="{rvy_sentry_ext_name}"]
=== {rvy_sentry_ext_name}

{rvy_sentry_ext_name} adds the sentry capability type.

.{rvy_sentry_ext_name} instruction extension
[#{rvy_sentry_file_name}]
[width="100%",options=header,cols="2,1,1,5",]
|==============================================================================
include::generated/{rvy_sentry_file_name}.adoc[]
|==============================================================================

[#rvy_zca_insn_table, reftext="{rvy_zca_ext_name}"]
=== {rvy_zca_ext_name}

An {cheri_base_ext_name} core which supports Zca should also support {rvy_zca_ext_name}.

{rvy_zca_ext_name} is incompatible with Zcf (RV32) and Zcd (RV64).

.{rvy_zca_ext_name} instruction extension
[#{rvy_zca_file_name}]
[width="100%",options=header,cols="2,1,1,5",]
|==============================================================================
include::generated/{rvy_zca_file_name}.adoc[]
|==============================================================================

ifdef::cheri_standalone_spec[]
<<<
//this has all been integrated into the relevant chapter
=== RV32 / {cheri_base32_ext_name} RVC load/store mapping summary

include::rv32c_mapping_table.adoc[]

<<<
=== RV64 / {cheri_base64_ext_name} RVC load/store mapping summary

include::rv64c_mapping_table.adoc[]

endif::[]

include::insns/load_16bit_cap_sprel.adoc[]
include::insns/store_16bit_cap_sprel.adoc[]

<<<

[#rvy_zca_mod_insn_table, reftext="{rvy_zca_mod_ext_name}"]
=== {rvy_zca_mod_ext_name}

An {cheri_base_ext_name} core which supports Zca must also support {rvy_zca_mod_ext_name} which _modifies_ the behavior of some instructions.

NOTE: {C_MV_CAP_LC} is renamed from `c.mv` to avoid ambiguity in disassembly.

.{rvy_zca_mod_ext_name} instruction extension
[#{rvy_zca_mod_file_name}]
[width="100%",options=header,cols="2,1,1,5",]
|==============================================================================
include::generated/{rvy_zca_mod_file_name}.adoc[]
|==============================================================================

include::insns/addi16sp_16bit.adoc[]
include::insns/addi4spn_16bit.adoc[]
include::insns/cmv_16bit.adoc[]
include::insns/jr_16bit.adoc[]
include::insns/jal_16bit.adoc[]
include::insns/jalr_16bit.adoc[]

<<<

[#rvy_zalrsc_insn_table, reftext="{rvy_zalrsc_ext_name}"]
=== {rvy_zalrsc_ext_name}

Specifying {cheri_base_ext_name} and Zalrsc adds atomic capability load and store instructions.

.{rvy_zalrsc_ext_name} instruction extension
[#{rvy_zalrsc_file_name}]
[width="100%",options=header,cols="2,1,1,5",]
|==============================================================================
include::generated/{rvy_zalrsc_file_name}.adoc[]
|==============================================================================

ifdef::cheri_standalone_spec[]
include::insns/load_res_cap_32bit.adoc[]
include::insns/store_cond_cap_32bit.adoc[]
<<<
endif::[]

[#rvy_zaamo_insn_table, reftext="{rvy_zaamo_ext_name}"]
=== {rvy_zaamo_ext_name}

Specifying {cheri_base_ext_name} and Zaamo gives {rvy_zaamo_ext_name} functionality, which adds atomic capability swap.

.{rvy_zaamo_ext_name} instruction extension
[#{rvy_zaamo_file_name}]
[width="100%",options=header,cols="2,1,1,5",]
|==============================================================================
include::generated/{rvy_zaamo_file_name}.adoc[]
|==============================================================================

ifdef::cheri_standalone_spec[]
include::insns/amoswap_32bit_cap.adoc[]
<<<
endif::[]

[#rvy_h_insn_table, reftext="{rvy_h_ext_name}"]
=== {rvy_h_ext_name}

Specifying {cheri_base_ext_name} and "H" gives {rvy_h_ext_name} functionality, which adds virtualized capability load and store instructions.

While HLVX.* only requires execute permission in the PTE, the authorizing CHERI capability must grant <<r_perm>>.

.{rvy_h_ext_name} instruction extension
[#{rvy_h_file_name}]
[width="100%",options=header,cols="2,1,1,5",]
|==============================================================================
include::generated/{rvy_h_file_name}.adoc[]
|==============================================================================

include::insns/hypv-virt-load-cap.adoc[]
include::insns/hypv-virt-store-cap.adoc[]

<<<

[#rvy_zba_insn_table, reftext="{rvy_zba_ext_name}"]
=== {rvy_zba_ext_name}

Specifying {cheri_base_ext_name} and Zba gives {rvy_zba_ext_name} functionality, which adds more instructions.

.{rvy_zba_ext_name} instruction extension
[#{rvy_zba_file_name}]
[width="100%",options=header,cols="2,1,1,5",]
|==============================================================================
include::generated/{rvy_zba_file_name}.adoc[]
|==============================================================================

NOTE: There is no {cheri_base_ext_name} equivalent for `add.uw` as only having the integer version is sufficient.

ifdef::cheri_standalone_spec[]
// For the integrated build, these instruction listings are in the Zba chapter.
include::insns/sh1234add_32bit.adoc[]
include::insns/sh1234add_uw_32bit.adoc[]

<<<
endif::[]

[#rvy_zicbom_mod_insn_table, reftext="{rvy_zicbom_mod_ext_name}"]
=== {rvy_zicbom_mod_ext_name}

Specifying {cheri_base_ext_name} and Zicbom gives {rvy_zicbom_mod_ext_name} functionality, which extends the checking.

.{rvy_zicbom_mod_ext_name} instruction extension
[#{rvy_zicbom_mod_file_name}]
[width="100%",options=header,cols="2,1,1,5",]
|==============================================================================
include::generated/{rvy_zicbom_mod_file_name}.adoc[]
|==============================================================================

include::insns/cbo.clean.adoc[]
include::insns/cbo.flush.adoc[]
include::insns/cbo.inval.adoc[]

<<<

[#rvy_zicboz_mod_insn_table, reftext="{rvy_zicboz_mod_ext_name}"]
=== {rvy_zicboz_mod_ext_name}

Specifying {cheri_base_ext_name} and Zicboz gives {rvy_zicboz_mod_ext_name} functionality, which extends the checking.

.{rvy_zicboz_mod_ext_name} instruction extension
[#{rvy_zicboz_mod_file_name}]
[width="100%",options=header,cols="2,1,1,5",]
|==============================================================================
include::generated/{rvy_zicboz_mod_file_name}.adoc[]
|==============================================================================

include::insns/cbo.zero.adoc[]

<<<

[#rvy_zicbop_mod_insn_table, reftext="{rvy_zicbop_mod_ext_name}"]
=== {rvy_zicbop_mod_ext_name}

Specifying {cheri_base_ext_name} and Zicbop gives {rvy_zicbop_mod_ext_name} functionality, which extends the checking.

.{rvy_zicbop_mod_ext_name} instruction extension
[#{rvy_zicbop_mod_file_name}]
[width="100%",options=header,cols="2,1,1,5",]
|==============================================================================
include::generated/{rvy_zicbop_mod_file_name}.adoc[]
|==============================================================================

include::insns/prefetch.i.adoc[]
include::insns/prefetch.r.adoc[]
include::insns/prefetch.w.adoc[]

<<<

[#rvy_hybrid_insn_table, reftext="{cheri_default_ext_name}"]
=== {cheri_default_ext_name}

An {cheri_base_ext_name} core which supports {cheri_default_ext_name} adds the instructions in <<{rvy_hybrid_file_name}>>.

.{cheri_default_ext_name} instruction extension
[#{rvy_hybrid_file_name}]
[width="100%",options=header,cols="2,1,1,5",]
|==============================================================================
include::generated/{rvy_hybrid_file_name}.adoc[]
|==============================================================================

include::insns/scmode_32bit.adoc[]

include::insns/gcmode_32bit.adoc[]

include::insns/modesw_32bit.adoc[]

<<<

=== {cheri_base_ext_name} Privileged and Debug ISA

#these need moving#

include::insns/mret_sret.adoc[]
include::insns/dret.adoc[]

<<<

[appendix]
[#clen_csr_summary]
== Capability Width CSR Summary

.CSRs aliased and extended to capability width
[#aliased_CSRs]
[width="100%",options=header,cols="1,1,1"]
|==============================================================================
include::generated/csr_aliases_table_body.adoc[]
|==============================================================================

.Action taken on writing to extended CSRs
[#extended_CSR_writing]
[width="100%",options=header,cols="1,2,2"]
|==============================================================================
include::generated/csr_alias_action_table_body.adoc[]
|==============================================================================

^*^ The vector range check is to ensure that vectored entry to the handler is within bounds of the capability written to `__x__tvec`.
  The check on writing must include the lowest (0 offset) and highest possible offset (e.g., 64 * MXLEN bits where HICAUSE=16).

XLEN bits of extended YLEN-wide CSRs are written when executing
<<CSRRWI_CHERI>>, <<CSRRC_CHERI>>, <<CSRRS_CHERI>>, <<CSRRCI_CHERI>> or <<CSRRSI_CHERI>> regardless of the
CHERI execution mode. When using <<CSRRW_CHERI>>, YLEN bits are written when the
CHERI execution mode is {cheri_cap_mode_name} and XLEN bits are written when
the mode is {cheri_int_mode_name}; therefore, writing XLEN bits with <<CSRRW_CHERI>>
is only possible when {cheri_default_ext_name} is implemented.

.Action taken on writing to YLEN-wide CSRs
[#new_cap_CSR_writing]
[width="100%",options=header,cols="1,2,2"]
|==============================================================================
include::generated/new_csr_write_action_table_body.adoc[]
|==============================================================================

XLEN bits of YLEN-wide CSRs added in {cheri_default_ext_name} are
written when executing <<CSRRWI_CHERI>>, <<CSRRC_CHERI>>, <<CSRRS_CHERI>>, <<CSRRCI_CHERI>> or
<<CSRRSI_CHERI>> regardless of the CHERI execution mode. YLEN bits are always written
when using <<CSRRW_CHERI>> regardless of the CHERI execution mode.

NOTE: Implementations which allow misa.C to be writable need to legalize `__x__epc`
 on _reading_ if the misa.C value has changed since the value was written as this
 can cause the read value of bit [1] to change state.

.YLEN-wide CSRs storing code pointers or data pointers
[#CSR_exevectors]
[width="100%",options=header,cols="1,1,1,1"]
|==============================================================================
include::generated/csr_exevectors_table_body.adoc[]
|==============================================================================

Some CSRs store code pointers or data pointers as shown in xref:CSR_exevectors[xrefstyle=short].
These are WARL CSRs that do not need to store full 64-bit addresses on RV64, and so need not be capable
of holding all possible invalid addresses. Prior to writing an invalid address to these CSRs,
the address must be converted to another invalid address that the CSR is capable of holding.
CSRs that store fewer address bits are also subject to the invalid address
check in <<section_invalid_addr_conv>> on writing.

xref:all_capability_CSRs[xrefstyle=short] shows all YLEN-wide CSRs.

.All YLEN-wide CSRs.
[#all_capability_CSRs]
[width="100%",options=header,cols="2,1,1,2,2,4"]
|==============================================================================
include::generated/csr_permission_table_body.adoc[]
|==============================================================================
