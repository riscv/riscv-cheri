[#section_cheri_hybrid_ext]
== "{cheri_default_ext_name}" Extension for CHERI Execution Modes

ifdef::cheri_standalone_spec[]
WARNING: This chapter will appear in the unpriv spec somewhere after the Zicsr chapter (since it depends on Zicsr).
endif::[]

{cheri_default_ext_name} is an optional extension to {cheri_base_ext_name} which adds the ability to dynamically change the base architecture of the hart between  CHERI ({cheri_base_ext_name}) and standard RISC-V (RVI/RVE).

The ability to choose between these two behaviors is referred to as switching between _CHERI Execution Modes_. The mode is controlled by a new bit (the <<m_bit>>) allocated in the <<pcc>>.

{cheri_default_ext_name} adds the instructions shown in <<rvy_hybrid_insn_table>> which add the ability to query and update the current mode.

{cheri_default_ext_name} also adds a new unprivileged CSR: the default data capability, <<ddc>>. <<ddc>> is used to authorize all data memory accesses when executing RVI/RVE code.

NOTE: Together with <<pcc>>, <<ddc>> allows confining code runs to a compartment (also called a _sandbox_), where all data memory and instruction memory accesses are bounded to fixed memory regions. These compartments have full binary compatibility with all existing ratified RISC-V base architectures and extensions,
i.e. non-CHERI aware programs which execute unmodified. Providing that the privileged execution environment has set up <<ddc>> and <<pcc>> appropriately, non-CHERI aware programs will execute unmodified providing they don't attempt to access memory out of the defined bounds.

{cheri_base_ext_name} implementations which support {cheri_default_ext_name} are typically referred to as CHERI Hybrid, whereas implementations which do not support {cheri_default_ext_name} are typically referred to as CHERI purecap.

[#cheri_execution_mode,reftext="CHERI Execution Mode"]
=== CHERI Execution Modes

The two execution modes are:

{cheri_int_mode_name}::
Executing with the RVI (or RVE) base ISA.
+
NOTE: If RVC encodings are supported, load/store encodings will revert back to their non-CHERI encodings, such as <<C_LOAD_CAP_SP>> reverting to C.FLWSP for RV32F. This behavior is summarized in <<insn_remapping_16bit_rv32_a>>, <<insn_remapping_16bit_rv32_b>>, <<insn_remapping_16bit_rv64_a>> and <<insn_remapping_16bit_rv64_b>>.
+
NOTE: Instructions which are _modified_ on an {cheri_base_ext_name} architecture (<<rvy_insn_table>>) _revert to their standard behavior_.
+
All <<rvy_insn_table>> instructions, and associated CSRs, are available in addition to RVI/RVE and all supported non-CHERI extensions.
+
All memory accesses are implicitly authorized by <<ddc>>, including <<PREFETCH_W_CHERI>> and <<PREFETCH_R_CHERI>>.
<<PREFETCH_I_CHERI>> is authorized by <<pcc>> instead.
+
NOTE: <<ddc>> is also used to authorize {cheri_base_ext_name} specific memory instructions such as <<LOAD_CAP>> and <<STORE_CAP>>.
+
All CSR accesses to YLEN CSRs only access the lower XLEN bits, and, if writing, update the CSR using the semantics of the <<SCADDR>> instruction (see xref:zicsr-section-default[xrefstyle=short]).

{cheri_cap_mode_name}::
Executing with the {cheri_base_ext_name} base ISA.

The _<<cheri_execution_mode>>_ is key in providing backwards compatibility with the base RV32I/RV64I ISA.
RISC-V software is able to execute unchanged in implementations supporting {cheri_default_ext_name} provided that the privileged environment sets up <<ddc>> and <<pcc>> appropriately.

NOTE: The CHERI execution mode is always {cheri_cap_mode_name} on implementations that support {cheri_base_ext_name}, but not {cheri_default_ext_name}.

[#m_bit,reftext="M-bit"]
==== CHERI Execution Mode Encoding

The _<<cheri_execution_mode>>_ is determined by a bit in the metadata of the <<pcc>> called the <<m_bit>>.
{cheri_default_ext_name} adds a new _<<cheri_execution_mode>>_ field (M) to the capability format.
Although always present, it only takes effect in code capabilities, i.e., when the <<x_perm>> is set.
The exact location of the M-bit in the capability format for XLEN=32 and XLEN=64 is described in <<app_cap_description>>.

* Mode (M)={CAP_MODE_VALUE} indicates {cheri_cap_mode_name}.
* Mode (M)={INT_MODE_VALUE} indicates {cheri_int_mode_name}.

IMPORTANT: While the <<m_bit>> only has an effect when installed in <<pcc>>, it needs to be encoded in all capabilities.
  Since indirect jumps copy the full target capability into <<pcc>>, it allows indirect jumps to change between modes (see <<sec_changing_cheri_execution_mode>>).

//#I don't understand this statement, as <<MODESW_CAP>> can be executed at any time#
//The <<m_bit>> of the <<pcc>>, may be overridden by the execution environment which may not grant permission to enter {cheri_cap_mode_name}.

[#sec_changing_cheri_execution_mode]
==== Changing CHERI Execution Mode
The <<m_bit>> of <<pcc>> can be updated by the instructions listed in <<tab_cheri_mode_sw_summary>>:

.{cheri_default_ext_name} instructions that can perform mode changes
[#tab_cheri_mode_sw_summary,%autowidth,options=header,align="center",cols="2,2,4"]
|=======================
|Mnemonic        | From mode          | Description
| <<JALR_CHERI>> |{cheri_cap_mode_name}| {JALR_CHERI_DESC}
| <<MODESW_INT>> |{cheri_cap_mode_name}| {MODESW_INT_DESC}
| <<MODESW_CAP>> |{cheri_int_mode_name}| {MODESW_CAP_DESC}
|=======================

The <<m_bit>> of a <<x_perm>>-granting capability can be read and written by the instructions listed in <<tab_hybrid_summary>>:

.{cheri_default_ext_name} instructions to observe and update the mode in a capability
[#tab_hybrid_summary,%autowidth,options=header,align="center",cols="1,4"]
|=======================
|Mnemonic      |Description
|<<SCMODE>>    |{SCMODE_DESC}
|<<GCMODE>>    |{GCMODE_DESC}
|=======================

NOTE: In addition to the mode switching instructions, the current mode can also be updated by setting the <<m_bit>> of a target capability using <<SCMODE>> followed by a <<JALR_CHERI>>.

For capabilities that do not grant <<x_perm>>,
<<m_bit>> must always be interpreted and reported as {cap_mode_value}.

NOTE: While this is not phrased as an additional rule for <<CLRPERM>> to follow,
beyond those of <<sec_permission_transitions>>,
capability encodings may nevertheless take advantage of this implication
in their representation of architectural CHERI capabilities.

[#m_bit_observe,reftext="Observing the CHERI Execution Mode"]
==== Observing the CHERI Execution Mode

The effective CHERI execution mode cannot be determined just by reading the <<m_bit>> from <<pcc>> since it also depends on the execution environment.
The following code sequence demonstrates how a program can observe the current, effective CHERI execution mode.
It will write {CAP_MODE_VALUE} for {cheri_cap_mode_name} and {INT_MODE_VALUE} for {cheri_int_mode_name} to `x1`:

[source,subs=attributes+]
----
auipc {creg}1, 0
{gctag_lc} x1, {creg}1
----

NOTE: Implementations that support {cheri_default_ext_name} will typically boot into {cheri_int_mode_name} so that non-CHERI aware software can run unmodified.
 CHERI aware software can observe and switch the mode as required.

=== Added instructions

include::insns/scmode_32bit.adoc[]

include::insns/gcmode_32bit.adoc[]

include::insns/modesw_32bit.adoc[]

=== Added State

{cheri_default_ext_name} adds the YLEN-wide CSR shown in
xref:default-csrnames-added[xrefstyle=short].

[[default-csrnames-added]]
.Unprivileged YLEN-wide CSRs added in {cheri_default_ext_name}
[%autowidth,float="center",align="center",cols="<,<,<",options="header"]
|===
|YLEN CSR|Permissions|Description
|<<ddc>>|URW|User Default Data Capability
|===

[#ddc,reftext="ddc"]
==== Default Data Capability CSR (ddc)

<<ddc>> is a read-write, user mode accessible capability CSR.
It does not require <<asr_perm>> in <<pcc>> for writes or reads.
Similarly to <<pcc>> authorizing all control flow and instruction fetches, this capability register is implicitly checked to authorize all data memory accesses  when the current CHERI mode is {cheri_int_mode_name}.
On startup <<ddc>> bounds and permissions must be set such that the program can run successfully
(e.g., by setting it to have sufficiently broad bounds and permissions,
possibly a <<root-rw-cap>> capability).

.Unprivileged default data capability register
include::img/ddcreg.edn[]

[#zicsr-section-default]
=== Changes to Zicsr Instructions

When in {cheri_int_mode_name}, there is a special rule for updating extended CSRs (e.g., <<jvt_y>>).
These are CSRs that are XLEN-wide for RVI/RVE but YLEN-wide for {cheri_base_ext_name}.

* Writing an extended CSR writes the address field (XLEN bits) only, and the full CSR is updated using the semantics of the <<SCADDR>> instruction.
* Reading an extended CSR reads the address field (XLEN bits) only

Accesses to extended CSRs in {cheri_int_mode_name} must only access XLEN bits for compatibility, and so use the semantics of the <<SCADDR>> instruction to determine the final written value.

YLEN-wide CSRs are accessed identically in either <<cheri_execution_mode>>.

.YLEN-bit CSR and Extended CSR access summary for {cheri_default_ext_name}
[#clen_access_summary_default,%autowidth,options=header,align="center"]
|=======================
|                   2+| YLEN-bit CSR^1^           2+| Extended CSR^2^
|Instruction          | Read Width  | Write Width   | Read Width  | Write Width
|CSRRW       rd==x0   |             | YLEN          |             | XLEN
|CSRRW       rd!=x0   |YLEN         | YLEN          |XLEN         | XLEN
|CSRR[C\|S]  rs1==x0  |YLEN         |               |XLEN         |
|CSRR[C\|S]  rs1!=x0  |YLEN         | XLEN          |XLEN         | XLEN
|CSRRWI      rd==x0   |             | XLEN          |             | XLEN
|CSRRWI      rd!=x0   |YLEN         | XLEN          |XLEN         | XLEN
|CSRR[C\|S]I uimm==x0 |YLEN         |               |XLEN         |
|CSRR[C\|S]I uimm!=x0 |YLEN         | XLEN          |XLEN         | XLEN
|=======================

^1^ e.g., <<utidc>>

^2^ e.g., <<jvt_y>>

include::insns/csrr_32bit.adoc[]
include::insns/csrrw_32bit.adoc[]
