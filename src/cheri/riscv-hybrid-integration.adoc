[#section_cheri_hybrid_ext, reftext={cheri_default_ext_name}]
== "{cheri_default_ext_name}" Extension for CHERI Execution Modes

ifdef::cheri_standalone_spec[]
WARNING: This chapter will appear in the unpriv spec somewhere after the Zicsr chapter (since it depends on Zicsr).
endif::[]

{cheri_default_ext_name} is an optional extension to {cheri_base_ext_name} which adds the ability to dynamically change the base architecture of the hart between  CHERI ({cheri_base_ext_name}) and standard RISC-V (RVI/RVE).

The ability to choose between these two behaviors is referred to as switching between _CHERI Execution Modes_. The mode is controlled by a new bit (the <<m_bit>>) allocated in the <<pcc>>.

{cheri_default_ext_name} adds the instructions shown in <<rvy_hybrid_insn_table>> which add the ability to query and update the current mode.

{cheri_default_ext_name} also adds a new unprivileged CSR: the default data capability, <<ddc>>. <<ddc>> is used to authorize all data memory accesses when executing RVI/RVE code.

NOTE: Together with <<pcc>>, <<ddc>> allows confining code runs to a compartment (also called a _sandbox_), where all data memory and instruction memory accesses are bounded to fixed memory regions. These compartments have full binary compatibility with all existing ratified RISC-V base architectures and extensions,
i.e. non-CHERI-aware programs which execute unmodified.
Provided that the privileged execution environment has set up <<ddc>> and <<pcc>> appropriately, non-CHERI-aware programs will execute unmodified (as long as they don't attempt to access memory out of the defined bounds).

{cheri_base_ext_name} implementations which support {cheri_default_ext_name} are typically referred to as CHERI Hybrid, whereas implementations which do not support {cheri_default_ext_name} are typically referred to as CHERI purecap.

[#cheri_execution_mode,reftext="CHERI Execution Mode"]
=== CHERI Execution Modes

The two execution modes are:

{cheri_int_mode_name}::
Executing with the RVI (or RVE) base ISA.
+
NOTE: If RVC encodings are supported, load/store encodings will revert back to their non-CHERI encodings, such as <<C_LOAD_CAP_SP>> reverting to C.FLWSP for RV32F. This behavior is summarized in <<insn_remapping_16bit_rv32_a>>, <<insn_remapping_16bit_rv32_b>>, <<insn_remapping_16bit_rv64_a>> and <<insn_remapping_16bit_rv64_b>>.
+
NOTE: Instructions which are _modified_ on an {cheri_base_ext_name} architecture (see <<{rvy_i_mod_file_name}>>) _revert to their standard behavior_.
+
All <<rvy_insn_table>> instructions, and associated CSRs, are available in addition to RVI/RVE and all supported non-CHERI extensions.
+
The authorizing capability for memory access is <<ddc>> (as opposed to `rs1`).
That is, all memory accesses, including <<PREFETCH_W_CHERI>> and <<PREFETCH_R_CHERI>>, are implicitly authorized by <<ddc>> and only the memory address is sourced from `rs1`.
+
The prefetched address of <<PREFETCH_I_CHERI>> _should_ be authorized against <<pcc>>, but the check _may_ be avoided in the implementation, or the memory access associated with the prefetch _may_ not be issued if the address cannot be correctly authorized.
+
NOTE: High performance implementations may not have access to the <<pcc>> to authorize the access, as <<pcc>> bounds are not otherwise required in the load/store unit.
Since instruction prefetches cannot be used to violate memory safety and only impact side-channel resistence, this check is a strong recommendation rather than mandatory.
+
NOTE: <<ddc>> is also used to authorize {cheri_base_ext_name} specific memory instructions such as <<LOAD_CAP>> and <<STORE_CAP>>.
+
All CSR accesses to YLEN CSRs only access the lower XLEN bits, and, if writing, update the CSR using the semantics of the <<SCADDR>> instruction (see xref:zicsr-section-default[xrefstyle=short]).

{cheri_cap_mode_name}::
Executing with the {cheri_base_ext_name} base ISA.

The _<<cheri_execution_mode>>_ is key in providing backwards compatibility with the base RV32I/RV64I ISA.
RISC-V software is able to execute unchanged in implementations supporting {cheri_default_ext_name} provided that the privileged environment sets up <<ddc>> and <<pcc>> appropriately.

NOTE: The CHERI execution mode is always {cheri_cap_mode_name} on implementations that support {cheri_base_ext_name}, but not {cheri_default_ext_name}.

[NOTE]
====
Software is referred to as _purecap_ if it utilizes CHERI capabilities for all
memory accesses -- including loads, stores and instruction fetches -- rather
than integer addresses. Purecap software requires the CHERI RISC-V hart to
support {cheri_base_ext_name}. Software is referred to as _hybrid_ if it uses
integer addresses *or* CHERI capabilities for memory accesses. Hybrid software
requires the CHERI RISC-V hart to support {cheri_base_ext_name} and
{cheri_default_ext_name}.
====

[#m_bit,reftext="M-bit"]
==== CHERI Execution Mode Encoding

The _<<cheri_execution_mode>>_ is determined by a bit in the metadata of the <<pcc>> called the <<m_bit>>.
{cheri_default_ext_name} adds a new _<<cheri_execution_mode>>_ field (M) to the capability format.
This field needs to be present only in capabilities granting <<X-permission>>,
as it is only ever architecturally interpreted on the capability resident in <<pcc>>.

NOTE: While the <<m_bit>> can also be read/written explicitly using <<GCMODE>>/<<SCMODE>>, it only affects machine state once installed into <<pcc>>.

Capabilities not granting <<X-permission>> may or may not have a defined M field,
and attempting to update this field may be a no-op.
{cheri_default_ext_name} is compatible only with capability encodings that specify transport of the M-bit (see <<rv32y_cap_description>> and <<rv64y_cap_description>>, for examples).

* Mode (M)={CAP_MODE_VALUE} indicates {cheri_cap_mode_name}.
* Mode (M)={INT_MODE_VALUE} indicates {cheri_int_mode_name}.

IMPORTANT: Since indirect jumps copy the full target capability into <<pcc>>, it allows indirect jumps to change between modes (see <<sec_changing_cheri_execution_mode>>).

//#I don't understand this statement, as <<MODESW_CAP>> can be executed at any time#
//The <<m_bit>> of the <<pcc>>, may be overridden by the execution environment which may not grant permission to enter {cheri_cap_mode_name}.

[#sec_changing_cheri_execution_mode]
==== Changing CHERI Execution Mode
The <<m_bit>> of <<pcc>> can be updated by the instructions listed in <<tab_cheri_mode_sw_summary>>:

.{cheri_default_ext_name} instructions that can perform mode changes
[#tab_cheri_mode_sw_summary,%autowidth,options=header,align="center",cols="2,2,4"]
|=======================
|Mnemonic        | From mode          | Description
| <<JALR_CHERI>> |{cheri_cap_mode_name}| {JALR_CHERI_DESC}
| <<MODESW_INT>> |{cheri_cap_mode_name}| {MODESW_INT_DESC}
| <<MODESW_CAP>> |{cheri_int_mode_name}| {MODESW_CAP_DESC}
|=======================

NOTE: When <<JALR_CHERI>> copies `rs1` into <<pcc>> it includes copying the <<m_bit>> and so setting the <<cheri_execution_mode>> of the target instruction.

The <<m_bit>> of a <<x_perm>>-granting capability can be read and written by the instructions listed in <<tab_hybrid_summary>>:

.{cheri_default_ext_name} instructions to observe and update the mode in a capability
[#tab_hybrid_summary,%autowidth,options=header,align="center",cols="1,4"]
|=======================
|Mnemonic      |Description
|<<SCMODE>>    |{SCMODE_DESC}
|<<GCMODE>>    |{GCMODE_DESC}
|=======================

NOTE: In addition to the mode switching instructions, the current mode can also be updated by setting the <<m_bit>> of a target capability using <<SCMODE>> followed by a <<JALR_CHERI>>.

[#sec_m_bit_hybrid_rule]
==== Representation of the <<m_bit>> in the capability encoding

For capabilities that do not grant <<x_perm>>,
<<m_bit>> must always be interpreted and reported as {cap_mode_value} representing {cheri_cap_mode_name}.

NOTE: While this is not phrased as an additional rule for <<CLRPERM>> to follow,
beyond those of <<sec_permission_transitions>>,
capability encodings may nevertheless take advantage of this implication
in their representation of architectural CHERI capabilities.

[#m_bit_observe,reftext="Observing the CHERI Execution Mode"]
==== Observing the CHERI Execution Mode

The effective CHERI execution mode cannot be determined just by reading the <<m_bit>> from <<pcc>> since it also depends on the execution environment.
The following code sequence demonstrates how a program can observe the current, effective CHERI execution mode.
It will write, to `x1`, the value `1` for {cheri_cap_mode_name} (wherein `pc` has a set {ctag})
or `0` for {cheri_int_mode_name} (wherein `pc` is just an address and has a clear {ctag}):

[source,subs=attributes+]
----
auipc {creg}1, 0
{gctag_lc} x1, {creg}1
----

NOTE: Implementations that support {cheri_default_ext_name} will typically boot into {cheri_int_mode_name} so that non-CHERI-aware software can run unmodified.
 CHERI-aware software can observe and switch the mode as required.

=== Added instructions

include::insns/scmode_32bit.adoc[]

include::insns/gcmode_32bit.adoc[]

include::insns/modesw_32bit.adoc[]

=== Added State

{cheri_default_ext_name} adds the YLEN-wide CSR shown in
xref:default-csrnames-added[xrefstyle=short].

[[default-csrnames-added]]
.Unprivileged YLEN-wide CSRs added in {cheri_default_ext_name}
[%autowidth,float="center",align="center",cols="<,<,<",options="header"]
|===
|YLEN CSR|Permissions|Description
|<<ddc>>|URW|User Default Data Capability
|===

[#ddc,reftext="ddc"]
==== Default Data Capability CSR (ddc)

<<ddc>> is a read-write, user mode accessible capability CSR.
It does not require <<asr_perm>> in <<pcc>> for writes or reads.
Similarly to <<pcc>> authorizing all control flow and instruction fetches, this capability register is implicitly checked to authorize all data memory accesses  when the current CHERI mode is {cheri_int_mode_name}.
On startup <<ddc>> bounds and permissions must be set such that the program can run successfully
(e.g., by setting it to have sufficiently broad bounds and permissions,
possibly a <<root-rw-cap>> capability).

.Unprivileged default data capability register
include::img/ddcreg.edn[]

[#zicsr-section-default]
=== Changes to Zicsr Instructions

When in {cheri_int_mode_name}, there is a special rule for updating extended CSRs (e.g., <<jvt_y>>).
These are CSRs that are XLEN-wide for RVI/RVE but YLEN-wide for {cheri_base_ext_name}.

* Writing an extended CSR writes the address field (XLEN bits) only, and the full CSR is updated using the semantics of the <<SCADDR>> instruction.
* Reading an extended CSR reads the address field (XLEN bits) only.

Accesses to extended CSRs in {cheri_int_mode_name} must access only XLEN bits for compatibility, and so use the semantics of the <<SCADDR>> instruction to determine the final written value.

YLEN-wide CSRs are accessed identically in either <<cheri_execution_mode>>.

.YLEN-bit CSR and Extended CSR access summary for {cheri_default_ext_name}
[#clen_access_summary_default,%autowidth,options=header,align="center"]
|=======================
|                   2+| YLEN-bit CSR^1^           2+| Extended CSR^2^
|Instruction          | Read Width  | Write Width   | Read Width  | Write Width
|CSRRW       rd==x0   |             | YLEN          |             | XLEN
|CSRRW       rd!=x0   |YLEN         | YLEN          |XLEN         | XLEN
|CSRR[C\|S]  rs1==x0  |YLEN         |               |XLEN         |
|CSRR[C\|S]  rs1!=x0  |YLEN         | XLEN          |XLEN         | XLEN
|CSRRWI      rd==x0   |             | XLEN          |             | XLEN
|CSRRWI      rd!=x0   |YLEN         | XLEN          |XLEN         | XLEN
|CSRR[C\|S]I uimm==x0 |YLEN         |               |XLEN         |
|CSRR[C\|S]I uimm!=x0 |YLEN         | XLEN          |XLEN         | XLEN
|=======================

^1^ e.g., <<utidc>>

^2^ e.g., <<jvt_y>>

ifdef::cheri_ratification_v1_only[]
ifndef::cheri_standalone_spec[]
NOTE: `jvt` depends on Zcmt, and the {cheri_base32_ext_name} version of this standard extension is not available yet.

[#jvt_y, reftext=jvt ({cheri_base_ext_name})]
*jvt for {cheri_base32_ext_name}*

endif::[]
endif::[]

include::insns/csrr_32bit.adoc[]
include::insns/csrrw_32bit.adoc[]
