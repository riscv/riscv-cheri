[#section_cheri_hybrid_ext]
== "{cheri_default_ext_name}" Extension for CHERI {cheri_int_mode_name}

ifdef::cheri_standalone_spec[]
WARNING: This chapter will appear in the unpriv spec somewhere after the Zicsr chapter (since it depends on Zicsr).
endif::[]

{cheri_default_ext_name} is an optional extension to the {cheri_base_ext_name} base architectures.
{cheri_default_ext_name} adds the ability to dynamically change the base ISA between using capability pointers for all memory references ({cheri_base_ext_name}) and using integer pointers (RV32I/RV64I).
The ability to choose between these two behaviors (referred to as _CHERI Execution Modes_) ensures CHERI can be fully compatible with the base RISC-V integers ISAs while saving instruction encoding space.

Additionally, {cheri_default_ext_name} adds a new unprivileged CSR: the default data capability, <<ddc>>, that is used to authorize all data memory accesses when treating pointers as integers.

NOTE: Together with <<pcc>>, <<ddc>> allows confining code runs to a compartment (also called a _sandbox_), where all data memory and instruction memory accesses are bounded to fixed memory regions.


The remainder of this section describes these features in detail as well as their integration with the primary base integer variants of the base RISC-V ISA.

IMPORTANT: Implementations that support both {cheri_base_ext_name} and {cheri_default_ext_name} have full binary compatibility with all existing ratified RISC-V base architectures and extensions.

[#cheri_execution_mode,reftext="CHERI Execution Mode"]
=== CHERI Execution Mode

The two execution modes are:

{cheri_int_mode_name}::
Executing with RV32I/RV64I base ISA.
+
All {cheri_base_ext_name} instructions and CSRs are also available in {cheri_default_ext_name}.
+
IMPORTANT: All instructions from existing RISC-V extensions can be run in {cheri_int_mode_name}.
  This execution mode is fully binary compatible with non-CHERI-aware programs.

{cheri_cap_mode_name}::
Executing with the {cheri_base_ext_name} base ISA.
+
Some instructions in the RV32I/RV64I base ISA (and in some other extensions) use capabilities instead of integers for memory references (see xref:section_existing_riscv_insns[xrefstyle=short]). In these cases, such as <<SH1ADD_CHERI>>, the lower XLEN bits of the result is the same in either mode and the upper XLEN bits, and valid tag, are either handled as capabilities in {cheri_cap_mode_name}, or are ignored in the source and written to zero in {cheri_int_mode_name}

The _<<cheri_execution_mode>>_ impacts the instruction set in the following way:

* The authorizing capability used to execute memory access instructions depends on the mode.
In {cheri_int_mode_name}, <<ddc>> is implicitly used. In {cheri_cap_mode_name}, the authorizing  capability is supplied as an explicit *c* operand to the instruction.
// XXX: This only affects the floating-point compressed isns, no need to mention here:
// * The set of instructions that is available for execution. Some instructions are available in {cheri_int_mode_name} but not {cheri_cap_mode_name} and vice-versa (see xref:app_cheri_instructions[xrefstyle=short]).

// NOTE: The _<<cheri_execution_mode>>_ is effectively an extension to some RISC-V instruction encodings.
//   For example, the encoding of an instruction like <<LW>> remains unchanged, but the mode indicates whether the capability authorizing the load is the register operand `cs1` ({cheri_cap_mode_name}).
// The mode is shown in the assembly syntax.

The _<<cheri_execution_mode>>_ is key in providing backwards compatibility with the base RV32I/RV64I ISA.
RISC-V software is able to execute unchanged in implementations supporting both {cheri_base_ext_name} and {cheri_default_ext_name} provided that the privileged environment sets up <<ddc>> and <<pcc>> appropriately.

NOTE: The CHERI execution mode is always {cheri_cap_mode_name} on implementations that support {cheri_base_ext_name}, but not {cheri_default_ext_name}.

NOTE: {cheri_base_ext_name} implementations which support {cheri_default_ext_name} are typically referred to as CHERI Hybrid, whereas implementations which do not support {cheri_default_ext_name} are typically referred to as CHERI purecap.

==== CHERI Execution Mode Effect On Existing Encodings

All RV32I/RV64I instructions are available in both CHERI execution modes.



[#m_bit,reftext="M-bit"]
==== CHERI Execution Mode Encoding

The _<<cheri_execution_mode>>_ is determined by a bit in the metadata of the <<pcc>> called the <<m_bit>>.
{cheri_default_ext_name} adds a new _<<cheri_execution_mode>>_ field (M) to the capability format.
Although always present, it only takes effect in code capabilities, i.e., when the <<x_perm>> is set.
The exact location of the M-bit in the capability format for XLEN=32 and XLEN=64 is described in <<app_cap_description>>.

* Mode (M)={CAP_MODE_VALUE} indicates {cheri_cap_mode_name}.
* Mode (M)={INT_MODE_VALUE} indicates {cheri_int_mode_name}.

IMPORTANT: While the <<m_bit>> only has a effect when installed in <<pcc>>, it needs to be encoded in all capabilities.
  Since indirect jumps copy the full target capability into <<pcc>>, it allows indirect jumps to change between modes (see <<sec_changing_cheri_execution_mode>>).

CAUTION: #ARC-QUESTION: This next paragraph has a reference to a section in the priv spec, does it need to move there or can we keep it here?#

#Tariq: I think we need to remove the forward reference to CRE#

The current _<<cheri_execution_mode>>_ is given by the <<m_bit>> of the <<pcc>> and the <<section_cheri_disable,CHERI register and instruction access settings>> as follows:

* The Mode is {cheri_cap_mode_name} when the <<m_bit>> of the <<pcc>> is {CAP_MODE_VALUE}, *and* <<section_cheri_disable,CHERI register and instruction access is enabled>> for the current privilege.
* Otherwise the Mode is {cheri_int_mode_name}.

// When the <<m_bit>> can be set, the <<sec_permission_transitions,rules>> defined by <<ACPERM>> must be followed.

[#sec_changing_cheri_execution_mode]
==== Changing CHERI Execution Mode
The <<m_bit>> of <<pcc>> can be updated by the instructions listed in <<tab_cheri_mode_sw_summary>>:

.{cheri_default_ext_name} instructions that can perform mode changes
[#tab_cheri_mode_sw_summary,%autowidth,options=header,align="center",cols="2,2,4"]
|=======================
|Mnemonic        | From mode          | Description
| <<JALR_CHERI>> |{cheri_cap_mode_name}| Install `cs1` in the <<pcc>> and so update `pcc.M`
| <<MODESW.INT>> |{cheri_cap_mode_name}| Switch to {cheri_int_mode_name}.
| <<MODESW.CAP>> |{cheri_int_mode_name}| Switch to {cheri_cap_mode_name}.
|=======================

NOTE: The mode can also be updated by setting the <<m_bit>> of a target capability using <<SCMODE>> followed by a <<JALR_CHERI>>.

[#m_bit_observe,reftext="Observing the CHERI Execution Mode"]
==== Observing the CHERI Execution Mode

The effective CHERI execution cannot be determined just by reading the <<m_bit>> from <<pcc>> since it also depends on the values of some <<section_cheri_disable,privileged CSRs>>.
The following code sequence demonstrate how a program can observe the current, effective CHERI execution mode.
It will write {CAP_MODE_VALUE} for {cheri_cap_mode_name} and {INT_MODE_VALUE} for {cheri_int_mode_name} to `x1`:

[source]
----
auipc c1, 0
gctag x1, c1
----

=== Added State

{cheri_default_ext_name} adds the capability CSRs shown in
xref:default-csrnames-added[xrefstyle=short].

[[default-csrnames-added]]
.Unprivileged capability CSRs added in {cheri_default_ext_name}
[%autowidth,float="center",align="center",cols="<,<,<,<",options="header"]
|===
|CLEN CSR|Address|Permissions|Description
|<<ddc>>|0x416|RW|User Default Data Capability
|===

[#ddc,reftext="ddc"]
==== Default Data Capability CSR (ddc)

<<ddc>> is a read-write, user mode accessible capability CSR.
It does not require <<asr_perm>> in <<pcc>> for writes or reads.
Similarly to <<pcc>> authorizing all control flow and instruction fetches, this capability register is implicitly checked to authorize all data memory accesses  when the current CHERI mode is {cheri_int_mode_name}.
On startup <<ddc>> bounds and permissions must be set such that the program can run successfully (e.g., by setting it to <<infinite-cap>> to ensure _all_ data references are in bounds).

.Unprivileged default data capability register
include::img/ddcreg.edn[]

NOTE: <<section_cheri_disable,CHERI register and instruction access>> is not required for the implicit access required by checking memory accesses against <<ddc>>.

NOTE: <<ddc>> is a data pointer, so it does not need to be able to hold all possible invalid addresses (see <<section_invalid_addr_conv>>).

=== {cheri_default_ext_name} Memory Accesses

In {cheri_cap_mode_name} all memory accesses behave as defined by <<rv32y,{cheri_base_ext_name}>> and are authorised by the base register (`cs1`), from which the bounds and permissions are taken. For example:

* `lw t0, 16(ca0)`

In {cheri_int_mode_name} the `lw` has the same behavior and assembly syntax as the RV32I/RV64I:

* `lw t0, 16(a0)`

All memory accesses must still be checked, but now they are authorized by the capability in <<ddc>> instead.

//Load and store instructions change behavior depending on the CHERI execution
//mode although the instruction's encoding remains unchanged.
//
//Loads and stores behave as described in
//xref:section_existing_riscv_insns[xrefstyle=short] when in {cheri_cap_mode_name}.
//In {cheri_int_mode_name}, the instructions behave as described in
//the RISC-V base ISA and rely on *x* operands
//only. The capability authorizing the memory access is <<ddc>> and the memory
//address is given by sign-extending the 12-bit immediate offset and adding it to
//the base address in the *x* register operand.
//
//The exception cases remain as described in
//xref:section_existing_riscv_insns[xrefstyle=short] regardless of the CHERI
//execution mode.

=== {cheri_default_ext_name} Branches and Jumps

The rules from xref:section_existing_riscv_insns[xrefstyle=short] are applied, so that all branch and jump targets are checked against <<pcc>>.

NOTE: In {cheri_int_mode_name} JALR does _not_ copy the target capability register `cs1` into <<pcc>>, instead it updates the address of <<pcc>> with the target value.
The only difference to RV32I/RV64I without {cheri_default_ext_name}, is that the target address is checked against the bounds of <<pcc>>.

[#section_hybrid_ext_instructions]
=== {cheri_default_ext_name} Instructions

{cheri_default_ext_name} introduces new instructions to switch CHERI execution modes.
Additionally, {cheri_default_ext_name} makes all instructions defined by {cheri_default_ext_name} available.

.Instructions summary for {cheri_default_ext_name}
[#tab_hybrid_summary,%autowidth,options=header,align="center",cols="1,4"]
|=======================
|Mnemonic     |Description
|<<SCMODE>>    |Set capability CHERI execution mode (<<m_bit>>)
// The output is written to an unprivileged *c* register, not <<pcc>>.
|<<GCMODE>>    |Get capability CHERI execution mode (<<m_bit>>)
|<<MODESW_CAP>>|Set current CHERI execution mode to {cheri_cap_mode_name}
|<<MODESW_INT>>|Set current CHERI execution mode to {cheri_int_mode_name}
|=======================

include::insns/scmode_32bit.adoc[]

include::insns/gcmode_32bit.adoc[]

include::insns/modesw_32bit.adoc[]

<<<

=== Changes to {cheri_base_ext_name} Instructions

The load and store capability instructions introduced in {cheri_base_ext_name} change behavior depending on the
CHERI execution mode although the instruction's encoding remains unchanged.

==== <<LC>>
When the CHERI execution mode is {cheri_cap_mode_name}; the instruction behaves as described in xref:sec_cap_load_store[xrefstyle=short].
In {cheri_int_mode_name}, the capability authorizing the memory access is <<ddc>>, so the effective address is obtained by adding the *x* register to the sign-extended offset.

==== <<SC>>

When the CHERI execution mode is {cheri_cap_mode_name}; the instruction behaves as described in xref:sec_cap_load_store[xrefstyle=short].
In {cheri_int_mode_name}, the capability authorizing the memory access is <<ddc>>, so the effective address is obtained by adding the *x* register to the sign-extended offset.

[#zicsr-section-default]
=== Changes to Zicsr Instructions

{cheri_base_ext_name} extends all RISC-V CSRs which hold addresses, to hold capabilities.
Therefore, such registers are extended to CLEN bits in {cheri_base_ext_name} and a `c` suffix is added when referring to the entire CSR instead of the only the address field.

WARNING: This assumes that the Zcmt CSR is extended to be a capability when the base architecture is {cheri_base_ext_name}.

For example, the `jvt` CSR is extended to `jvtc`, the `c` suffix indicating that it's a capability.
It is referred to as `jvt` if only accessing the address or `jvtc` if accessing the whole capability.

* In {cheri_cap_mode_name} <<CSRRW_CHERI>> _always_ read/writes the entire CLEN bits of all CLEN-width CSRs, i.e., it accesses `jvtc`.
* In {cheri_int_mode_name} <<CSRRW_CHERI>> _only_ accesses XLEN bits of extended CSRs (e.g., `jvt`, for compatibility) and all CLEN-bits of CSRs added by CHERI extensions (e.g., <<ddc>>).
** <<CSRRW_CHERI>> in {cheri_int_mode_name} can only update the address field of `jvt`, but it can write a full value into <<ddc>>.
** {cheri_cap_mode_name} always accesses `jvtc`, never `jvt`.
* when only writing XLEN bits to an extended CSR (e.g., `jvt`), the CSR value is updated using <<SCADDR>> semantics.

IMPORTANT: need to resolve how to cross-reference the privileged spec to have a list of the new and extended CSRs

//IMPORTANT: For new (rather than extended) capability-width CSRs, <<CSRRW_CHERI>> always reads/writes the full capability width regardless of <<cheri_execution_mode>>.
// See https://github.com/riscv/riscv-cheri/pull/354 for discussion on this.


//All CSR instructions atomically read-modify-write a single CSR.
//If the CSR accessed is of capability size then the capability's tag, metadata and address are all accessed atomically.
//Reading or writing any part of a capability CSR may cause side effects.
//For example, the CSR's tag bit may be cleared if a new address is outside the <<section_cap_representable_check>> of a CSR capability being written.
//
//IMPORTANT: Unless specified otherwise, all CSR instructions cause CHERI exceptions if the <<pcc>> does not grant <<asr_perm>> and the CSR accessed is privileged.
//See <<priv-csrs,the CSR listing in the privileged specification>> for a full list of CSRs that do not require <<asr_perm>>.
//
//When <<CSRRW_CHERI>> is executed on an extended CSR in {cheri_int_mode_name}:
//
//* The register operand is an *x* register.
//* Only XLEN bits from the *x* source are written to the capability address
//field.
//    ** The valid tag and metadata are updated as specified in <<extended_CSR_writing,the privileged specification>>.
//* Only XLEN bits are read from the capability address field, which are extended
//to MXLEN bits according to cite:[riscv-priv-spec] _(Base ISA Control in
//mstatus Register)_ and are then written to the destination *x* register.
//
//When <<CSRRW_CHERI>> is executed on an extended CSR in {cheri_cap_mode_name}, or
//on a new capability CSR regardless of the CHERI execution mode:
//
//* The register operand is a *c* register.
//* The full capability in the *c* register source is written to the CSR.
//** The capability may require modification before the final written value is
//determined (see <<extended_CSR_writing>>).
//* The full capability is written to destination *c* register.

When any CLEN-width CSR is accessed with another CSR instruction:

* <<CSRRWI_CHERI>>
* <<CSRRC_CHERI>>
* <<CSRRCI_CHERI>>
* <<CSRRS_CHERI>>
* <<CSRRSI_CHERI>>

The following rules apply:

* The final address is calculated according to the standard RISC-V CSR rules (set bits, clear bits etc).
* The final address is updated as specified in <<extended_CSR_writing,the privileged specification>> for an XLEN write.
    ** Unless specified otherwise, the update uses <<SCADDR>> semantics
* When accessing an extended CSR:
    ** In {cheri_int_mode_name}, XLEN bits are read from the capability address field and written to an output *x* register.
    ** In {cheri_cap_mode_name}, CLEN bits are read from the CSR and written to an output *c* register.
* When accessing a CSR added by a CHERI extension:
** CLEN bits are read from the CSR and written to an output *c* register.

//NOTE: For all non-capability CSRs (i.e., XLEN-width CSRs) XLEN bits are read/written regardless of <<cheri_execution_mode>>.

ifdef::cheri_v9_annotations[]
NOTE: *CHERI v9 Note:* CSpecialRW is removed. Its role is assumed by <<CSRRW_CHERI>>.
endif::[]

include::insns/csrr_32bit.adoc[]
include::insns/csrrw_32bit.adoc[]
