[#section_cheri_priv_crg_ext]
== "{cheri_priv_crg_ext}" Extension, Version 1.0 for {cheri_base64_ext_name}

This extension specifies use of the {rv64y_pte4_field_name_lc} field from the PTE formats (e.g., see <<sv39pte>>).

{cheri_priv_crg_ext} implies Sv39.

The {cheri_priv_crg_ext} extension is enabled when the `sstatus.{pte_cap_fc_enable}` bit is set.

NOTE: The enable bit is required to redefine the usage of the _pte_._{rv64y_pte4_field_name_lc}_ field.

The extension adds the ability for supervisor-mode software to quickly enable trapping loads of capabilities from all pages of memory, incrementally allow loads of capabilities from such pages, and track stores of capabilities to all pages of memory.
Applied to userspace pages, this has been shown to allow the operating system to implement capability revocation schemes, which allow userspace memory allocators to deterministically guard against use-after-reallocation cite:[cornucopia-reloaded].
Applied to kernel pages, they can similarly be used against use-after-reallocation within the kernel itself.

The 4-bit _pte_._{rv64y_pte4_field_name_lc}_  field is sub-divided into four 1-bit fields, two controlling capability loads (including the capability loaded during an AMO) and two controlling capability stores (again, including the capability stored as part of an AMO).

[[svycrg_rvy_field_breakdown]]
.Breakdown of the 4-bit _pte_._{rv64y_pte4_field_name_lc}_ field.
[%autowidth,float="center",align="center",cols="<,<,<",options="header"]
|===
| Bit                                  | Name                                | Comment
3+| *Capability load/AMO fields*
|_pte_._{rv64y_pte4_field_name_lc}[0]_ | _pte_._{pte_cap_r_name_lc}_         | Capability readable
|_pte_._{rv64y_pte4_field_name_lc}[1]_ | _pte_._{pte_cap_crg_pte_name_lc}_   | Capability read generation
3+| *Capability store/AMO fields*
|_pte_._{rv64y_pte4_field_name_lc}[2]_ | _pte_._{pte_cap_w_name_lc}_         | Capability writable
|_pte_._{rv64y_pte4_field_name_lc}[3]_ | _pte_._{pte_cap_dirty_name_lc}_     | Capability dirty
|===

NOTE: {cheri_priv_crg_ext} is a separate extension and not part of the {cheri_base64_ext_name} Privileged ISA, as a future extension may specify an alternative usage for the _pte_._{rv64y_pte4_field_name_lc}_ field allowing a different mechanism giving improved software efficiency.

When all of the following are true, {cheri_priv_crg_ext} adds two related archiectural features, {cheri_excep_name_pte_ld}s and Capability Dirty Tracking:

. `sstatus.{pte_cap_fc_enable}` is set.
. The authorizing capability has <<c_perm>>.
. The PMA is set to (_CHERI {ctag_title}_).

=== {cheri_excep_name_pte_ld}s

{cheri_priv_crg_ext} defines a new fault type:

* {cheri_excep_name_pte_ld} (cause value {cheri_excep_cause_pte_ld})

In the case of AMOs which could trigger both a {cheri_excep_name_pte_st}, due to storing a valid {ctag}, and also a {cheri_excep_name_pte_ld}, the {cheri_excep_name_pte_st} takes priority as shown in <<exception-priority-cheri>>

_pte_._{pte_cap_r_name_lc}_ is used to enable capability loads or AMOs to write a {ctag} to {cd}.

When _pte_._{pte_cap_r_name_lc}_ is set, _pte_._{pte_cap_crg_pte_name_lc}_ can be used to trap on capability loads or AMOs when it does not match the Capability Read Generation value which is represented by the value of `sstatus.U{pte_cap_crg_pte_name}` for userspace pages (_pte_._u=1_) or `sstatus.S{pte_cap_crg_pte_name}` for kernel pages (_pte_._u=0_).

The implementation raises a {cheri_excep_name_pte_ld} when, in addition to the rules above, all of the following are true:

. A capability load or AMO is executed.
. _pte_._{pte_cap_r_name_lc}_ is set.
. if _pte_._u=1_, _pte_._{pte_cap_crg_pte_name_lc}_ does not equal `sstatus.U{pte_cap_crg_pte_name}`.
. if _pte_._u=0_, _pte_._{pte_cap_crg_pte_name_lc}_ does not equal `sstatus.S{pte_cap_crg_pte_name}`.
. Optionally, the loaded {ctag} is set^1^.
. Any other platform specific rules have not forced the loaded {ctag} to be clear.

[NOTE]
====

^1^Checking the value of the {ctag} requires taking data dependent exceptions on loaded capabilities for loads or AMOs.
Ideally all implementations would trap precisely (taking the {ctag} into account in all cases) rather than conservatively (trapping more often, potentially on every loaded capability).
However, the loaded {ctag} may not be available in all implementations when determining whether to raise the exception, and therefore flexibility is permitted.
As a result, the software is required to be tolerant of raising the trap when the {ctag} is not set, potentially resulting in spurious traps from pages which have _pte_._{pte_cap_r_name_lc}=1_, and so are likely to store valid capabilities.

Implementations which already take synchronous traps on loaded data, such as ECC faults, are recommended to check the loaded {ctag} when determining whether to raise the fault.

====

[[pte_rvy_load_summary]]
.Summary of capability load _pte_._{pte_cap_r_name_lc}_ and _pte_._{pte_cap_crg_pte_name_lc}_ behavior in the PTEs
[%autowidth,float="center",align="center",cols="<,<,<,<",options="header"]
|===
|_pte_._{pte_cap_r_name_lc}_|_pte_._{pte_cap_crg_pte_name_lc}_          | tag^1^| Load Capability Behavior
| 0                         | 0                                         |   X   | Clear loaded {ctag}
| 0                         | 1                                         |   X   | Normal operation
| 1                         | {ne} `sstatus.x{pte_cap_crg_pte_name}`^2^ |   0   | Implementation defined choice of +
{cheri_excep_name_pte_ld} or normal operation
| 1                         | {ne} `sstatus.x{pte_cap_crg_pte_name}`^2^ |   1   | {cheri_excep_name_pte_ld}
| 1                         | = `sstatus.x{pte_cap_crg_pte_name}`^2^    |   X   | Normal operation
|===

^1^ The loaded {ctag}.

^2^ if _pte_._u=1_, `sstatus.U{pte_cap_crg_pte_name}`, else `sstatus.S{pte_cap_crg_pte_name}`.

NOTE: {cheri_excep_name_pte_ld}s may be used to implement the load-barrier primitive from cite:[cornucopia-reloaded].

=== Capability Dirty Tracking

When _pte_._{pte_cap_w_name_lc}_ is clear, capability stores or AMOs where the to-be-stored {ctag} is set will raise a {cheri_excep_name_pte_st} fault.

When _pte_._{pte_cap_w_name_lc}_ is set, capability stores to the virtual page are permitted.
In addition, the _pte_._{pte_cap_dirty_name_lc}_ bit indicates that a capability was stored to the virtual page since the last time the _pte_._{pte_cap_dirty_name_lc}_ bit was cleared.

NOTE: This is akin to the _pte_._d_ bit indicating that a store occurred through this PTE since the last time _pte_._d_ was cleared.

Capability dirty tracking behavior is enabled when, in addition to the rules above, all of the following are true:

. A capability store or AMO instruction is executed.
. The to-be-stored {ctag} is set.
. _pte_._{pte_cap_w_name_lc}_ is set.
. _pte_._{pte_cap_dirty_name_lc}_ is clear.

Two schemes for capability dirty tracking are permitted, and the scheme in use is determined by whether the _Svade_ or _Svadu_ extensions are enabled.

* For _Svade_, take a {cheri_excep_name_pte_st}.
* For _Svadu_, do a hardware update which sets _pte_._{pte_cap_dirty_name_lc}=1_, following the same rules as setting _pte_._d_.
** When setting _pte_._{pte_cap_dirty_name_lc}_, the hardware update also necessarily sets (or leaves set) _pte_._a_ and _pte_._d_.


[[pte_rvy_store_summary]]
.Summary of capability store _pte_._{pte_cap_w_name_lc}_ and _pte_._{pte_cap_dirty_name_lc}_ behavior in the PTEs
[%autowidth,float="center",align="center",cols="<,<,<,<",options="header"]
|===
|_pte_._{pte_cap_w_name_lc}_|_pte_._{pte_cap_dirty_name_lc}_|tag^1^| Store Capability Behavior
| 0        | X      |  0   | Normal operation
| 0        | X      |  1   | {cheri_excep_name_pte_st}
| 1        | 0      |  0   | Normal operation
| 1        | 0      |  1   | {cheri_excep_name_pte_st} (_Svade_) or +
hardware _pte_._{pte_cap_dirty_name_lc}_ update (_Svadu_)
| 1        | 1      |  X   | Normal operation
|===

^1^ The to-be-stored {ctag}.

The capability dirty tracking is resolved during memory translation, but there are cases it is not known if there will be a {ctag} stored to memory or not at this point.
Capability dirty tracking _must_ be triggered when _pte_._{pte_cap_w_name_lc}_=1 and _pte_._{pte_cap_dirty_name_lc}_=0 and the to-be-stored {ctag} is set, and _may_ be triggered in the following case where it is not known if there will be a stored {ctag} during translation:

* SC{LD_ST_DOT_CAP} triggers capability dirty tracking if the {ctag} is set in {cs2}, even if the store fails.

[NOTE]
====

_pte_._{pte_cap_dirty_name_lc}_ must always be set when there is a stored {ctag} to a virtual page so that software knows which pages have had capabilities stored to them.
It may be set too often, which may cause software to examine the page to check for capabilities when none are present.
This is a situation software is required to handle anyway, as it is always possible for all capabilities in a page to be overwritten by non-capability data.
In this case the _pte_._{pte_cap_dirty_name_lc}_ bit will still be set.

Future AMOs fall into this category:

* For future AMOCAS{LD_ST_DOT_CAP}, it is not known whether the store will happen until the load has executed and the compare has been done. Therefore, AMOCAS{LD_ST_DOT_CAP} is likely to trigger capability dirty tracking if the {ctag} is set in {cs2}.
* For future AMOADD{LD_ST_DOT_CAP}, the stored {ctag} depends upon the loaded {ctag} which is not known during translation and also on the execution of the {CADD}.
 Therefore, AMOADD{LD_ST_DOT_CAP}, is likely to always trigger capability dirty tracking.

Checking the stored {ctag} is less of a burden to the implementation than checking the loaded {ctag} for {cheri_excep_name_pte_ld}, which is why checking the loaded {ctag} is optional behavior.
 However, a future extension may reduce the burden further by removing the check on the to-be-stored {ctag}.

====

NOTE: Capability dirty tracking may be used to implement the store-barrier primitive from cite:[cornucopia-reloaded].

NOTE: The minimum level of PTE support is to set _pte_._{pte_cap_r_name_lc}_=1, _pte_._{pte_cap_dirty_name_lc}_=1, _pte_._{pte_cap_w_name_lc}_=1 and _pte_._{pte_cap_crg_pte_name_lc}_=0 in all PTEs intended for storing capabilities (e.g., private anonymous mappings) and set `sstatus.U{pte_cap_crg_pte_name}`=0 and `sstatus.S{pte_cap_crg_pte_name}`=0 on all harts, which will enable capabilities to be loaded and stored successfully.

ifdef::cheri_standalone_spec[]

[#xstatus_pte]
=== U{pte_cap_crg_pte_name} CSR field

The `mstatus`, `sstatus` and `vsstatus` CSRs include the Userspace Capability Read Generation (U{pte_cap_crg_pte_name}) bit, the Supervisor version (S{pte_cap_crg_pte_name}) and the enable bit ({pte_cap_fc_enable}).

[#mstatusreg_pte]
.Machine-mode status (*mstatus*) register for {cheri_base64_ext_name}
[wavedrom, ,svg,subs=attributes+]
....
{reg: [
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SIE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'MIE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SPIE'},
  {bits:  1, name: 'UBE'},
  {bits:  1, name: 'MPIE'},
  {bits:  1, name: 'SPP'},
  {bits:  2, name: 'VS[1:0]'},
  {bits:  2, name: 'MPP[1:0]'},
  {bits:  2, name: 'FS[1:0]'},
  {bits:  2, name: 'XS[1:0]'},
  {bits:  1, name: 'MPRV'},
  {bits:  1, name: 'SUM'},
  {bits:  1, name: 'MXR'},
  {bits:  1, name: 'TVM'},
  {bits:  1, name: 'TW'},
  {bits:  1, name: 'TSR'},
  {bits:  1, name: 'SPELP'},
  {bits:  1, name: 'SDT'},
  {bits:  7, name: 'WPRI'},
  {bits:  2, name: 'UXL[1:0]'},
  {bits:  2, name: 'SXL[1:0]'},
  {bits:  1, name: 'SBE'},
  {bits:  1, name: 'MBE'},
  {bits:  1, name: 'GVA'},
  {bits:  1, name: 'MPV'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'MPELP'},
  {bits:  1, name: 'MDT'},
  {bits: 16, name: 'WPRI'},
  {bits:  1, name: '{pte_cap_fc_enable}'},
  {bits:  1, name: 'S{pte_cap_crg_pte_name}'},
  {bits:  1, name: 'U{pte_cap_crg_pte_name}'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SD'},
], config:{lanes: 4, hspace:1024}}
....

[#sstatusreg_pte]
.Supervisor-mode status (*sstatus*) register when SXLEN=64
[wavedrom, ,svg,subs=attributes+]
....
{reg: [
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SIE'},
  {bits:  3, name: 'WPRI'},
  {bits:  1, name: 'SPIE'},
  {bits:  1, name: 'UBE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SPP'},
  {bits:  2, name: 'VS[1:0]'},
  {bits:  2, name: 'WPRI'},
  {bits:  2, name: 'FS[1:0]'},
  {bits:  2, name: 'XS[1:0]'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SUM'},
  {bits:  1, name: 'MXR'},
  {bits:  3, name: 'WPRI'},
  {bits:  1, name: 'SPELP'},
  {bits:  1, name: 'SDT'},
  {bits:  7, name: 'WPRI'},
  {bits:  2, name: 'UXL[1:0]'},
  {bits: 25, name: 'WPRI'},
  {bits:  1, name: '{pte_cap_fc_enable}'},
  {bits:  1, name: 'S{pte_cap_crg_pte_name}'},
  {bits:  1, name: 'U{pte_cap_crg_pte_name}'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SD'},
], config:{lanes: 4, hspace:1024}}
....

[#vsstatusreg_pte]
.Virtual Supervisor-mode status (*vsstatus*) register when VSXLEN=64
[wavedrom, ,svg,subs=attributes+]
....
{reg: [
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SIE'},
  {bits:  3, name: 'WPRI'},
  {bits:  1, name: 'SPIE'},
  {bits:  1, name: 'UBE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SPP'},
  {bits:  2, name: 'VS[1:0]'},
  {bits:  2, name: 'WPRI'},
  {bits:  2, name: 'FS[1:0]'},
  {bits:  2, name: 'XS[1:0]'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'MXR'},
  {bits:  1, name: 'SUM'},
  {bits: 12, name: 'WPRI'},
  {bits:  2, name: 'UXL[1:0]'},
  {bits: 25, name: 'WPRI'},
  {bits:  1, name: '{pte_cap_fc_enable}'},
  {bits:  1, name: 'S{pte_cap_crg_pte_name}'},
  {bits:  1, name: 'U{pte_cap_crg_pte_name}'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SD'}
], config:{lanes: 4, hspace:1024}}
....

endif::[]
