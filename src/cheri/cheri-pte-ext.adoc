[#section_cheri_priv_crg_ext]
== "{cheri_priv_crg_ext}" Extension, Version 1.0 for {cheri_base64_ext_name}

NOTE: _Sv32_ (for RV32) does not have any spare PTE bits, and so no features from this chapter can be implemented.

The {cheri_priv_crg_ext} extension is enabled when the `sstatus.CRGE` bit is set.

When enabled, the extension adds the ability for supervisor-mode software to quickly front-run loads of capabilities from userspace pages, and to track capabilities stores to pages.
Such facilities have been shown to provide useful primitives for system-level implementation of certain forms of capability revocation which, in turn, allow userspace heap allocator software to deterministically guard against use-after-reallocation cite:[cornucopia-reloaded].

It achieves this by adding by adding the _pte.crg_, _pte.cd_ and `Xstatus.UCRG` bits as described below.
When the extension is disabled the _pte.cd_, _pte.crg_ and `Xstatus.UCRG` bits remain reserved.

NOTE: {cheri_priv_crg_ext} depends on Sv39 and {cheri_base64_ext_name} also being supported.

NOTE: {cheri_priv_crg_ext} is not a mandatory part of the {cheri_base64_ext_name} Privileged ISA, as a future version of this specification may specify an improved method.

NOTE: Hardware-initiated memory accesses from the page-table walker are not checked by a capability.

[#section_extending_pte]
=== Extending the Page Table Entry Format

ifdef::cheri_v9_annotations[]
NOTE: *CHERI v9 Note:* The current proposal is provisional and only includes
support for load-side revocation when compared to CHERI v9.
endif::[]

Two new bits, Capability Read Generation (CRG) and Capability Dirty (CD),
are added to leaf PTEs in Sv39, Sv48 and Sv57 as shown in
xref:sv39pte_crg[xrefstyle=short], xref:sv48pte_crg[xrefstyle=short] and
xref:sv57pte_crg[xrefstyle=short] respectively. For non-leaf PTEs these bits
remain reserved and must be cleared by software for forward compatibility,
or else a page-fault exception is raised. Additionally, if the hypervisor
extension is enabled these bits remain reserved for leaf and non-leaf PTEs
used in guest address translation.

.Sv39 page table entry
[#sv39pte_crg]
include::img/sv39pte_crg.edn[]

.Sv48 page table entry
[#sv48pte_crg]
include::img/sv48pte_crg.edn[]

.Sv57 page table entry
[#sv57pte_crg]
include::img/sv57pte_crg.edn[]

=== Software Primitives

The _pte.crw_ bit (defined by <<section_priv_cheri_vmem>>) indicates whether loading or storing capabilities to
the virtual page is permitted.

When `sstatus.CRGE` is clear, the _pte.cd_ and _pte.crg_ bits are reserved and must not be set in any valid PTEs, and the existing rules from <<section_priv_cheri_vmem>> are followed.

When all of the following are true, {cheri_priv_crg_ext} adds two primitives for use by software:

. `sstatus.CRGE` is set.
. _pte.crw_ is set.
. The authorizing capability has <<c_perm>>.
. The PMA is set to (_CHERI {ctag_title}_).

==== {cheri_excep_name_pte_ld}s


When _pte.crw_ is set, _pte.crg_ can be used to trap on capability loads or AMOs when it does not match the value of `sstatus.UCRG`.

The implementation raises a {cheri_excep_name_pte_ld} when, in addition to the rules above, all of the following are true:

. A capability load or AMO is executed.
. _pte.crg_ does not equal `sstatus.UCRG`.
. _pte.u_ is set.
. Any other platform specific rules have not forced the loaded {ctag} to be clear.

NOTE: An example of a platform specific rule is a hardware engine clearing {ctag}s in memory after a call to free() to offload the CPU, which may have cleared a {ctag} before the CPU loads it.

There is an additional rule if _{cheri_priv_crg_load_tag_ext}_ is implemented:

[start=5]
. The loaded {ctag} is set.

NOTE: Checking the value of the {ctag} requires taking data dependent exceptions on loaded data for loads or AMOs, and also affects the exception priority, see xref:exception-priority[xrefstyle=short].
 Ideally all implementations would trap precisely (taking the {ctag} into account) rather than conservatively (on every capability access).
 However, this information may not be available in all implementations, and therefore both choices are permitted.
 This can be communicated to software by showing presence of the _{cheri_priv_crg_load_tag_ext}_ extension which implies {cheri_priv_crg_ext}.
 Implementations which already take synchronous traps on loaded data, such as ECC faults, should implement _{cheri_priv_crg_load_tag_ext}_.
 Both choices can be handled correctly by the same software, but {cheri_priv_crg_load_tag_ext} is expected to result in fewer spurious traps.

Even if the _{cheri_priv_crg_load_tag_ext}_ extension is implemented, implementations are still allowed to conservatively fault in some situations in which the {ctag} is not set.

[[pte_crw_crg_load_summary]]
.Summary of capability load _pte.crw_ and _pte.crg_ behavior in the PTEs
[%autowidth,float="center",align="center",cols="<,<,<,<,<",options="header"]
|===
|_pte.crw_| _pte.cd_| _pte.crg_              | _pte.u_| Load/AMO
| 0       | 0       | 0                      | X      | Clear loaded tag
| 0       | 0       | 1                      | X      | Reserved
| 0       | 1       | X                      | X      | Reserved
| 1       | X       | {ne} `sstatus.` `UCRG` | 1      | {cheri_excep_name_pte_ld}, or {cheri_excep_name_pte_ld} if {ctag} is set for _{cheri_priv_crg_load_tag_ext}_
| 1       | X       | = `sstatus.` `UCRG`    | 1      | Normal operation
| 1       | X       | X                      | 0      | Normal operation^1^
|===

^1^ A future version of this specification may check an SCRG bit in `sstatus` in this case for trapping on kernel pages.

NOTE: {cheri_excep_name_pte_ld}s may be used to implement the load-barrier primitive from cite:[cornucopia-reloaded].

==== Capability Dirty Tracking


When _pte.crw_ is set, the _pte.cd_ bit indicates that a capability was stored to the
virtual page since the last time the _pte.cd_ bit was cleared.

Capability dirty tracking behavior is enabled when, in addition to the rules above, all of the following are true:

. A capability store or AMO instruction is executed.
. The to-be-stored {ctag} is set.
. _pte.cd_ is clear.

Two schemes for this are permitted, and the scheme in use is determined by whether the _Svade_ or _Svadu_ extensions are enabled.

* For _Svade_, take a {cheri_excep_name_pte_st}.
* For _Svadu_, do a hardware update which sets _pte.cd=1_, following the same rules as setting _pte.d_.
** When setting _pte.cd_, the hardware update also necessarily sets (or leaves set) _pte.a_ and _pte.d_.

[[pte_crw_cd_store_summary]]
.Summary of capability store _pte.crw_ and _pte.cd_ behavior in the PTEs
[%autowidth,float="center",align="center",cols="<,<,<,<",options="header"]
|===
|_pte.crw_|_pte.cd_|_pte.crg_| Store/AMO
| 0       | 0      | 0       | {cheri_excep_name_pte_st} if the to-be-stored {ctag} is set
| 0       | 0      | 1       | Reserved
| 0       | 1      | X       | Reserved
| 1       | 0      | X       | {cheri_excep_name_pte_st} if the to-be-stored {ctag} is set (_Svade_), or hardware _pte.cd_ update (_Svadu_)
| 1       | 1      | X       | Normal operation
|===

NOTE: Because the state of _pte.cd=1_ and _pte.crw=0_ is illegal, it is possible for the update of _pte.cd_ to fail if another thread has cleared _pte.crw_.
ifndef::cheri_standalone_spec[]
 This follows the standard rules in xref:sv32algorithm[xrefstyle=short].
endif::[]

Capability dirty tracking _always_ checks the {ctag} on stored capabilities when determining whether to raise the {cheri_excep_name_pte_st}.

NOTE: Checking the stored {ctag} is less of a burden to the implementation than checking the loaded {ctag} for {cheri_priv_crg_load_tag_ext}, which is why checking the loaded {ctag} is optional behavior.
 However, a future extension may reduce the burden further by removing the check on the stored {ctag}.

NOTE: Capability dirty tracking may be used to implement the store-barrier primitive from cite:[cornucopia-reloaded].

==== Minimum support

The minimum level of PTE support is to set _pte.crw_ and _pte.cd_ to 1 in all PTEs intended for storing
capabilities (e.g., private anonymous mappings) and leave
`sstatus.UCRG` on all harts and _pte.crg_ in all PTEs set to 0, which will allow
capabilities to be loaded and stored successfully.

[#xstatus_pte]
=== UCRG, CRGE CSR fields

The `mstatus`, `sstatus` and `vsstatus` CSRs include the new Userspace Capability Read Generation (UCRG) and Capability Read Generation Enable (CRGE) bits.

[#sstatus_crge_note]
[NOTE]
====

The CRGE bit is necessary because {cheri_priv_crg_ext} defines a different semantic for the _pte.crw=1_, _pte.cd=0_ and _pte.crg=0_ state with respect to <<section_priv_cheri_vmem>>.
In particular, an oblivious software implementation that only sets the _pte.crw_ bit would observe one of the following:

* The _pte.cd_ bit is set by the hardware when a capability is stored and _Svadu_ is enabled.
* A {cheri_excep_name_pte_st} trap when _Svade_ is enabled.

The CRGE bit also has the benefit of maintaining matching polarity of the _pte.cd_ bit with respect to the data Dirty bit (_pte.d_).
If the behavior of the _pte.crw=1_ _pte.cd=0_ state were defined to match the behavior when {cheri_priv_crg_ext} is not implemented, then _pte.cd_ would need to have 0 meaning dirty, which is inconsistent.

The CRGE bit also permits alternative uses of the _pte.cd_ and _pte.crg_ reserved states by future extensions without worrying about compatibility with <<section_priv_cheri_vmem>> (e.g. by an alternative revocation extension which uses more states).

====

ifdef::cheri_standalone_spec[]

[#mstatusreg_pte]
.Machine-mode status (*mstatus*) register for {cheri_base64_ext_name}
[wavedrom, ,svg,subs=attributes+]
....
{reg: [
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SIE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'MIE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SPIE'},
  {bits:  1, name: 'UBE'},
  {bits:  1, name: 'MPIE'},
  {bits:  1, name: 'SPP'},
  {bits:  2, name: 'VS[1:0]'},
  {bits:  2, name: 'MPP[1:0]'},
  {bits:  2, name: 'FS[1:0]'},
  {bits:  2, name: 'XS[1:0]'},
  {bits:  1, name: 'MPRV'},
  {bits:  1, name: 'SUM'},
  {bits:  1, name: 'MXR'},
  {bits:  1, name: 'TVM'},
  {bits:  1, name: 'TW'},
  {bits:  1, name: 'TSR'},
  {bits:  1, name: 'SPELP'},
  {bits:  1, name: 'SDT'},
  {bits:  7, name: 'WPRI'},
  {bits:  2, name: 'UXL[1:0]'},
  {bits:  2, name: 'SXL[1:0]'},
  {bits:  1, name: 'SBE'},
  {bits:  1, name: 'MBE'},
  {bits:  1, name: 'GVA'},
  {bits:  1, name: 'MPV'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'MPELP'},
  {bits:  1, name: 'MDT'},
  {bits: 17, name: 'WPRI'},
  {bits:  1, name: 'CRGE'},
  {bits:  1, name: 'UCRG'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SD'},
], config:{lanes: 4, hspace:1024}}
....

[#sstatusreg_pte]
.Supervisor-mode status (*sstatus*) register when SXLEN=64
[wavedrom, ,svg,subs=attributes+]
....
{reg: [
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SIE'},
  {bits:  3, name: 'WPRI'},
  {bits:  1, name: 'SPIE'},
  {bits:  1, name: 'UBE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SPP'},
  {bits:  2, name: 'VS[1:0]'},
  {bits:  2, name: 'WPRI'},
  {bits:  2, name: 'FS[1:0]'},
  {bits:  2, name: 'XS[1:0]'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SUM'},
  {bits:  1, name: 'MXR'},
  {bits:  3, name: 'WPRI'},
  {bits:  1, name: 'SPELP'},
  {bits:  1, name: 'SDT'},
  {bits:  7, name: 'WPRI'},
  {bits:  2, name: 'UXL[1:0]'},
  {bits: 26, name: 'WPRI'},
  {bits:  1, name: 'CRGE'},
  {bits:  1, name: 'UCRG'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SD'},
], config:{lanes: 4, hspace:1024}}
....

[#vsstatusreg_pte]
.Virtual Supervisor-mode status (*vsstatus*) register when VSXLEN=64
[wavedrom, ,svg,subs=attributes+]
....
{reg: [
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SIE'},
  {bits:  3, name: 'WPRI'},
  {bits:  1, name: 'SPIE'},
  {bits:  1, name: 'UBE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SPP'},
  {bits:  2, name: 'VS[1:0]'},
  {bits:  2, name: 'WPRI'},
  {bits:  2, name: 'FS[1:0]'},
  {bits:  2, name: 'XS[1:0]'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'MXR'},
  {bits:  1, name: 'SUM'},
  {bits: 12, name: 'WPRI'},
  {bits:  2, name: 'UXL[1:0]'},
  {bits: 26, name: 'WPRI'},
  {bits:  1, name: 'CRGE'},
  {bits:  1, name: 'UCRG'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SD'}
], config:{lanes: 4, hspace:1024}}
....

endif::[]
