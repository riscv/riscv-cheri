[#section_cheri_priv_crg_ext]
== "{cheri_priv_crg_ext}" Extension, Version 1.0 for {cheri_base64_ext_name}

ifdef::cheri_standalone_spec[]
WARNING: This chapter will appear in the priv spec. Exact location TBD.
endif::[]

NOTE: _Sv32_ (for RV32) does not have any spare PTE bits, and so no features from this chapter can be implemented.


The {cheri_priv_crg_ext} extension is enabled when the <<sstatusreg_pte,sstatus>>.CRGE bit is set.
When enabled, the extension adds the ability to perform capability revocation of userspace pages (see <<cap_revocation>>) by adding the PTE.CRG, PTE.CD and <<sstatusreg_pte,sstatus>>.UCRG bits as described below.
When the extension is disabled the PTE.CD, PTE.CRG and <<sstatusreg_pte,sstatus>>.UCRG bits remain reserved.

NOTE: A future extension may define an alternative function for these reserved states; the PTE.CRW bit is interpreted as defined by <<section_priv_cheri_vmem>>.

NOTE: {cheri_priv_crg_ext} depends on Supervisor-Level ISA and {cheri_base64_ext_name} also being supported.

NOTE: {cheri_priv_crg_ext} is strongly recommended but not mandatory as a future version of this specification may specify an improved method.

NOTE: A future version of this specification may include kernel revocation which may require an <<sstatusreg_pte,sstatus>>.SCRG bit.

The minimum level of PTE support is to set PTE.CRW and PTE.CD to 1 in all PTEs intended for storing
capabilities (i.e., private anonymous mappings) and leave
<<sstatusreg_pte,sstatus>>.UCRG and PTE.CRG in all PTEs set to 0, which will allow
capabilities with their {ctag}s set to be loaded and stored successfully.

NOTE: When {cheri_priv_crg_ext} is enabled (<<sstatusreg_pte,sstatus>>.CRGE is set), the semantics of PTE.CRW bit are redefined relative to the definition in <<section_priv_cheri_vmem>>.
The ability to load and store capabilities in the page depends on all of the PTE.CRW, PTE.CD, PTE.CRG bits, which effectively become a single 3-bit field controlling the behavior.
Therefore, when PTE.CRW is clear, it is not required that future extensions to {cheri_priv_crg_ext}, such as for kernel revocation, cannot store capabilities to a page.

NOTE: Hardware-initiated memory accesses from the page-table walker are not checked by a capability.

[#cap_revocation]
=== Capability Revocation

Revocation is the process of clearing the {ctag} of capabilities that point to freed memory, to prevent them from being dereferenced and thereby enforcing _temporal memory safety_.
cite:[cornucopia-reloaded] details algorithms for preventing use-after-free in virtual memory, and non-virtual memory based systems.

{cheri_priv_crg_ext} adds capability revocation for userspace pages only.

It uses the <<sstatusreg_pte,sstatus>>.UCRG and PTE.CRG bits to control the revocation epoch, which is used to provide a _load-side barrier_ to detect when loading from a page which needs sweeping (i.e. may contain dangling capabilities which point to freed memory).
This state is indicated by the generation in PTE.CRG mismatching the global one in <<sstatusreg_pte,sstatus>>.UCRG.

It also uses the PTE.CD (capability dirty) bit to provide a _store-side barrier_ to detect when stored capabilities are to a clean page, and so need to be swept in case they are dangling.

[#section_extending_pte]
=== Extending the Page Table Entry Format

ifdef::cheri_v9_annotations[]
NOTE: *CHERI v9 Note:* The current proposal is provisional and only includes
support for load-side revocation when compared to CHERI v9.
endif::[]

Two new bits, Capability Read Generation (CRG) and Capability Dirty (CD),
are added to leaf PTEs in Sv39, Sv48 and Sv57 as shown in
xref:sv39pte_crg[xrefstyle=short], xref:sv48pte_crg[xrefstyle=short] and
xref:sv57pte_crg[xrefstyle=short] respectively. For non-leaf PTEs these bits
remain reserved and must be cleared by software for forward compatibility,
or else a page-fault exception is raised. Additionally, if the hypervisor
extension is enabled these bits remain reserved for leaf and non-leaf PTEs
used in guest address translation.

.Sv39 page table entry
[#sv39pte_crg]
include::img/sv39pte_crg.edn[]

.Sv48 page table entry
[#sv48pte_crg]
include::img/sv48pte_crg.edn[]

.Sv57 page table entry
[#sv57pte_crg]
include::img/sv57pte_crg.edn[]

NOTE: The behavior in this section isn't relevant if:

. A capability load or AMO cannot set the {ctag} in the target register.
. A capability store or AMO cannot store a set {ctag} to the target memory.

These can be due to:

* missing <<c_perm>> on the authorizing capability, or
* the PTE.CRW bit being 0 (see <<section_priv_cheri_vmem>>) for loaded capabilities, or
* the PMA (_CHERI {ctag_title} Strip_), or
* other extensions which clear the tag, or
* other platform specific rules about clearing {ctag}s.

When PTE.CRW, PTE.CD, and PTE.CRG are _all_ clear, the implementation is required to clear
loaded tags and raise {cheri_excep_name_pte_st} when the stored {ctag} is set.

NOTE: Other PTE.CD and PTE.CRG combinations when PTE.CRW=0 are reserved for future extensions.
The reserved PTE states behave as the PTE.CRW=0, PTE.CD=0, PTE.CRG=0, unless a future extension
defines an alternative function.

=== Load-side barrier

The _load-side barrier_ allows the software to detect when a userspace virtual memory page need to be swept for dangling capabilities.
This is achieved by taking a trap on capability loads allowing the exception handler to sweep the page _before_ the application can load the capability.

To achieve this, when the PTE.CRW bit is set, the behavior of loaded capabilities is controlled by the PTE.CRG bit.

The implementation raises a {cheri_excep_name_pte_ld} when a capability is loaded and:

* PTE.CRW=1, and
* PTE.CRG != <<sstatusreg_pte,sstatus>>.UCRG, and
* PTE.U=1, and
* The loaded {ctag} is set^1^

^1^ Implementations are allowed to avoid checking the {ctag} under specific conditions.
 A valid implementation is _never_ to check the loaded {ctag} value.
 The choice about whether the {ctag} is _ever_ checked affects the exception priority, see <<exception-priority-cheri>>.

NOTE: Implementations which already take synchronous traps on loaded data, such as ECC faults, should implement checking the loaded {ctag}.

[[pte_crw_crg_load_summary]]
.Summary of Load PTE.CRW and PTE.CRG behavior
[%autowidth,float="center",align="center",cols="<,<,<,<,<",options="header"]
|===
|PTE. CRW| PTE. CD| PTE.CRG                               | PTE.U | Load/AMO
| 0      | 0      | 0                                     | X     | Clear loaded {ctag}
| 0      | 0      | 1                                     | X     | Reserved
| 0      | 1      | X                                     | X     | Reserved
| 1      | X      | {ne} <<sstatusreg_pte,sstatus>>. UCRG | 1     | {cheri_excep_name_pte_ld} if {ctag} is set in {cd}
| 1      | X      | = <<sstatusreg_pte,sstatus>>. UCRG    | 1     | Normal operation
| 1      | X      | X                                     | 0     | Normal operation^1^
|===

^1^ A future version of this specification may check an SCRG bit in <<sstatusreg_pte,sstatus>> for kernel revocation.

=== Store-side barrier

The _store-side barrier_ is to track capability stores, which may require a userspace page to be scanned for dangling capabilities.

When PTE.CRW is set, the PTE.CD bit is intended to indicate that a capability was stored to the virtual page since the last time the PTE.CD bit was cleared.
When a capability is stored, the {ctag} bit of the to-be-stored capability is set and the PTE.CD bit is clear, two schemes are permitted (also see <<section_hardware_pte_updates>>):

* The same behavior as when PTE.CRW is clear, allowing software interpretation of this state.
* The implementation automatically sets the PTE.CD bit.
 The PTE update behaves in the same way as the D bit update described by the _Svadu_ extension.

[[pte_crw_cd_store_summary]]
.Summary of Store PTE.CRW and PTE.CD behavior
[%autowidth,float="center",align="center",cols="<,<,<,<",options="header"]
|===
|PTE.CRW | PTE.CD | PTE.CRG | Store/AMO
| 0      | 0      | 0       | {cheri_excep_name_pte_st} if stored {ctag} is set
| 0      | 0      | 0       | Normal operation
| 0      | 0      | 1       | Reserved
| 0      | 1      | X       | Reserved
| 1      | 0      | X       | {cheri_excep_name_pte_st} if stored {ctag} is set, or <<section_hardware_pte_updates, hardware PTE.CD update>>
| 1      | 1      | X       | Normal operation
|===

[#section_hardware_pte_updates]
=== Enabling Software or Hardware PTE updates

The decision about whether to take exceptions on capability stores with the {ctag} set to a page with PTE.CRW=1 and PTE.CD=0 is determined by whether the _Svade_ and _Svadu_ extensions are enabled.
These cause PTE Accessed and Dirty updates to be done in software, via the exception handler, or by a hardware mechanism respectively.

* If only _Svade_ is implemented, or enabled through henvcfg.ADUE or menvcfg.ADUE, then take a {cheri_excep_name_pte_st}.
* If only _Svadu_ is implemented, or enabled through henvcfg.ADUE or menvcfg.ADUE, then do the hardware update of setting PTE.CD=1 as described in <<section_extending_pte>>.

[#xstatus_pte]
=== Extending the Supervisor (sstatus) and Virtual Supervisor (vsstatus) Status Registers

The <<sstatusreg_pte,sstatus>> and <<vsstatusreg_pte,vsstatus>> CSRs are extended to include the new Capability Read Generation (CRG) and Capability Read Generation Enable (CRGE) bits as shown.

When V=1 <<vsstatusreg_pte,vsstatus>>.UCRG and CRGE are in effect.

<<mstatusreg_pte,mstatus>>.UCRG and CRGE also exist. Reading or writing it is equivalent to reading or writing <<sstatusreg_pte,sstatus>>.UCRG and CRGE respectively.

NOTE: The CRGE bit is added to the <<mstatusreg_pte,mstatus>>, <<vsstatusreg_pte,vsstatus>> and <<sstatusreg_pte,sstatus>> registers in order to allow the S-mode software to explicitly opt in to the revocation extensions.

[NOTE]
====

The CRGE bit is necessary because the {cheri_priv_crg_ext} defines a different semantic for PTE.CRW=1 PTE.CD=0 PTE.CRG=0 with respect to <<section_priv_cheri_vmem>>.
In particular, an oblivious software implementation that only sets the PTE.CRW bit would observe one of the following:

* The PTE.CD bit is set by the hardware when a capability is stored and _Svadu_ is enabled.
* A {cheri_excep_name_pte_st} trap when _Svade_ is enabled.

Both these conditions are unexpected according to <<section_priv_cheri_vmem>>.
The CRGE bit also has the benefit of maintaining matching polarity of the PTE.CD bit with respect to the data Dirty bit (PTE.D), and permits alternative uses by future extensions of the PTE.CD and PTE.CRG reserved bits (e.g. by an alternative revocation extension that re-defines the semantics of PTE.CD and PTE.CRG).
====

[#mstatusreg_pte]
.Machine-mode status (*mstatus*) register for {cheri_base64_ext_name}
[wavedrom, ,svg,subs=attributes+]
....
{reg: [
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SIE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'MIE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SPIE'},
  {bits:  1, name: 'UBE'},
  {bits:  1, name: 'MPIE'},
  {bits:  1, name: 'SPP'},
  {bits:  2, name: 'VS[1:0]'},
  {bits:  2, name: 'MPP[1:0]'},
  {bits:  2, name: 'FS[1:0]'},
  {bits:  2, name: 'XS[1:0]'},
  {bits:  1, name: 'MPRV'},
  {bits:  1, name: 'SUM'},
  {bits:  1, name: 'MXR'},
  {bits:  1, name: 'TVM'},
  {bits:  1, name: 'TW'},
  {bits:  1, name: 'TSR'},
  {bits:  1, name: 'SPELP'},
  {bits:  1, name: 'SDT'},
  {bits:  7, name: 'WPRI'},
  {bits:  2, name: 'UXL[1:0]'},
  {bits:  2, name: 'SXL[1:0]'},
  {bits:  1, name: 'SBE'},
  {bits:  1, name: 'MBE'},
  {bits:  1, name: 'GVA'},
  {bits:  1, name: 'MPV'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'MPELP'},
  {bits:  1, name: 'MDT'},
  {bits: 17, name: 'WPRI'},
  {bits:  1, name: 'CRGE'},
  {bits:  1, name: 'UCRG'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SD'},
], config:{lanes: 4, hspace:1024}}
....

[#sstatusreg_pte]
.Supervisor-mode status (*sstatus*) register when SXLEN=64
[wavedrom, ,svg,subs=attributes+]
....
{reg: [
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SIE'},
  {bits:  3, name: 'WPRI'},
  {bits:  1, name: 'SPIE'},
  {bits:  1, name: 'UBE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SPP'},
  {bits:  2, name: 'VS[1:0]'},
  {bits:  2, name: 'WPRI'},
  {bits:  2, name: 'FS[1:0]'},
  {bits:  2, name: 'XS[1:0]'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SUM'},
  {bits:  1, name: 'MXR'},
  {bits:  3, name: 'WPRI'},
  {bits:  1, name: 'SPELP'},
  {bits:  1, name: 'SDT'},
  {bits:  7, name: 'WPRI'},
  {bits:  2, name: 'UXL[1:0]'},
  {bits: 26, name: 'WPRI'},
  {bits:  1, name: 'CRGE'},
  {bits:  1, name: 'UCRG'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SD'},
], config:{lanes: 4, hspace:1024}}
....

[#vsstatusreg_pte]
.Virtual Supervisor-mode status (*vsstatus*) register when VSXLEN=64
[wavedrom, ,svg,subs=attributes+]
....
{reg: [
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SIE'},
  {bits:  3, name: 'WPRI'},
  {bits:  1, name: 'SPIE'},
  {bits:  1, name: 'UBE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SPP'},
  {bits:  2, name: 'VS[1:0]'},
  {bits:  2, name: 'WPRI'},
  {bits:  2, name: 'FS[1:0]'},
  {bits:  2, name: 'XS[1:0]'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'MXR'},
  {bits:  1, name: 'SUM'},
  {bits: 12, name: 'WPRI'},
  {bits:  2, name: 'UXL[1:0]'},
  {bits: 26, name: 'WPRI'},
  {bits:  1, name: 'CRGE'},
  {bits:  1, name: 'UCRG'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SD'}
], config:{lanes: 4, hspace:1024}}
....
