[#section_cheri_priv_crg_ext]
== "{cheri_priv_crg_ext}" Extension, Version 1.0 for {cheri_base64_ext_name}

ifdef::cheri_standalone_spec[]
WARNING: This chapter will appear in the priv spec. Exact location TBD.
endif::[]

NOTE: _Sv32_ (for RV32) does not have any spare PTE bits, and so no features from this chapter can be implemented.


#Begin new since last ARC review (added enable/disable bit)#
The {cheri_priv_crg_ext} extension is enabled when the <<sstatusreg_pte,sstatus>>.CRGE bit is set.
#End new since last ARC review#
When enabled, the extension adds the ability to perform capability revocation of user mode pages (see <<cap_revocation>>) by adding the PTE.CRG, PTE.CD and <<sstatusreg_pte,sstatus>>.UCRG bits as described below.
When the extension is disabled the PTE.CD, PTE.CRG and <<sstatusreg_pte,sstatus>>.UCRG bits remain reserved and a future extension may define an alternative function; the PTE.CRW bit is interpreted as defined by <<section_priv_cheri_vmem>>.

NOTE: {cheri_priv_crg_ext} depends on Supervisor-Level ISA and {cheri_base64_ext_name} also being supported.

NOTE: {cheri_priv_crg_ext} is strongly recommended but not mandatory as a future version of this specification may specify an improved method.

NOTE: A future version of this specification may include kernel revocation which may require an <<sstatusreg_pte,sstatus>>.SCRG bit.

The minimum level of PTE support is to set CRW and CD to 1 in all PTEs intended for storing
capabilities (i.e., private anonymous mappings) and leave
<<sstatusreg_pte,sstatus>>.UCRG and CRG in all PTEs set to 0, which will allow
capabilities with their {ctag}s set to be loaded and stored successfully.

NOTE: When {cheri_priv_crg_ext} is enabled (<<sstatusreg_pte,sstatus>>.CRGE is set), the semantics of PTE.CRW bit are redefined relative to the definition in <<section_priv_cheri_vmem>>.
The ability to load and store capabilities in the page depends on all of the PTE.CRW, PTE.CD, PTE.CRG bits, which effectively become a single 3-bit field controlling the behavior.
Therefore, when PTE.CRW is clear, it is not required that future extensions to {cheri_priv_crg_ext}, such as for kernel revocation, cannot store capabilities to a page.

NOTE: Hardware-initiated memory accesses from the page-table walker are not checked by a capability.

[#cap_revocation]
=== Capability Revocation

cite:[cornucopia-reloaded] details algorithms for preventing use-after-free in virtual memory, and non-virtual memory based systems.
Revocation is the process of clearing the {ctag} of capabilities which point to freed memory, to prevent them from being dereferenced.
A CHERI system which implements such a scheme is said to support _temporal safety_.

{cheri_priv_crg_ext} adds temporal safety for user pages only.
It uses the <<sstatusreg_pte,sstatus>>.UCRG and PTE.CRG bits to control the revocation epoch, which is used to provide a load barrier to detect when loading from a page which needs sweeping.
This is indicated by the generation in the PTE mismatching the global one in <<sstatusreg_pte,sstatus>>.UCRG.
Stored {ctag}s to clean pages are tracked using PTE.CD to record which virtual memory pages contain dirty capabilities, and so will need to be swept.

[#section_extending_pte]
=== Extending the Page Table Entry Format

ifdef::cheri_v9_annotations[]
NOTE: *CHERI v9 Note:* The current proposal is provisional and only includes
support for load-side revocation when compared to CHERI v9.
endif::[]

Two new bits, Capability Read Generation (CRG) and Capability Dirty (CD),
are added to leaf PTEs in Sv39, Sv48 and Sv57 as shown in
xref:sv39pte_crg[xrefstyle=short], xref:sv48pte_crg[xrefstyle=short] and
xref:sv57pte_crg[xrefstyle=short] respectively. For non-leaf PTEs these bits
remain reserved and must be cleared by software for forward compatibility,
or else a page-fault exception is raised. Additionally, if the hypervisor
extension is enabled these bits remain reserved for leaf and non-leaf PTEs
used in guest address translation.

.Sv39 page table entry
[#sv39pte_crg]
include::img/sv39pte_crg.edn[]

.Sv48 page table entry
[#sv48pte_crg]
include::img/sv48pte_crg.edn[]

.Sv57 page table entry
[#sv57pte_crg]
include::img/sv57pte_crg.edn[]

NOTE: The behavior in this section isn't relevant if:

. The authorizing capability doesn't have <<c_perm>>, for loads, stores and AMO.
. Any extension-specific mediation has already cleared the stored tag, for stores and AMOs.

The CRW bit (defined by {cheri_priv_vmem_ext}) indicates whether reading or writing capabilities with the {ctag} set to
the virtual page is permitted. When the CRW bit is set, capabilities are written
as usual, and capability reads are controlled by the CRG bit.

NOTE: The {ctag} bit of the stored capability is checked _after_ it is potentially
cleared due to lack of <<c_perm>>.


If all the CRW, CD and CRG bits are clear, the "no capability state", then the existing rules from <<section_priv_cheri_vmem>> are followed:

* When a capability load or AMO instruction is executed, the {ctag} bit of the
  loaded capability is cleared before it is written to the destination register.
* When a capability store or AMO instruction is executed and the {ctag} bit
 of the capability being written is set, the implementation raises a
 {cheri_excep_name_pte_st}.

When the CRW bit is set, the "capability state", then the behavior of
capability loads is controlled by CRG and the behavior of capability stores
is controlled by CD.

When CRW is set, the CRG bit indicates the current generation of the virtual
memory page with regards to the ongoing capability revocation cycle.
The implementation raises {cheri_excep_name_pte_ld} when a capability load
or AMO instruction is executed and:

* the authorizing capability grants <<c_perm>>,
* the virtual page's CRG bit does not equal <<sstatusreg_pte,sstatus>>.UCRG, and
* the virtual page's PTE.U is set.

When the _{cheri_priv_crg_load_tag_ext}_ extension is implemented, the
{cheri_excep_name_pte_ld} is raised when a capability load or AMO instruction
satisfies the conditions above and the capability read from memory
has its {ctag} set.

{cheri_priv_crg_load_tag_ext} implies {cheri_priv_crg_ext}.


When CRW is set, the CD bit indicates that a capability was stored to the
virtual page since the last time the CD bit was cleared.
When a capability store or AMO instruction is executed, the {ctag} bit
of the capability being written is set and the CD bit is clear,
two schemes are permitted (also see <<section_hardware_pte_updates>>):

* The same behavior as when CRW is clear, allowing software interpretation
 of this state.
* The implementation sets the CD bit. The PTE update behaves in the same way as
 the D bit update described by the _Svadu_ extension.

When CRW, CD, and CRG are all clear, the implementation is required to clear
loaded tags and raise {cheri_excep_name_pte_st} when the stored {ctag} is set.

NOTE: Other CD and CRG combinations when CRW=0 are reserved for future extensions.
The reserved PTE states behave as the CRW=0, CD=0, CRG=0, unless a future extension
defines an alternative function.

[[pte_crw_crg_load_summary]]
.Summary of Load CRW and CRG behavior in the PTEs
[%autowidth,float="center",align="center",cols="<,<,<,<,<",options="header"]
|===
|PTE.CRW | PTE.CD | PTE.CRG                                 | PTE.U | Load/AMO
| 0      | 0      | 0                                       | X     | Clear loaded tag
| 0      | 0      | 1                                       | X     | Reserved
| 0      | 1      | X                                       | X     | Reserved
| 1      | X      | &#8800; <<sstatusreg_pte,sstatus>>.UCRG | 1     | {cheri_excep_name_pte_ld}, or {cheri_excep_name_pte_ld} if tag is set for _{cheri_priv_crg_load_tag_ext}_^1^
| 1      | X      | = <<sstatusreg_pte,sstatus>>.UCRG       | 1     | Normal operation
| 1      | X      | X                                       | 0     | Normal operation^2^
|===

^1^ The choice here is whether to take data dependent exceptions on load data
 for loads or atomic operations. The default is to take the trap without
 checking the value of the loaded {ctag}. Taking a trap when the {ctag} is not
 set will introduce additional traps during revocation sweeps.
 If _{cheri_priv_crg_load_tag_ext}_ is implemented then the trap is only taken
 if the loaded {ctag} is set, to reduce software overhead from revocation sweeps.
 Checking the loaded tag affects the exception priority, see <<exception-priority>>.

NOTE: _{cheri_priv_crg_load_tag_ext}_ is an optimization for software, and as
such implementations are allowed to conservatively fault under certain
conditions even if the {ctag} is not set.

NOTE: Implementations which already take synchronous traps on loaded data, such as ECC faults, should implement _{cheri_priv_crg_load_tag_ext}_ instead of {cheri_priv_crg_ext}.

_{cheri_priv_crg_load_tag_ext}_ implies _{cheri_priv_crg_ext}_.

^2^ A future version of this specification may check an SCRG bit in <<sstatusreg_pte,sstatus>> for kernel revocation.

[[pte_crw_cd_store_summary]]
.Summary of Store CRW and CD behavior in the PTEs
[%autowidth,float="center",align="center",cols="<,<,<,<",options="header"]
|===
|PTE.CRW | PTE.CD | PTE.CRG | Store/AMO
| 0      | 0      | 0       | {cheri_excep_name_pte_st} if stored tag is set
| 0      | 0      | 1       | Reserved
| 0      | 1      | X       | Reserved
| 1      | 0      | X       | {cheri_excep_name_pte_st} if stored tag is set, or <<section_hardware_pte_updates, hardware CD update>>
| 1      | 1      | X       | Normal operation
|===

[#section_hardware_pte_updates]
=== Enabling Software or Hardware PTE updates

The decision about whether to take exceptions on capability stores with the {ctag} set to a page with PTE.CRW=1 and PTE.CD=0 is determined by whether the _Svade_ and _Svadu_ extensions are enabled.
These cause PTE Accessed and Dirty updates to be done in software, via the exception handler, or by a hardware mechanism respectively.

* If only _Svade_ is implemented, or enabled through henvcfg.ADUE or menvcfg.ADUE, then take a {cheri_excep_name_pte_st}.
* If only _Svadu_ is implemented, or enabled through henvcfg.ADUE or menvcfg.ADUE, then do the hardware update of setting PTE.CD=1 as described in <<section_extending_pte>>.

[#xstatus_pte]
=== Extending the Supervisor (sstatus) and Virtual Supervisor (vsstatus) Status Registers

#Begin new since last ARC review (added enable/disable bit)#
The <<sstatusreg_pte,sstatus>> and <<vsstatusreg_pte,vsstatus>> CSRs are extended to include the new Capability Read Generation (CRG) and Capability Read Generation Enable (CRGE) bits as shown.

When V=1 <<vsstatusreg_pte,vsstatus>>.UCRG and CRGE are in effect.

<<mstatusreg_pte,mstatus>>.UCRG and CRGE also exist. Reading or writing it is equivalent to reading or writing <<sstatusreg_pte,sstatus>>.UCRG and CRGE respectively.

NOTE: The CRGE bit is added to the <<mstatusreg_pte,mstatus>>, <<vsstatusreg_pte,vsstatus>> and <<sstatusreg_pte,sstatus>> registers in order to allow the S-mode software to explicitly opt in to the revocation extensions.

NOTE: The CRGE bit is necessary because the {cheri_priv_crg_ext} defines a different semantic for PTE.CRW=1 PTE.CD=0 PTE.CRG=0 with respect to <<section_priv_cheri_vmem>>.
In particular, an oblivious software implementation that only sets the PTE.CRW bit would observe one of the following:
* The PTE.CD bit is set by the hardware when a capability is stored and _Svadu_ is enabled.
* A {cheri_excep_name_pte_st} trap when _Svade_ is enabled.
Both these conditions are unexpected according to <<section_priv_cheri_vmem>>.
The CRGE bit also has the benefit of maintaining matching polarity of the PTE.CD bit with respect to the data Dirty bit (PTE.D), and permits alternative uses by future extensions of the PTE.CD and PTE.CRG reserved bits (e.g. by an alternative revocation extension that re-defines the semantics of CD and CRG).
#End new since last ARC review#


[#mstatusreg_pte]
.Machine-mode status (*mstatus*) register for {cheri_base64_ext_name}
[wavedrom, ,svg,subs=attributes+]
....
{reg: [
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SIE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'MIE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SPIE'},
  {bits:  1, name: 'UBE'},
  {bits:  1, name: 'MPIE'},
  {bits:  1, name: 'SPP'},
  {bits:  2, name: 'VS[1:0]'},
  {bits:  2, name: 'MPP[1:0]'},
  {bits:  2, name: 'FS[1:0]'},
  {bits:  2, name: 'XS[1:0]'},
  {bits:  1, name: 'MPRV'},
  {bits:  1, name: 'SUM'},
  {bits:  1, name: 'MXR'},
  {bits:  1, name: 'TVM'},
  {bits:  1, name: 'TW'},
  {bits:  1, name: 'TSR'},
  {bits:  1, name: 'SPELP'},
  {bits:  1, name: 'SDT'},
  {bits:  7, name: 'WPRI'},
  {bits:  2, name: 'UXL[1:0]'},
  {bits:  2, name: 'SXL[1:0]'},
  {bits:  1, name: 'SBE'},
  {bits:  1, name: 'MBE'},
  {bits:  1, name: 'GVA'},
  {bits:  1, name: 'MPV'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'MPELP'},
  {bits:  1, name: 'MDT'},
  {bits: 17, name: 'WPRI'},
  {bits:  1, name: 'CRGE'},
  {bits:  1, name: 'UCRG'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SD'},
], config:{lanes: 4, hspace:1024}}
....

[#sstatusreg_pte]
.Supervisor-mode status (*sstatus*) register when SXLEN=64
[wavedrom, ,svg,subs=attributes+]
....
{reg: [
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SIE'},
  {bits:  3, name: 'WPRI'},
  {bits:  1, name: 'SPIE'},
  {bits:  1, name: 'UBE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SPP'},
  {bits:  2, name: 'VS[1:0]'},
  {bits:  2, name: 'WPRI'},
  {bits:  2, name: 'FS[1:0]'},
  {bits:  2, name: 'XS[1:0]'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SUM'},
  {bits:  1, name: 'MXR'},
  {bits:  3, name: 'WPRI'},
  {bits:  1, name: 'SPELP'},
  {bits:  1, name: 'SDT'},
  {bits:  7, name: 'WPRI'},
  {bits:  2, name: 'UXL[1:0]'},
  {bits: 26, name: 'WPRI'},
  {bits:  1, name: 'CRGE'},
  {bits:  1, name: 'UCRG'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SD'},
], config:{lanes: 4, hspace:1024}}
....

[#vsstatusreg_pte]
.Virtual Supervisor-mode status (*vsstatus*) register when VSXLEN=64
[wavedrom, ,svg,subs=attributes+]
....
{reg: [
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SIE'},
  {bits:  3, name: 'WPRI'},
  {bits:  1, name: 'SPIE'},
  {bits:  1, name: 'UBE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SPP'},
  {bits:  2, name: 'VS[1:0]'},
  {bits:  2, name: 'WPRI'},
  {bits:  2, name: 'FS[1:0]'},
  {bits:  2, name: 'XS[1:0]'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'MXR'},
  {bits:  1, name: 'SUM'},
  {bits: 12, name: 'WPRI'},
  {bits:  2, name: 'UXL[1:0]'},
  {bits: 26, name: 'WPRI'},
  {bits:  1, name: 'CRGE'},
  {bits:  1, name: 'UCRG'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SD'}
], config:{lanes: 4, hspace:1024}}
....
