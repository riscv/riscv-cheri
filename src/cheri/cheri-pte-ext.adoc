[#section_cheri_priv_crg_ext]
== "{cheri_priv_crg_ext}" Extension, Version 1.0 for {cheri_base64_ext_name}

NOTE: _Sv32_ (for RV32) does not have any spare PTE bits, and so no features from this chapter can be implemented.

The {cheri_priv_crg_ext} extension is enabled when the `sstatus.CRGE` bit is set.

The extension adds the ability for supervisor-mode software to quickly front-run loads of capabilities from userspace pages, and to track stores of capabilities to pages.
Such facilities have been shown to provide useful primitives for system-level implementation of certain forms of capability revocation which, in turn, allow userspace heap allocator software to deterministically guard against use-after-reallocation cite:[cornucopia-reloaded].

It achieves this by adding by adding the _pte.crg_, _pte.cd_ and `Xstatus.UCRG` bits as described below.
When the extension is disabled the _pte.cd_, _pte.crg_ and `Xstatus.UCRG` bits remain reserved.

NOTE: {cheri_priv_crg_ext} depends on Sv39 and {cheri_base64_ext_name} also being supported.

NOTE: {cheri_priv_crg_ext} is not a mandatory part of the {cheri_base64_ext_name} Privileged ISA, as a future extension may specify an alternative mechanism giving improved software efficiency.

NOTE: Hardware-initiated memory accesses from the page-table walker are not checked by a capability.

[#section_extending_pte]
=== Extending the Page Table Entry Format

ifdef::cheri_v9_annotations[]
NOTE: *CHERI v9 Note:* The current proposal is provisional and only includes
support for load-side revocation when compared to CHERI v9.
endif::[]

Two new bits, Capability Read Generation (CRG) and Capability Dirty (CD),
are added to leaf PTEs in Sv39, Sv48 and Sv57 as shown in
xref:sv39pte_crg[xrefstyle=short], xref:sv48pte_crg[xrefstyle=short] and
xref:sv57pte_crg[xrefstyle=short] respectively. For non-leaf PTEs these bits
remain reserved and must be cleared by software for forward compatibility,
or else a page-fault exception is raised. Additionally, if the hypervisor
extension is enabled these bits remain reserved for leaf and non-leaf PTEs
used in guest address translation.

.Sv39 page table entry
[#sv39pte_crg]
include::img/sv39pte_crg.edn[]

.Sv48 page table entry
[#sv48pte_crg]
include::img/sv48pte_crg.edn[]

.Sv57 page table entry
[#sv57pte_crg]
include::img/sv57pte_crg.edn[]

=== Software Primitives

The _pte.crw_ bit (defined by <<section_priv_cheri_vmem>>) continues to indicate whether loading or storing capabilities to
the virtual page is permitted.

When `sstatus.CRGE` is clear, the _pte.cd_ and _pte.crg_ bits are reserved and must not be set in any valid PTEs, and the existing rules from <<section_priv_cheri_vmem>> are followed.

When all of the following are true, {cheri_priv_crg_ext} adds two primitives for use by software:

. `sstatus.CRGE` is set.
. _pte.crw_ is set.
. The authorizing capability has <<c_perm>>.
. The PMA is set to (_CHERI {ctag_title}_).

==== {cheri_excep_name_pte_ld}s

When _pte.crw_ is set, _pte.crg_ can be used to trap on capability loads or AMOs when it does not match the value of `sstatus.UCRG`.

The implementation raises a {cheri_excep_name_pte_ld} when, in addition to the rules above, all of the following are true:

. A capability load or AMO is executed.
. _pte.crg_ does not equal `sstatus.UCRG`.
. _pte.u_ is set.
. Any other platform specific rules have not forced the loaded {ctag} to be clear.
. The loaded {ctag} is set.

{cheri_excep_name_pte_ld} is prioritized below {cheri_excep_name_pte_st} as shown in <<exception-priority-cheri>>, as AMOs can raise both.

NOTE: An example of a platform specific rule is a hardware engine clearing {ctag}s in memory after a call to free() to offload the CPU, which may have cleared a {ctag} before the CPU loads it.

The {cheri_excep_name_pte_ld} _must_ be taken if the loaded {ctag} is set.
The {cheri_excep_name_pte_ld} _may_ be taken if the loaded {ctag} is not set.
This gives a range of valid implementations.

[NOTE]
====

Checking the value of the {ctag} requires taking data dependent exceptions on loaded capabilities for loads or AMOs.
Ideally all implementations would trap precisely (taking the {ctag} into account in all cases) rather than conservatively (trapping more often, potentially on every loaded capability).
However, the loaded {ctag} may not be available in all implementations when determining whether to raise the exception, and therefore flexibility is permitted.
As a result, the software is required to be tolerant of raising the trap when the {ctag} is not set, potentially resulting in spurious traps from pages which have _pte.crw=1_, and so are likely to store valid capabilities.

Implementations which already take synchronous traps on loaded data, such as ECC faults, are recommended to check the loaded {ctag} when determining whether to raise the fault.

====

[[pte_crw_crg_load_summary]]
.Summary of capability load _pte.crw_ and _pte.crg_ behavior in the PTEs
[%autowidth,float="center",align="center",cols="<,<,<,<,<,<",options="header"]
|===
|_pte.crw_| _pte.cd_| _pte.crg_           | _pte.u_|tag^1^| Load Capability Behavior
| 0       | 0       | 0                   | X      |  X   | Clear loaded {ctag}
| 0       | 0       | 1                   | X      |  X   | Reserved
| 0       | 1       | X                   | X      |  X   | Reserved
| 1       | X       | X                   | 0      |  X   | Normal operation^2^
| 1       | X       | {ne} `sstatus.UCRG` | 1      |  0   | Implementation defined choice of +
{cheri_excep_name_pte_ld} or normal operation
| 1       | X       | {ne} `sstatus.UCRG` | 1      |  1   | {cheri_excep_name_pte_ld}
| 1       | X       | = `sstatus.UCRG`    | 1      |  X   | Normal operation
|===

^1^ The loaded {ctag}.

^2^ A future version of this specification may check an SCRG bit in `sstatus` in this case for trapping on kernel pages.

NOTE: {cheri_excep_name_pte_ld}s may be used to implement the load-barrier primitive from cite:[cornucopia-reloaded].

==== Capability Dirty Tracking

When _pte.crw_ is set, the _pte.cd_ bit indicates that a capability was stored to the
virtual page since the last time the _pte.cd_ bit was cleared.

NOTE: This is akin to the _pte.d_ bit indicating that a store occurred through this PTE since the last time _pte.d_ was cleared.

Capability dirty tracking behavior is enabled when, in addition to the rules above, all of the following are true:

. A capability store or AMO instruction is executed.
. The to-be-stored {ctag} is set.
. _pte.cd_ is clear.

Two schemes for capability dirty tracking are permitted, and the scheme in use is determined by whether the _Svade_ or _Svadu_ extensions are enabled.

* For _Svade_, take a {cheri_excep_name_pte_st}.
* For _Svadu_, do a hardware update which sets _pte.cd=1_, following the same rules as setting _pte.d_.
** When setting _pte.cd_, the hardware update also necessarily sets (or leaves set) _pte.a_ and _pte.d_.

[[pte_crw_cd_store_summary]]
.Summary of capability store _pte.crw_ and _pte.cd_ behavior in the PTEs
[%autowidth,float="center",align="center",cols="<,<,<,<,<",options="header"]
|===
|_pte.crw_|_pte.cd_|_pte.crg_|tag^1^| Store Capability Behavior
| 0       | 0      | 0       |  0   | Normal operation
| 0       | 0      | 0       |  1   | {cheri_excep_name_pte_st}
| 0       | 0      | 1       |  X   | Reserved
| 0       | 1      | X       |  X   | Reserved
| 1       | 0      | X       |  0   | Normal operation
| 1       | 0      | X       |  1   | {cheri_excep_name_pte_st} (_Svade_) +
or hardware _pte.cd_ update (_Svadu_)
| 1       | 1      | X       |  X   | Normal operation
|===

^1^ The to-be-stored {ctag}.

[NOTE]
====

Because the state of _pte.cd=1_ and _pte.crw=0_ is _reserved_:

*  It is possible for the update of _pte.cd_ to fail if another thread has cleared _pte.crw_.
ifndef::cheri_standalone_spec[]
 This follows the standard rules in xref:sv32algorithm[xrefstyle=short].
endif::[]
* For non-capability data, it is possible for a virtual page to be read-only but also dirty (_pte.w=0, pte.d=1_).
 The analogous page state is not permitted for capability data.

====

The capability dirty tracking is resolved during memory translation, but there are cases it is not known if there will be a {ctag} stored to memory or not at this point.
Capability dirty tracking _must_ be triggered when there is a stored {ctag}, and _may_ be triggered in the following case where it is not known if there will be a stored {ctag} during translation.

* <<STORE_COND_CAP>> triggers capability dirty tracking if the {ctag} is set in {cs2}, even if the store fails.

[NOTE]
====

_pte.cd_ must always be set when there is a stored {ctag} to a virtual page so that software knows which pages have had capabilities stored to them.
It may be set too often, which may cause software to examine the page to check for capabilities when none are present.
This is a situation software is required to handle anyway, as it is always possible for all capabilities in a page to be overwritten by non-capability data.
In this case the _pte.cd_ bit will still be set.

Future AMOs fall into this category:

* For future AMOCAS{LD_ST_DOT_CAP}, it is not known whether the store will happen until the load has executed and the compare has been done. Therefore, AMOCAS{LD_ST_DOT_CAP} is likely to trigger capability dirty tracking if the {ctag} is set in {cs2}.
* For future AMOADD{LD_ST_DOT_CAP}, the stored {ctag} depends upon the loaded {ctag} which is not known during translation and also on the execution of the <<CADD>>.
 Therefore, AMOADD{LD_ST_DOT_CAP}, is likely to always trigger capability dirty tracking.

Checking the stored {ctag} is less of a burden to the implementation than checking the loaded {ctag} for {cheri_excep_name_pte_ld}, which is why checking the loaded {ctag} is optional behavior.
 However, a future extension may reduce the burden further by removing the check on the to-be-stored {ctag}.

====

NOTE: Capability dirty tracking may be used to implement the store-barrier primitive from cite:[cornucopia-reloaded].

==== Minimum support

The minimum level of PTE support is to set _pte.crw_ and _pte.cd_ to 1 in all PTEs intended for storing
capabilities (e.g., private anonymous mappings) and leave
`sstatus.UCRG` on all harts and _pte.crg_ in all PTEs set to 0, which will allow
capabilities to be loaded and stored successfully.

[#xstatus_pte]
=== UCRG, CRGE CSR fields

The `mstatus`, `sstatus` and `vsstatus` CSRs include the new Userspace Capability Read Generation (UCRG) and Capability Read Generation Enable (CRGE) bits.

[#sstatus_crge_note]
[NOTE]
====

The CRGE bit is necessary because {cheri_priv_crg_ext} defines a different semantic for the _pte.crw=1_, _pte.cd=0_ and _pte.crg=0_ state with respect to <<section_priv_cheri_vmem>>.
In particular, an oblivious software implementation that only sets the _pte.crw_ bit would observe one of the following:

* The _pte.cd_ bit is set by the hardware when a capability is stored and _Svadu_ is enabled.
* A {cheri_excep_name_pte_st} trap when _Svade_ is enabled.

The CRGE bit also has the benefit of maintaining matching polarity of the _pte.cd_ bit with respect to the data Dirty bit (_pte.d_).
If the behavior of the _pte.crw=1_ _pte.cd=0_ state were defined to match the behavior when {cheri_priv_crg_ext} is not implemented, then _pte.cd_ would need to have 0 meaning dirty, which is inconsistent.

The CRGE bit also permits alternative uses of the _pte.cd_ and _pte.crg_ reserved states by future extensions without worrying about compatibility with <<section_priv_cheri_vmem>> (e.g. by an alternative revocation extension which uses more states).

====

ifdef::cheri_standalone_spec[]

[#mstatusreg_pte]
.Machine-mode status (*mstatus*) register for {cheri_base64_ext_name}
[wavedrom, ,svg,subs=attributes+]
....
{reg: [
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SIE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'MIE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SPIE'},
  {bits:  1, name: 'UBE'},
  {bits:  1, name: 'MPIE'},
  {bits:  1, name: 'SPP'},
  {bits:  2, name: 'VS[1:0]'},
  {bits:  2, name: 'MPP[1:0]'},
  {bits:  2, name: 'FS[1:0]'},
  {bits:  2, name: 'XS[1:0]'},
  {bits:  1, name: 'MPRV'},
  {bits:  1, name: 'SUM'},
  {bits:  1, name: 'MXR'},
  {bits:  1, name: 'TVM'},
  {bits:  1, name: 'TW'},
  {bits:  1, name: 'TSR'},
  {bits:  1, name: 'SPELP'},
  {bits:  1, name: 'SDT'},
  {bits:  7, name: 'WPRI'},
  {bits:  2, name: 'UXL[1:0]'},
  {bits:  2, name: 'SXL[1:0]'},
  {bits:  1, name: 'SBE'},
  {bits:  1, name: 'MBE'},
  {bits:  1, name: 'GVA'},
  {bits:  1, name: 'MPV'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'MPELP'},
  {bits:  1, name: 'MDT'},
  {bits: 17, name: 'WPRI'},
  {bits:  1, name: 'CRGE'},
  {bits:  1, name: 'UCRG'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SD'},
], config:{lanes: 4, hspace:1024}}
....

[#sstatusreg_pte]
.Supervisor-mode status (*sstatus*) register when SXLEN=64
[wavedrom, ,svg,subs=attributes+]
....
{reg: [
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SIE'},
  {bits:  3, name: 'WPRI'},
  {bits:  1, name: 'SPIE'},
  {bits:  1, name: 'UBE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SPP'},
  {bits:  2, name: 'VS[1:0]'},
  {bits:  2, name: 'WPRI'},
  {bits:  2, name: 'FS[1:0]'},
  {bits:  2, name: 'XS[1:0]'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SUM'},
  {bits:  1, name: 'MXR'},
  {bits:  3, name: 'WPRI'},
  {bits:  1, name: 'SPELP'},
  {bits:  1, name: 'SDT'},
  {bits:  7, name: 'WPRI'},
  {bits:  2, name: 'UXL[1:0]'},
  {bits: 26, name: 'WPRI'},
  {bits:  1, name: 'CRGE'},
  {bits:  1, name: 'UCRG'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SD'},
], config:{lanes: 4, hspace:1024}}
....

[#vsstatusreg_pte]
.Virtual Supervisor-mode status (*vsstatus*) register when VSXLEN=64
[wavedrom, ,svg,subs=attributes+]
....
{reg: [
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SIE'},
  {bits:  3, name: 'WPRI'},
  {bits:  1, name: 'SPIE'},
  {bits:  1, name: 'UBE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SPP'},
  {bits:  2, name: 'VS[1:0]'},
  {bits:  2, name: 'WPRI'},
  {bits:  2, name: 'FS[1:0]'},
  {bits:  2, name: 'XS[1:0]'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'MXR'},
  {bits:  1, name: 'SUM'},
  {bits: 12, name: 'WPRI'},
  {bits:  2, name: 'UXL[1:0]'},
  {bits: 26, name: 'WPRI'},
  {bits:  1, name: 'CRGE'},
  {bits:  1, name: 'UCRG'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SD'}
], config:{lanes: 4, hspace:1024}}
....

endif::[]
