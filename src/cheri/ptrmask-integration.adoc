ifdef::cheri_standalone_spec[]
[#section_cheri_pointer_masking_integration, reftext="Ssnpm, Smnpm, Smmpm, Sspm, Supm ({cheri_base_ext_name})"]
== Pointer Masking (Ssnpm, Smnpm, Smmpm, Sspm, Supm)  ({cheri_base64_ext_name})

endif::[]

NOTE: The suggestion in this section is based on the pointer masking approach from Morello but with changes
to sign extension and to address the dynamic nature of bit masking.
#Further evaluation is still required.#

When bounds are <<section_cap_encoding,encoded or decoded>>, a masked but _not_ sign extended address is used.
Changing how many bits are masked can therefore change the interpretation of the bounds of a capability,
both for the purpose of implicit accesses via bounds checks and any instructions that report the bounds of a capability.
Apart from treating the PMLEN high address bits as zero, there are no other changes to bounds decode,
which are still based on XLEN, not the new effectively addressable space.
That is, the maximum length of a capability does not change, and
it is not invalid to have a capability that covers a longer range than could be actually be addressed with pointer masking enabled (such as one that covers the entire XLEN address space).
For the <<section_cap_representable_check, representable range check>>, both the original and new addresses
are masked.
Bounds setting instructions also mask the address in the same way.

NOTE: Because dynamically changing the number of masked bits changes the interpretation of a capability,
software must take the same care when sharing capabilities between address spaces with differing pointer masking
as it generally must when sharing capabilities between address spaces with different page mappings.

Any address that is checked against a capability
is also first subject to the same masking as bounds decode (masking without extension).
After any CHERI operations, the final access address is still subject to as much sign extension as the pointer masking extensions mandate.

In summary, for data accesses only:

* When setting bounds ({SCBNDS}/{SCBNDSI}/{SCBNDSR}), bits [XLEN-1:XLEN-PMLEN] of the address are set to zero and therefore the resulting capability will have a base with the PMLEN high address bits set to zero.
* When decoding bounds, the address used for decoding has bits [XLEN-1:XLEN-PMLEN] set to zero.
* When checking the <<section_cap_representable_check, representable range>> for {CADDI}/{CADD}/{SCADDR}, the old address and new addresses both have bits [XLEN-1:XLEN-PMLEN] set to zero *before* the check.

Also note that:

* <<pcc>> bounds decoding isn't affected by pointer masking.
* Any <<section_cap_representable_check, representable range check>> triggered by a write to a CSR (e.g. <<mtvec_y>>) are not affected by pointer masking.
