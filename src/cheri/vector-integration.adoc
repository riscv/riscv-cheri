[#section_cheri_vector_integration, reftext="Vector \"V\" ({cheri_base_ext_name})"]
== Vector "V" Extension ({cheri_base_ext_name})

The Vector extension is orthogonal to {cheri_base_ext_name} because the vector registers do not support {ctag}s.

NOTE: A future extension may allow {ctag}s to be stored in vector registers.
  Until that time, vector load and store instructions must not be used to implement generic
  memory copying in software, such as the `memcpy()` standard C library function,
  because the vector registers do not hold capabilities, so the {ctag}s of any
  copied capabilities will be set to 0 in the destination memory.

Under {cheri_base_ext_name}, vector loads and stores follow the standard rules for _active_ elements:

* Only _active_ elements are subject to CHERI exception checks.
* If there are no _active_ elements then no CHERI exceptions will be raised.
* CHERI exceptions are only raised on fault-only-first loads if element 0 is both _active_ and fails any exception checks.

Additionally the standard {cheri_base_ext_name} rule that all loads and stores where the base register is `x0` are reserved applies to all vector memory access instructions.

NOTE: The approach of using indexed loads with the base register set to the value zero and XLEN-wide offsets does not work well with CHERI as the authorizing capability must cover all of memory.
      If the authorizing capability is specified as `x0` then the instruction encoding is _reserved_.
