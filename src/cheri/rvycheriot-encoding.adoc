[#rv32y_cheriot_cap_description, reftext="{rvy32e_cheriot_base_name} (CHERIoT V1)"]
== The {rvy32e_cheriot_base_name} Capability Base Extension for {cheri_base32e_ext_name}, (CHERIoT V1)

This chapter describes an in-memory format and properties of a capability encoding intended for {cheri_base32e_ext_name}.
This is the encoding used for CHERIoT, which is an RV32Y variant adapted for microcontrollers.
Compared to <<rv32y_cap_description>> it has some additional features for building rich compartmentalization, such as extra permissions and sealing types, and some differences in the bounds encoding that trade some software compatibility for more precise bounds on small sizes and reduced microarchitectural complexity.

[#section_cap_encoding_cheriot]
=== Capability Encoding

The components of a capability, except the {ctag}, are encoded as shown in xref:cap_encoding_cheriot[xrefstyle=short].

.Capability encoding for {rvy32e_cheriot_base_name}
[#cap_encoding_cheriot]
include::img/cap-encoding-cheriot.edn[]

NOTE: The reserved bit( R ) must be 0 in valid capabilities and is available for future extensions.

[#cheriot_encoding_field_summary, reftext="CHERIoT capability fields"]
[width="100%",options=header,cols="1,5"]
|==============================================================================
| Field      | Description
| R          | Reserved bit, must be zero in valid capabilities and preserved in any value loaded from memory and stored.
| G          | Global bit, as in <<zylevels1_gl_perm>>.
| P          | Architectural Permissions, see <<cheriot-permission-encoding>>.
| CT         | Sealed object Type, see <<section_cheriot_cap_type>>.
| E          | Exponent field for bounds encoding, see <<section_cheriot_cap_bounds>>.
| T          | Top field for bounds encoding, see <<section_cheriot_cap_bounds>>.
| B          | Base field for bounds encoding, see <<section_cheriot_cap_bounds>>.
| Address    | The address field as per <<cap_structure>>.
|==============================================================================

The encoding impacts the following CHERI extensions:

<<section_cheri_hybrid_ext>>::
This encoding does not support {cheri_default_ext_name}: there is no mode bit so only purecap mode is supported.

<<section_zylevels1>>::
This encoding supports <<section_zylevels1>>.
The <<zylevels1_gl_perm,GL>> flag is encoded in the G bit.

<<section_zyseal>>::
This encoding supports <<section_zyseal>>.
The <<zyseal_se_perm,SE>> and <<zyseal_us_perm,US>> permissions are encoded in the P field.

This capability encoding has the following properties that affect the observable behavior of {cheri_base_ext_name} instructions such as <<SCBNDS>> and <<CLRPERM>>:

* **Mantissa width (mw{cap_cheriot_mw_width})**: The mantissa width for the bounds encoding uses {cap_cheriot_mw_width} bits
* **Maximum exponent (e{cap_cheriot_exp_max})**: The maximum value for the exponent in a valid capability is {cap_cheriot_exp_max}, however exponents 15 to 23 are not supported (see below).
* **Representable region (rc0)**: Only addresses between encoded base and top (inclusive) are guaranteed to be representable.
* **Permission encoding (pc)**: The permissions are encoded using a compressed format that cannot represent every combination of permissions.

==== Capability Encoding Parameter Summary

.{rvy32e_cheriot_base_name} parameter summary
[#rvy32e_cheriot_base_name_param_summary,width="100%",options=header,]
|==============================================================================
| Parameter | Value                | Comment
| mw        | {cap_cheriot_mw_width}  | Mantissa width
| e         | 14                   | Exponent limit before jumping to maximum exponent
| rc        | 0                    | Representable region between base and top only
| p         | pc                   | Compressed permission encoding
| as        | 11                   | <<AUIPC>> shift
|==============================================================================

.{rvy32e_cheriot_base_name} extension summary
[#rvy32e_cheriot_base_name_ext_summary,width="100%",options=header,]
|==============================================================================
| Extension                    | Comment
| <<section_cheri_hybrid_ext>> | Not supported
| <<section_zylevels1>>        | Compatible
ifdef::cheri_standalone_spec[]
| <<section_zyseal>>           | Compatible
endif::[]
| All RVY versions of other standard extensions | Compatible if the extension is compatible with RV32I
|==============================================================================

.{rvy32e_cheriot_base_name} Feature summary
[#rvy32e_cheriot_base_name_feature_summary,width="100%",options=header,]
|==============================================================================
| Feature                      | Comment
| Representable region         | Between base and top only (inclusive)
| Permission encodings         | Not all combinations can be represented
|==============================================================================

[#cheriot-permission-encoding, reftext="CHERIoT permission encoding"]
==== Architectural Permissions Encoding

As with {rv32y_uni_base_name} the permisisons are encoded in a compressed form.

The permission encoding space is split into quadrants using P[3:2].
Each quadrant may include some fixed permissions (indicated with ✔) and some dependent permissions encoded using P[2:0]. 
Quadrant 0 is used to encode permissions that authorise sealing (see <<section_zyseal>>) and also a single software-defined permission, SDP0. It can also encode 'no permissions'.
Quadrant 1 encodes executable capabilities along with the dependent permission ASR and optional permissions LM and LG.
Quadrant 2 is subdivided into octants, with octant 4 encoding combinations of R and W without C (with the redundant not R and not W used to encode write-only with C). 
Octant 5 encodes read-only capabilities with C and the dependent permissions LM and LG.
Quadrant 3 encodes permissions with R, W, C and the dependent permissions SL, LM and LG.
The meaning for bits [2:0] are shown in <<cheriot_perms_encoding>>.

[#cheriot_perms_encoding,width="100%",options=header,cols="^2,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,^1,4",align="center",reftext="CHERIoT permission encoding"]
|===
4+| P[4:0] 12+| Decoded Permissions
| P[4:3] | P[2] | P[1] | P[0] |  R   |  W   |  C   |  SL  |  LM  |  LG  |  X  | ASR  |  SDP0  |  SE  |  US  | Notes

| 00     | SDP0   | SE   | US   |      |      |      |      |      |      |     |      | P[2] | P[1] | P[0] | Sealing
| 01     | ASR  | LM   | LG   |  ✔   |      |  ✔   |      | P[1] | P[0] |  ✔  | P[2] |      |      |      | Executable
| 10     | 0    | 0    | 0    |      |  ✔   |  ✔   |      |      |      |     |      |      |      |      | Cap WO
| 10     | 0    | R    | W    | P[1] | P[0] |      |      |      |      |     |      |      |      |      | Data RW (must have R or W)
| 10     | 1    | LM   | LG   |  ✔   |      |  ✔   |      | P[1] | P[0] |     |      |      |      |      | Cap RO
| 11     | SL   | LM   | LG   |  ✔   |  ✔   |  ✔   | P[2] | P[1] | P[0] |     |      |      |      |      | Cap RW
|===

For example, if P[4:3] = 01 and P[2:0] = 101 then the decoded permissions are R, C, X, LG, and ASR.
Note that there is no encoding for an "Infinite" capability with all permissions.
In particular there is no overlap between the sealing permissions (SDP0, SE, US) and any other permissions and X is mutually exclusive with W.
This means there are three <<root-cap>> capabilities from which all other capabilities can be derived using <<CLRPERM>>. These are shown in <<cheriot_root_caps>>, along with the CSRs that will contain this root on reset.

[#cheriot_root_caps,width="100%",options=header,cols="1,1,2,2",align="center",reftext="CHERIoT root capabilities"]
|===
| Root name  | P[4:0] | Permissions          | Reset location
| Sealing    | 00111  | SDP0, SE, US           | <<mscratch>>
| Executable | 01111  | X, R, C, LM, LG, ASR | <<pcc>>, <<mtvec>>
| RW Root    | 11111  | W, R, C, LM, LG, SL  | <<mtidc>>
|===

To encode a set of permissions resulting from <<CLRPERM>>, the following procedure is used:

1. If the permissions include X, R and C then encode ASR, LM and LG using the
executable format (P[4:3] = 01).
2. Otherwise, if the permissions include R, W and C then encode SL, LM and LG
using the Cap RW format (P[4:3] = 11).
3. Otherwise, if the permissions include R and C then encode LM and LG using
the Cap RO format (P[4:2] = 101).
4. Otherwise, if the permissions include W and C then encode using the Cap WO format (P[4:0] = 10000).
5. Otherwise, if the permissions include R or W then encode using the Data RW format (P[4:0] = 100RW).
6. Otherwise, encode SDP0, SE and US using the sealing format (P[4:3] = 00).

If any of the requested permissions cannot be represented using the chosen format then the they are dropped.
For example, if the requested permissions are R, LG and X then rule 5 applies and the resulting permissions will be just R.
This procedure will automatically apply the rules defined in <<sec_permission_transitions>> and <<zylevels1-clrperm-rules>> to legalize permission sets.

[#SDP-fieldcheriot, reftext="SDP-field"]
==== Software-Defined Permissions (SDP) Encoding

The <<SDP-field32>> is {cap_cheriot_sdp_width} bit wide.
The single software defined permission, SDP0 appears as bit zero in the value of the <<SDP-field32>> bits of <<GCPERM>>.

NOTE: Software is completely free to define the usage of this bit, however it is only present on capabilities derived from the sealing root capability so cannot be used in combination with memory access permissions.

[#section_cheriot_cap_type]
==== Capability Type (CT) Encoding

Capabilities in this encoding have a 3-bit field for <<sec_cap_type>> values.
This is used to encode 15 different sealing types by distinguishing between executable and non-executable sealed capabilities as follows:

[#cheriot_cap_type_encoding,width="100%",options=header,cols="1,1,1,2",align="center"]
|===
| CT Value | X | Decoded Type  | Description

| 000      | 1 | 0   | Unsealed
| 001      | 1 | 1   | Standard sentry
| 010      | 1 | 2   | Interrupt disabling forward sentry
| 011      | 1 | 3   | Interrupt enabling forward sentry
| 100      | 1 | 4   | Interrupt disabling return sentry
| 101      | 1 | 5   | Interrupt enabling return sentry
| 110      | 1 | 6   | Sealed with type 6
| 111      | 1 | 7   | Sealed with type 7
| 000      | 0 | 0   | Unsealed
| 1 .. 7   | 0 | 9 .. 15 | Data capability sealed with given type
|===

In addition to the ordinary <<sentry_cap>> type this encoding defines four types of sentry for enforcing structured control flow and atomically changing the value of `mstatus.IE` during a <<JALR_CHERI>>.
This works as follows:

* The type of the link capability produced by <<JALR_CHERI>> and <<JAL_CHERI>> varies depending on the current value of `mstatus.MIE` and the destination register index, rd. If the destination is `ra` then a return sentry appropriate to the current interrupt status is created, otherwise an ordinary forward sentry is created:

[#cheriot_jalr_link_cap_types,options=header,cols="1,1,1",align="center"]
[%autowidth]
|===
| mstatus.MIE | link register | Return capability sealing type

| any         | not ra        | 1 (standard sentry)
| 0           | ra            | 4 (interrupt disabling return sentry)
| 1           | ra            | 5 (interrupt enabling return sentry)
|===

* <<JALR_CHERI>> sets `mstatus.MIE` to 0 when jumping to a type 2 or 4 sentry, and sets it to 1 when jumping to a type 3 or 5 sentry. Other jumps leave it unchanged.

* <<JALR_CHERI>> has additional restrictions on which sentry types are accepted depending on the register indexes used for rs1 (target) and rd (link):

[#cheriot_jalr_sentry_rules,options=header]
[%autowidth]
|===
| rs1 | rd  | Accepted capability types

| any | ra  | 0, 1, 2, 3 (unsealed or forward sentries)
| ra  | zr  | 4, 5 (return sentries only)
2+| otherwise | 0, 1 (non interrupt modifying only)
|===

If the sentry is not of the correct type then the {ctag} is cleared on the target <<pcc>>, leading to a trap.
The purpose of this is to enable calls to short atomic sequences on single-core microcontrollers without granting the right to modify `mstatus.MIE` arbitrarily.
These rules ensure that functions that are called with a new interrupt stance can return to the caller's stance as well as providing a degree of control flow integrity.
Non-standard control flow transfers such as tail calls and calls to compiler outlined functions using a non-standard link register are still possible.

[#section_cheriot_cap_bounds, reftext="CHERIoT Capability Bounds Encoding"]
==== Bounds (E, B, T) Encoding

The bounds are encoded in similar, but slightly simplified way to <<section_cap_bounds,{rv64y_uni_base_name}>>, with field B and T being substitued into the address at the offset given by the exponent to form the base and top.
Rather than using an EF field to indicate whether the exponent is zero or contained in the low bits of B and T the exponent is stored  in its own 4-bit field, E.
Since this is not large enough to store the maximum exponent of 24 required to cover the full 32-bit address space, an E value of 15 decodes as 24 with exponents 15 to 23 being invalid.
The decoded exponent, e, is given by:

[source]
----
e = (E == 15) ? 24 : E
----

This means that capabilities up to nearly 8 MiB are represented with alignment requirements increasing in powers of two for increasing exponents up to 14, and all larger capabilities must have bounds aligned to 16 MiB.
<<rv32y_cheriot2_cap_description>> describes an encoding variant that removes this limitation.

For a given exponent the base and top are then computed as:

.Decoding of the XLEN+1 wide top (_t_) bound
[#cheriot_top_bound_dec]
include::img/cheriot-top-bound-dec.edn[]

.Decoding of the XLEN wide base (_b_) bound
[#cheriot_base_bound_dec]
include::img/cheriot-base-bound-dec.edn[]

where the corrections, c~t~ and c~b~, are given by:

[source]
----
A_hi = (A[e + 8 : e]) < B ? 1 : 0
T_hi = (T < B) ? 1 : 0
c_b = -A_hi
c_t = A_hi - T_hi
----

These corrections work by assuming that the base is in the lower of two 2^e+9^ aligned regions, and that the top and address are always greater than or equal to the base but may be in the higher region provided they are within 2^e+9^ of base.
These assumptions lead to the representable region being given by:

[source]
----
base <= address < base + (1 << (e + 9))
----

This must be checked by all operations that change the capability address.
If this check fails the resulting capability will have its {ctag} cleared.
Note that this means that it is not possible to represent a capability with an address less than the base.
Depending on the size of the capability some addresses above top may be representable, but in the worst case the highest representable address is equal to top (one byte beyond the end of the dereferenceable region).

===== Encoding bounds

When <<SCBNDS>> is used to set the bounds of a capability the E, B and T fields are computed from the desired base and length as follows:

[source]
----
// compute candidate exponent
e = 23 - count_leading_zeros(length[31 : 9])
if e > 14 then {
  e = 24
}

// extend base and top to XLEN+1 bits
base33 = 1b0 @ base
top33 = base33 + (1b0 @ length)

// extract 10-bit from base and top
b = base33[e + 9 : e]
t = top33[e + 9 : e]

// round up top if low bits are truncated
if top33[e - 1 : 0] != 0 {
  t = t + 1
}

// in case this caused length overflow use the next exponent
if t - b >= 1 << (e + 9) {
  e += 1
  if e > 14 then {
    e = 24
  }
  b = base33[e + 9 : e]
  t = top33[e + 9 : e]
  if top33[e - 1 : 0] != 0 {
    t = t + 1
  }
}

// encode E
E = (e == 24) ? 15 : e
// truncate B and T to 9 bits
B = b[8 : 0]
T = t[8 : 0]
----

===== <<AUIPC_CHERI>> Representability

Due to the limited representable range of this encoding there can be a problem when using <<AUIPC_CHERI>> to form addresses relative to <<PCC>>. For example, the following sequence might used to performa a pc relative relocation by an offset [imm20|imm12]:

[source,riscv]
----
auipc    rd1, imm20
addiy    rd2, rd1, imm12
----

In this case it is possible that imm20 is negative and imm12 is positive such that the resulting address in rd2 is inside the bounds of <<pcc>> but the intermediate address in rd1 is below the base and hence unrepresentable.
This would cause the {ctag} of rd1 to be cleared, leading to a trap when rd2 is used as a capability.

To avoid this problem the the shift applied to imm20 in <<AUIPC_CHERI>> is reduced to 11 bits rather than 12, so that is possible to ensure imm12 and imm20 have the same sign, keeping the intermediate address in rd1 within the representable region.
This limits the range of pc-relative offsets that can be formed using this sequence to ±1 GiB, but this is not a problem in practice as <pcc> will have much smaller bounds than this in real systems targeted by this encoding.

[#section_cheriot_cap_special_encodings]
=== Encoding of Special Capabilities

[#section_null_cap_encoding_cheriot]
==== NULL Capability Encoding

The <<null-cap>> capability is represented with 0 in all fields. This implies
that it is unsealed, has no permissions and its exponent, base and top are 0.

.Field values of the NULL capability
[#null-cap-encoding-cheriot,reftext="NULL",options=header,align=center,width="70%",cols="25,23,52"]
|==============================================================================
| Field    | Value  | Comment
| {ctag_title} | zero   | Capability is not valid
| R        | zero   | Reserved bit
| G        | zero   | Not global
| P        | zeros  | Grants no permissions
| CT       | zeros  | Unsealed
| E        | zeros  | Exponent
| T        | zeros  | Top address bits
| B        | zeros  | Base address bits
| Address  | zeros  | Capability address
|==============================================================================

[#section_infinite_cap_encoding_cheriot]
==== Infinite Capability Encoding

The encoding for the root capabilities have maximum bounds. The P field depends on which root capability is being represented as per <<cheriot_root_caps>>.

.Field values of the Infinite capability
[#infinite-cap-encoding-cheriot,reftext="Infinite"]
[options=header,align=center,width="90%",cols="25,23,52"]
|==============================================================================
| Field         | Value | Comment
| {ctag_title}  | one   | Capability is valid
| R        | zero   | Reserved bit
| G        | 1      | Global
| P        | XXXXX  | depends on root
| CT       | zeros  | Unsealed
| E        | 0xf    | Maximum exponent
| T        | 0x100  | top = 2^XLEN^
| B        | 0x000  | base 0
| Address  | zeros  | Capability address
|==============================================================================
