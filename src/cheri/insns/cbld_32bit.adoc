<<<

[#CBLD,reftext="CBLD"]
==== CBLD

ifdef::cheri_v9_annotations[]
NOTE: *CHERI v9 Note:* CBLD does not use ddc if ys1==0

NOTE: *CHERI v9 Note:* this instruction was called CBUILDCAP.
endif::[]

include::new_encoding_note.adoc[]

Synopsis::
Capability build

Mnemonic::
`cbld yd, ys1, ys2`

Encoding::
include::wavedrom/cbld.adoc[]

Description::
Copy `ys2` to `yd` and set `yd.tag` to 1 if

. `ys1.tag` is set, and
. `ys1` 's bounds are not <<section_cap_malformed,malformed>>, and all reserved fields are zero, and
. `ys1` 's permissions could have been legally produced by <<ACPERM>>, and
. `ys1` is not sealed, and
. `ys2` 's permissions and bounds are equal to or a subset of `ys1` 's, and
. `ys2` 's <<section_cap_level>> is equal to or lower than `ys1` 's, and
+
NOTE: With {cheri_0levels_ext_name} this check always passes as the level is hardwired.
. `ys2` 's bounds are not <<section_cap_malformed,malformed>>, and all reserved fields are zero, and
. `ys2` 's permissions could have been legally produced by <<ACPERM>>, and
. All reserved bits in `ys2` 's metadata are 0;

Otherwise, copy `ys2` to `yd` and clear `yd` 's tag.

<<CBLD>> is typically used alongside <<SCHI>> to build
capabilities from integer values.

NOTE: When `ys1` is `c0` this will copy `ys2` to `yd` and clear `yd.tag`.
However this may change in future extensions, and so software should not
assume `ys1==0` to be a pseudoinstruction for tag clearing.

Operation::
+
sail::execute[clause="CBLD(_, _, _)",part=body,unindent]
