<<<

[#CBLD,reftext="{CBLD}"]
==== {CBLD}

ifdef::cheri_v9_annotations[]
NOTE: *CHERI v9 Note:* {CBLD} does not use ddc if {creg_pref}s1==0

NOTE: *CHERI v9 Note:* this instruction was called CBUILDCAP.
endif::[]

include::new_encoding_note.adoc[]

Synopsis::
{CBLD_DESC}

Mnemonic::
`{cbld_lc} {creg_pref}d, {creg_pref}s1, {creg_pref}s2`

Encoding::
include::wavedrom/cbld.adoc[]

Description::
Copy `{creg_pref}s2` to `{creg_pref}d`.
+
Set `{creg_pref}d.tag=1` if:
+
. `{creg_pref}s1.tag` is set, and
. `{creg_pref}s1` passes all <<section_cap_integrity,integrity>> checks, and
. `{creg_pref}s1` is not sealed, and
. `{creg_pref}s2` 's permissions and bounds are equal to or a subset of `{creg_pref}s1` 's, and
. `{creg_pref}s2` passes all <<section_cap_integrity,integrity>> checks, and
. any extension-specific constraints on <<CBLD>> hold.
+
Otherwise, set `{creg_pref}d.tag=0`

NOTE: <<CBLD>> is typically used alongside <<SCHI>> to build
capabilities from integer values.

NOTE: When `{creg_pref}s1` is `{creg}0` <<CBLD>> will copy `{creg_pref}s2` to `{creg_pref}d` and clear `{creg_pref}d.tag`.
However future extensions may add additional behavior to update currently reserved fields,
and so software should not assume `{creg_pref}s1==0` to be a pseudo-instruction for tag clearing.

Operation::
+
sail::execute[clause="CBLD(_, _, _)",part=body,unindent]
