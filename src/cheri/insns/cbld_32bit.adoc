<<<

[#CBLD,reftext="{CBLD}"]
==== {CBLD}

ifdef::cheri_v9_annotations[]
NOTE: *CHERI v9 Note:* {CBLD} does not use ddc if {cs1}==0

NOTE: *CHERI v9 Note:* this instruction was called CBUILDCAP.
endif::[]

include::new_encoding_note.adoc[]

Synopsis::
{CBLD_DESC}

Mnemonic::
`{cbld_lc} {cd}, {cs1}, {cs2}`

Encoding::
include::wavedrom/cbld.adoc[]

Description::
Copy `{cs2}` to `{cd}`.
+
Set `{cd}.ct=0` (that is, set its <<sec_cap_type>> field
such that <<CBLD>> always builds _unsealed_ capabilities).
+
Set `{cd}.tag=1` if:
+
. `{cs1}.tag` is set, and
. `{cs1}` passes all <<section_cap_integrity,integrity>> checks, and
. `{cs1}` is not sealed (that is, its <<sec_cap_type>> field, `{cs1}.ct`, is `0`), and
. `{cs2}` 's permissions and bounds are equal to or a subset of `{cs1}` 's, and
. `{cs2}` passes all <<section_cap_integrity,integrity>> checks, and
. any extension-specific constraints on <<CBLD>> hold.
+
Otherwise, set `{cd}.tag=0`

NOTE: <<CBLD>> is typically used alongside <<SCHI>> to build
capabilities from integer values.

NOTE: When `{cs1}` is `{creg}0` <<CBLD>> will copy `{cs2}` to `{cd}` and clear `{cd}.ct` and `{cd}.tag`.
However future extensions may add additional behavior to update currently reserved fields,
and so software should not assume `{cs1}==0` to be a pseudo-instruction for {ctag} and type clearing.

[NOTE]
=====
<<CBLD>> can be used for "superset unsealing",
wherein software, given a capability `c`
and having checked for a set tag and an expected <<sec_cap_type>> field value,
can present, in `{cs1}`,
a capability to a superset of the authority borne by an unsealed `c`,
and thereby reconstruct, into `{cd}`, a modified copy of `c`, presented in `{cs2}`,
with a zeroed <<sec_cap_type>> field and a set tag.
For example, to unseal from `x3` into `x1`
using the superset in `x2` with scratch `x4`, such software might look like:

[subs="+attributes"]
----
  {GCTAG_LC} x4, x3  // check that input is tagged
  beqz x4, fail
  {GCTYPE_LC} x4, x3 // check that input is sealed
  beqz x4, fail
  {CBLD_LC} x1, x2, x3
  {GCTAG_LC} x4, x1  // check that output is tagged
  beqz x4, fail
----

Additional instructions may be required if the encoding implements
multiple <<sec_cap_type>> values
in addition to distinguishing (un)sealed capabilities.

The unsealing mechanism of <<section_zyseal>> is more flexible
and is generally encouraged, if it is available on a given platform.
=====

Included in::
<<rvy_insn_table>>

Operation::
+
sail::execute[clause="CBLD(_, _, _)",part=body,unindent]
