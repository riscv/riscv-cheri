<<<

[#CBLD,reftext="{CBLD}"]
==== {CBLD}

ifdef::cheri_v9_annotations[]
NOTE: *CHERI v9 Note:* {CBLD} does not use ddc if {cs1}==0

NOTE: *CHERI v9 Note:* this instruction was called CBUILDCAP.
endif::[]

include::new_encoding_note.adoc[]

Synopsis::
{CBLD_DESC}

Mnemonic::
`{cbld_lc} {cd}, {cs1}, {cs2}`

Encoding::
include::wavedrom/cbld.adoc[]

Description::
Copy `{cs2}` to `{cd}`.
+
Set `{cd}.tag=1` if:
+
. `{cs1}.tag` is set, and
. `{cs1}` passes all <<section_cap_integrity,integrity>> checks, and
. `{cs1}` is not sealed, and
. `{cs2}` 's permissions and bounds are equal to or a subset of `{cs1}` 's, and
. `{cs2}` passes all <<section_cap_integrity,integrity>> checks, and
. any extension-specific constraints on <<CBLD>> hold.
+
Otherwise, set `{cd}.tag=0`

#Begin new since last ARC review#

NOTE: The <<section_cap_integrity,integrity>> check on `{cs2}` is required to prevent authorising a capability with a lack of integrity.
 The <<section_cap_integrity,integrity>> check on `{cs1}` is optional.

If `{cd}.ct` (that is, its <<sec_cap_type>>) is
neither 0 nor an <<sec_cap_type_ambient,ambient>> type, then
set `{cd}.ct` to 0.
That is, <<CBLD>> will construct a sealed capability
only if its type is ambiently available.

#End new since last ARC review#

NOTE: <<CBLD>> is typically used alongside <<SCHI>> to build
capabilities from integer values.

NOTE: When `{cs1}` is `{creg}0` <<CBLD>> will copy `{cs2}` to `{cd}` and clear `{cd}.tag`.
However future extensions may add additional behavior to update currently reserved fields,
and so software should not assume `{cs1}==0` to be a pseudo-instruction for {ctag} clearing.

Included in::
<<rvy_insn_table>>

Operation::
+
sail::execute[clause="CBLD(_, _, _)",part=body,unindent]
