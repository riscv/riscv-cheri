<<<

[#JALR_CHERI,reftext="JALR ({cheri_base_ext_name})"]
==== JALR ({cheri_base_ext_name})

Synopsis::
{JALR_CHERI_DESC}

Mnemonic::
`jalr {cd}, {cs1}, offset`

Encoding::
include::wavedrom/ct-unconditional-2.adoc[]

include::base_isa_extension.adoc[]

#Begin changed since last ARC review#


Description::
Indirect jump to the target capability in `{cs1}` with an address offset.
+
NOTE: The  description below contains three hooks for extending <<JALR_CHERI>> behavior, used by extensions to give a large degree of extensibility.
 Unless an extension, such as <<section_rvy_sentry_insn_ext>>, is implemented which explicitly reference any of the hooks, then take no action for any of them.
+
Operationally, copy `{cs1}` to the target <<pcc>> and then...
+
. Compute the target <<pcc>> address in two steps, each using the semantics of the <<SCADDR>> instruction:
.. Increment the address of the target <<pcc>> by the sign-extended 12-bit `offset`, and
.. set bit zero of the target <<pcc>> address to zero.
. HOOK 1: Optionally clear the {ctag} of the target <<pcc>> depending on the <<sec_cap_type>> value and the numerical values of `{cd}` and `{cs1}`
. Unseal the target <<pcc>> if it is a <<sentry_cap>>, or clear the {ctag} if it is any other sealed type.
. If `{cd}â‰ {creg}0`, compute the return capability and install it to `{cd}`:
.. add the width of this instruction to the current <<pcc>> using the semantics of the <<SCADDR>> instructions, and
.. HOOK 2: Optionally seal the return capability as a <<sentry_cap>> with a <<sec_cap_type>> defined by the implemented extensions.
. HOOK 3: Optionally make other architectural state updates.
. Jump to the target <<pcc>>.
+
[NOTE]
=====
When a sealed capability is passed as the input to <<JALR_CHERI>>, its address must have bit zero clear and the instruction must have a zero offset, or the target <<pcc>> will have its {ctag} set to zero, since updates to its address are interpreted with <<SCADDR>> semantics.
=====
NOTE: A future extension may raise an exception on the <<JALR_CHERI>> instruction itself if the target <<pcc>> will raise a {cheri_excep_name_pc} at the target.
NOTE: A sentry defines a secure function entry point, and as such the offset in the JALR instruction must be zero.
 This is enforced by the use of <<SCADDR>> to add the offset which clears the tag of all sealed capabilities if the offset is non-zero.
#End changed since last ARC review#

Included in::
<<rvy_i_mod_insn_table>>

Operation::
+
TODO

//commented out as it still has exception checks
//sail::execute[clause="JALR_capmode(_, _)",part=body,unindent]
