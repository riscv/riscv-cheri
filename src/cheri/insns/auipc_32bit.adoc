<<<

[#AUIPC_CHERI,reftext="AUIPC ({cheri_base_ext_name})"]
==== AUIPC ({cheri_base_ext_name})

Synopsis::
{AUIPC_CHERI_DESC}

Mnemonic::
`auipc {cd}, imm`

Encoding::
include::wavedrom/rv64_lui-auipc.adoc[]

include::base_isa_extension.adoc[]

#Begin changed since last ARC review#

Description::
Form a 32-bit offset from the 20-bit immediate filling the lowest bits with zero;
the number of places to shift is determined by the capability encoding's choice of
the <<section_auipc_shift>> value (12, unless otherwise specified by the capability encoding format).
Take the value of the AUIPC instruction's <<pcc>>, increment its address by the 32-bit offset using the semantics of the <<SCADDR>> instruction and write the result to `{cd}`.
+
#End changed since last ARC review#
+
include::rep_range_check.adoc[]

Included in::
<<rvy_i_mod_insn_table>>

Operation::
+
sail::execute[clause="AUIPC_capmode(_, _)",part=body,unindent]

[#section_auipc_shift,reftext="AUIPC shift"]
==== The AUIPC Shift

#Begin new since last ARC review#

The RISC-V base integer ISA frequently splits signed 32-bit constants
accross instructions as the addition of a signed 12-bit constant
and a 20-bit constant shifted left by 12 bits.
For example, the I-type instruction `ADDI`, with its 12-bit immediate,
is to be combined with the U-type `LUI` instruction and its 20-bit immediate
when values beyond the reach of a signed 12-bit value are needed.
To reach a given value in this way involve "overshooting" the desired value:
for example, to materialize `0xf01` (`3841`) into a register,
one uses `LUI` to materialize `0x1000` (`4096`)
and `ADDI` to _subtract_ `0xff` (`255`).
Similarly, the U-type `AUIPC` instruction, with its 20-bit immediate,
is designed to compose well with the signed 12-bit immediate operands
of load (I-type) and store (S-type) instructions.

When manipulating addresses within capabilities, there is a risk
that such two-step sequences could take the address out of bounds
before attempting to bring it back within bounds.
Many capability encodings, including those of <<rv32y_cap_description>>,
have a <<section_rep_check_concept,*representable range*>> sufficient
to ensure that any capability whose length is larger than 2 KiB
(that is, those for which a signed 12-bit displacement might be insufficient)
are able to represent at least 2 KiB on either side of their bounds.
However, this is not an *essential* property of capability encodings,
and so this specification allows the capability *encoding* to specify
the shift used within address-manipulating instructions with shifted immediates.
For <<AUIPC_CHERI>> specifically, we refer to this value as **the AUIPC shift**,
and take it to be 12 unless the capability encoding sets it to another value.
(Taking the shift to be 11 instead of 12 decreases the reach of `AUIPC`
from ±2 GiB to ±1 GiB, but ensures that all values within that range
can be obtained with the same sign bit in the `AUIPC` immediate
and subsequent 12-bit immediate(s),
thereby ensuring that in-bounds addresses can be reached without risk of
the intermediate computation exceeding capability bounds.)
Future extensions that add instructions with similar semantics
should make use this same encoding-specified shift value or
otherwise allow the capability encoding to set the shift amount.

NOTE: It is possible for the compiler to generate code that is compatible with any AUIPC shift by emitting a AUIPC with a zero offset followed by a sequence of LUI and <<CADD>>/<<CADDI>>.

// The compiler (and maybe assembler) can always (inefficiently!) articulate the 12-bit shift semantics of AUIPC %0, n; ADDIY %0, %0, m in a way that does not depend on the AUIPC shift and guarantees not going OOB -- that is, oblivious to representation concerns -- by using a temporary register (%1) and emitting (for positive n, without loss of generality; the negative case is similar):
//
// AUIPC %0, 0
//
//   ; if m < 0, step 2Ki shorter than AUIPC would have taken us
// LUI %1, (m >= 0) ? n : (n - 1)  ; other sequences possible for small n.
// ADDY %0, %0, %1                 ; this gets us "most of" the way to (n << 12) + m.
//
//   ; if m < 0, reach upwards from 2 Ki shy of where 12-bit AUIPC would have taken us
// ADDIY %0, %0, ((m >= 0) ? m : (0x1000 - m))
//
// Proof sketch: Assume n > 0 throughout. AUIPC n is used only when the cap in pc has at least (n - 1) * 2 KiB of in-bounds addresses above the current offset, because the expected counterparts of AUIPC (ADDI and loads and stores) use signed 12-bit displacements.
// That is, AUIPC n may "overshoot" the intended target by up to 2 KiB, the furthest negative reach of these displacements. Put differently, in the integer base, AUIPC %0, n; ADDI %0, %0, m leaves %0 displaced from pc by at minimum n * 2 Ki - 2 Ki or (n - 1) * 2 Ki (when m = 0x800) and at most (n - 1) * 2 Ki + (2 Ki - 1) or n * 2 Ki - 1 (when m = 0x7FF).
// To reach the same set of targets while remaining in bounds, we need to step in the same direction: one, LUI (n - 1); ADDY, that gets us (n - 1) * 2 KiB of the way, and the other that gets us the last bit of the way there.
//
// In practice, of course, the toolchain may be able to fold the last ADDYI into the counterpart/subsequent instructions, and may be able to reuse the intermediate result (from ADDY) just like existing toolchains.
// (CHERIoT making its AUIPC shift 11 means that we can always guarantee that the first step is in bounds, and our toolchain picks the correspondingly different immediates to its AUIPC and counterpart instructions.)

#End new since last ARC review#
