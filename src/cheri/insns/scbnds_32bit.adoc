<<<

[#SCBNDSI,reftext="{SCBNDSI}"]
==== {SCBNDSI}

See <<SCBNDS>>.

[#SCBNDS,reftext="{SCBNDS}"]
==== {SCBNDS}

ifdef::cheri_v9_annotations[]
NOTE: *CHERI v9 Note:* {SCBNDS} was called CSETBOUNDSEXACT.

NOTE: *CHERI v9 Note:* {SCBNDSI} would have been CSETBOUNDSEXACTIMM if it had existed.
endif::[]

include::new_encoding_note.adoc[]

ifdef::cheri_v9_annotations[]
NOTE: *CHERI v9 Note:* the immediate format has changed
endif::[]

Synopsis::
{SCBNDS_DESC}

Mnemonics::
`{scbnds_lc} {creg_pref}d, {creg_pref}s1, rs2` +
`{scbndsi_lc} {creg_pref}d, {creg_pref}s1, uimm`

Encoding::
include::wavedrom/scbnds_32bit.adoc[]

Description::
Capability register `{creg_pref}d`  is set to capability register `{creg_pref}s1`  with the base
address of its bounds replaced with the value of `{creg_pref}s1.address` and
the length of its bounds set to `rs2` for <<SCBNDS>>, or `imm` for <<SCBNDSI>>.
+
Set `{creg_pref}d.tag=0` if `{creg_pref}s1.tag=0`, `{creg_pref}s1` is sealed or if `{creg_pref}d` 's bounds exceed `{creg_pref}s1` 's bounds.
+
Set `{creg_pref}d.tag=0` if the requested bounds cannot be encoded exactly.
+
include::malformed_cs1_clear_tag.adoc[]
+
<<SCBNDSI>> uses the `s` bit to scale the immediate by 4 places
+
`immediate = ZeroExtend(s ? uimm<<4 : uimm)`

NOTE: The <<SCBNDSI>> encoding with `s=1` and `uimm â‰¤ 1` is RESERVED since these immediates can also be encoded with `s=0`.


Operation for {SCBNDS}::
+
sail::execute[clause="SCBNDS(_, _, _)",part=body,unindent]

Operation for {SCBNDSI}::
+
sail::execute[clause="SCBNDSI(_, _, _, _)",part=body,unindent]
