<<<

[#CBO_INVAL_CHERI,reftext="CBO.INVAL ({cheri_base_ext_name})"]
==== CBO.INVAL ({cheri_base_ext_name})

Synopsis::
Perform an invalidate operation on a cache block

Mnemonic::
`cbo.inval 0({cs1})`

Encoding::
[wavedrom, , svg]
....
{reg: [
  {bits: 7,  name: 'opcode',    attr: ['7','MISC-MEM=0001111'],  type: 8},
  {bits: 5,  name: 'funct5',    attr: ['5','CBO=00000'],     type: 2},
  {bits: 3,  name: 'funct3',    attr: ['3','CBO=010'],  type: 8},
  {bits: 5,  name: 'rs1',       attr: ['5','base'],     type: 4},
  {bits: 12, name: 'funct12',   attr: ['12','CBO.INVAL=00.0000'],   type: 3},
]}
....

Description::
A CBO.INVAL instruction performs an invalidate operation on the cache block whose effective address is the base address specified in `{cs1}`.
The authorizing capability for this instruction is `{cs1}`.

:cbo_inval:
include::cbo_exceptions.adoc[]


[NOTE]
====
CSR state controls whether CBO.INVAL performs cache block flushes instead of invalidations for less privileged modes.

Invalidating a cache block can re-expose capabilities previously stored
to it after the most recent flush, not just secret values. As such, CBO.INVAL
has stricter checks on its use than CBO.FLUSH, and should only be made available to,
and used by, sufficiently-trusted software.

Untrusted software should use CBO.FLUSH instead as a minimum, and a sensible implementation choice for CHERI systems is to _always_ execute CBO.INVAL as CBO.FLUSH.
====

Prerequisites::
Zicbom, {cheri_base_ext_name}

Included in::
{rvycbom_xref}

Operation::
[source,SAIL,subs="verbatim,quotes"]
--
TBD
--
