<<<

[#YSEAL,reftext="{YSEAL}"]
==== {YSEAL}

Synopsis::
{YSEAL_DESC}

Mnemonic::
`{YSEAL_LC} {cd}, {cs1}, {cs2}`

Encoding::
TODO

Description::
Construct, into `{cd}`, a sealed copy of the unsealed capability in `{cs2}`, using the type and authority from `{cs1}`.
+
Copy `{cs2}` into `{cd}`, and then...
+
. Clear the {ctag} of the capability in `{cd}` if any of the following hold:
+
--
- `{cs2}` is sealed (has a non-zero <<sec_cap_type>> value)
- `{cs1}` has a clear `{ctag}`
- `{cs1}` does not grant <<zyseal_se_perm>>
- The address of `{cs1}` is out of bounds
- The address of `{cs1}` is not a <<sec_cap_type>> value that the capability encoding can encode on the capability in `{cs2}`
--
+
. Set the <<sec_cap_type>> of `{cd}` to the address of `{cs1}`.

[NOTE]
=====
<<YSEAL>> uses the (in-bounds) _addresss_ of the authority in `{cs1}` as the
type in the resulting capability.
If the authority has a nontrivial range,
software can use <<SCADDR>> to select which type should be used.
=====

[NOTE]
=====
If a capability encoding also entails the presence of <<sentry_cap>> types,
it will be possible for software (bearing suitably permissive capabilities)
to seal and unseal the sentry types that that encoding defines.
This is deliberate.
Software should ensure that the capabilities requisite for such operations are
attenuated, confined to sufficiently trusted components, and/or destroyed.
=====

[NOTE]
=====
Some capability encodings correlate non-zero <<sec_cap_type>> values
with other aspects of capabilities, notably permissions.
That is, some encodings may be able to represent
a valid capability with a given non-zero <<sec_cap_type>>
only if other properties of that capability hold,
such as it granting, or not granting, a particular permission.
As such, {YSEAL} may clear the {ctag} of the result in `{cd}`
depending on these other aspects of its `{cs2}` input,
even if some capabilities can be sealed with
the type called for by the address of `{cs1}`.
=====

Included in::
{cheri_seal_ext_name}

Operation::
+
TODO
