<<<

[#ACPERM,reftext="{ACPERM}"]
==== {ACPERM}

ifdef::cheri_v9_annotations[]
NOTE: *CHERI v9 Note:* The implementation of this instruction changes
because the permission fields are encoded differently in the new
capability format.

NOTE: *CHERI v9 Note:* this instruction was called CANDPERM.
endif::[]

include::new_encoding_note.adoc[]

Synopsis::
{ACPERM_DESC}

NOTE: #this needs the semantics changing to invert the mask to CLEAR permissions instead of ANDing"

Mnemonics::
`{acperm_lc} cd, cs1, rs2`

Encoding::
include::wavedrom/acperm.adoc[]

Description::
<<ACPERM>> performs the following operations:

. Convert the <<AP-field>>, <<SDP-field>>, and any other extension-defined permission-like fields of capability `cs1` into a bit field with the
format shown in xref:acperm_bit_field[xrefstyle=short].
. Calculate the bitwise AND of the bit field with the mask in `rs2`.
+
NOTE: Future extensions may include hardwired permission bits, in which case they are not included in this bitwise AND.
. Encode the resulting architectural permissions following the rules in <<sec_permission_transitions>>.
+
IMPORTANT: Depending on the base ISA and supported extensions, some combinations of permissions cannot be encoded or are not useful.
In these cases, <<ACPERM>> will return a minimal sets of permissions, which may be no permissions.
Therefore, it is possible that requesting to clear a permission also clears others, but <<ACPERM>> will never _add_ new permissions.
. Copy `cs1` to `cd`, and update the <<AP-field>>, <<SDP-field>>, and any others therein with the newly calculated versions.
. Set `cd.tag=0` if `cs1` is sealed and any bits in the <<AP-field>> or <<SDP-field>> were affected by <<ACPERM>>;
  extensions must describe whether such changes to their bits also necessitate tag clearing.
. Set `cd.tag=0` if any <<section_cap_integrity,integrity>> checks fail.

.Capability permissions bit field
[#acperm_bit_field]
include::../img/acperm_bit_field.edn[]

NOTE: If a future extension adds a new permission that overlaps with an existing permission (e.g., finer-grained <<asr_perm>>), then clearing the original must also clear the new permission.
This ensures software forward-compatibility: for example, a kernel that does not know about finer-grained <<asr_perm>> subsets must still be able to prevent all access to privileged instructions and CSRs by clearing <<asr_perm>>.

NOTE: Any future extension that defines new permissions that are a refinement of existing permissions (e.g., finer-grained <<asr_perm>> or those of <<section_zylevels1>>) must be allocated to the bits that are currently reported as 1 to ensure forward-compatibility.
Completely new permissions (e.g., sealing) should use the bits that are reported as zero in the current specification.

[NOTE]
====
Extensions like <<section_zylevels1>> introduce bits that are, conceptually, _labels_ on a capability rather than a permission granted by the capability.
These bits are, nevertheless, still adjusted using the <<ACPERM>> instruction.
This avoids the need for a dedicated instruction and allows simultaneous changes of these labels and permissions.
====

Operation::
+
sail::execute[clause="ACPERM(_, _, _)",part=body,unindent]
