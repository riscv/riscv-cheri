[appendix]
== Extension summary

=== {lr_sc_bh_ext_name}

{lr_sc_bh_ext_name} is a separate extension independent of CHERI, but is required for CHERI software.

These instructions are not controlled by the CRE bits in <<mseccfg>>, <<menvcfg>> or <<senvcfg>>.

.{lr_sc_bh_ext_name} instruction extension
[#Zabhlrsc_instruction_extension]
[width="100%",options=header,cols="2,2,10"]
|==============================================================================
include::generated/Zabhlrsc_insns_table_body.adoc[]
|==============================================================================

=== {sh4add_ext_name}

{sh4add_ext_name} is a separate extension independent of CHERI, but improves performance for CHERI code
as the natural data width of pointers has doubled.

These instructions are not controlled by the CRE bits in <<mseccfg>>, <<menvcfg>> or <<senvcfg>>.

.{sh4add_ext_name} instruction extension
[#Zish4add_instruction_extension]
[width="100%",options=header,cols="2,2,10"]
|==============================================================================
include::generated/Zish4add_insns_table_body.adoc[]
|==============================================================================

=== {cheri_base_ext_name}

{cheri_base_ext_name} defines the set of instructions supported by a core when in {cheri_cap_mode_name}.

Some instructions depend on the presence of other extensions, as listed in xref:Zcheri_purecap_instruction_extension[xrefstyle=short]

.{cheri_base_ext_name} instruction extension - Pure {cheri_cap_mode_name} instructions
[#Zcheri_purecap_instruction_extension]
[width="100%",options=header,cols="3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4"]
|==============================================================================
include::generated/Zcheri_purecap_insns_table_body.adoc[]
|==============================================================================

=== {cheri_default_ext_name}

{cheri_default_ext_name} defines the set of instructions added by the {cheri_int_mode_name}, in addition to {cheri_base_ext_name}.

NOTE: {cheri_default_ext_name} implies {cheri_base_ext_name}

.{cheri_default_ext_name} instruction extension - {cheri_int_mode_name} instructions
[#Zcheri_hybrid_instruction_extension]
[width="100%",options=header,cols="3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4"]
|==============================================================================
include::generated/Zcheri_hybrid_insns_table_body.adoc[]
|==============================================================================

[appendix]
[#clen_csr_summary]
== Capability Width CSR Summary

.CSRs renamed and extended to capability width
[#aliased_CSRs]
[width="100%",options=header,cols="1,1,1"]
|==============================================================================
include::generated/csr_aliases_table_body.adoc[]
|==============================================================================

.Action taken on writing to extended CSRs^**^
[#extended_CSR_writing]
[width="100%",options=header,cols="1,2,2"]
|==============================================================================
include::generated/csr_alias_action_table_body.adoc[]
|==============================================================================

^*^ The vector range check is to ensure that vectored entry to the handler
 is within bounds of the capability written to `Xtvecc`. The check on writing
 must include the lowest (0 offset) and highest possible offset (e.g. 64 * MXLEN bits where HICAUSE=16).

^**^ XLEN bits of extended capability CSRs are written when executing
<<CSRRWI>>, <<CSRRC>>, <<CSRRS>>, <<CSRRCI>> or <<CSRRSI>> regardless of the
CHERI execution mode. When using <<CSRRW>>, CLEN bits are written when the
CHERI execution mode is {cheri_cap_mode_name} and XLEN bits are written when
the mode is {cheri_int_mode_name}; therefore, writing XLEN bits with <<CSRRW>>
is only possible when {cheri_default_ext_name} is implemented.

.Action taken on writing to new capability CSRs^+^
[#new_cap_CSR_writing]
[width="100%",options=header,cols="1,2,2"]
|==============================================================================
include::generated/new_csr_write_action_table_body.adoc[]
|==============================================================================

^+^ XLEN bits of new capability CSRs added in {cheri_default_ext_name} are
written when executing <<CSRRWI>>, <<CSRRC>>, <<CSRRS>>, <<CSRRCI>> or
<<CSRRSI>> regardless of the CHERI execution mode. CLEN bits are always written
when using <<CSRRW>> regardless of the CHERI execution mode.

NOTE: Implementations which allow misa.C to be writable need to legalise *Xepcc*
 on _reading_ if the misa.C value has changed since the value was written as this
 can cause the read value of bit [1] to change state.

.CLEN-wide CSRs storing executable vectors or data pointers
[#CSR_exevectors]
[width="100%",options=header,cols="1,1,1,1"]
|==============================================================================
include::generated/csr_exevectors_table_body.adoc[]
|==============================================================================

Some CSRs store executable vectors or data pointers as shown in xref:CSR_exevectors[xrefstyle=short].
These CSRs do not need to store the full width address on RV64.
If they store fewer address bits then writes are subject to the invalid address
check in <<section_invalid_addr_conv>>.

.CLEN-wide CSRs which store all CLEN+1 bits
[#CSR_metadata]
[width="100%",options=header,cols="1,1"]
|==============================================================================
include::generated/csr_metadata_table_body.adoc[]
|==============================================================================

xref:CSR_metadata[xrefstyle=short] shows which CLEN-wide CSRs store all CLEN+1 bits. No other CLEN-wide CSRs store any reserved bits. All CLEN-wide CSRs store _all_ non-reserved metadata fields.

.All CLEN-wide CSRs. {cheri_base_ext_name} is a prerequisite for all CSRs in this table
[#extended_CSRs]
[width="100%",options=header,cols="2,1,1,2,2,4"]
|==============================================================================
include::generated/csr_permission_table_body.adoc[]
|==============================================================================

[appendix]
[#instruction-modes]
== Instructions and CHERI Execution Mode

xref:cap_mode_insns[xrefstyle=short], xref:legacy_mode_insns[xrefstyle=short]
and xref:both_mode_insns[xrefstyle=short] summarise on which
<<section-cheri-execution-mode,CHERI execution mode>> each instruction may be
executed in.

.Instructions valid for execution in {cheri_cap_mode_name} only
[#cap_mode_insns]
[width="100%",options=header,cols="17,15,17,51"]
|==============================================================================
include::generated/cap_mode_insns_table_body.adoc[]
|==============================================================================

.Instructions valid for execution in {cheri_int_mode_name} only
[#legacy_mode_insns]
[width="100%",options=header,cols="17,15,17,51"]
|==============================================================================
include::generated/legacy_mode_insns_table_body.adoc[]
|==============================================================================

.Instructions valid for execution in both {cheri_int_mode_name} and {cheri_cap_mode_name}
[#both_mode_insns]
[width="100%",options=header,cols="17,15,17,51"]
|==============================================================================
include::generated/both_mode_insns_table_body.adoc[]
|==============================================================================

.Mnemonics with the same encoding but mapped to different instructions in {cheri_int_mode_name} and {cheri_cap_mode_name}
[#legacy_mnemonics]
[width="100%",options=header,cols="20,40,40"]
|==============================================================================
include::generated/legacy_mnemonic_insns_table_body.adoc[]
|==============================================================================

.Instruction encodings which vary depending on the current XLEN
[#xlen_dependent_encodings]
[width="100%",options=header,cols="1,3"]
|==============================================================================
include::generated/xlen_dependent_encoding_insns_table_body.adoc[]
|==============================================================================

NOTE: <<MODESW_CAP>>, <<MODESW_INT>> and <<SCMODE>> only exist in {cheri_cap_mode_name} if
{cheri_int_mode_name} is _also_ present. A hart does not support the <<m_bit>>
if it does not implement the {cheri_default_ext_name} extension.

.Conditions for detecting illegal CHERI instructions
[#cheri_illegals]
[width="100%",options=header,cols="17,27,27,27"]
|==============================================================================
include::generated/illegal_insns_table_body.adoc[]
|==============================================================================

<<<

xref:cheri_behavior_cre_mode[xrefstyle=short] summarizes the behavior of a hart
supporting both {cheri_base_ext_name} and {cheri_default_ext_name} in
connection with the <<section_cheri_disable,CRE>> and the
<<section-cheri-execution-mode,CHERI execution mode>> while in a privilege
other than debug mode.

.Hart's behavior depending on the effective <<section_cheri_disable,CRE>> and <<section-cheri-execution-mode,CHERI execution mode>>
[#cheri_behavior_cre_mode,width=100%,options=header,align=center,%autowidth,cols="8,8,15,12,12,15,15,15"]
|==============================================================================
// Header
| <<section_cheri_disable,CRE>>
| <<pcc>>.<<m_bit,m>>
| Authorizing capability^1^
| <<zicsr-section-default,New CHERI CSRs>>^2^
| <<zicsr-section-default,Extended CHERI CSRs>>^3^
| CHERI instructions^4^
| <<legacy_mnemonics,Compressed instructions remapped>>^5^
| Note

// Body
| 0
| X^6^
| <<ddc>> or <<pcc>>
| ✘
| XLEN
| ✘
| No
| **_Fully RISC-V compatible_**^7^

| 1
| 0
| <<ddc>> or <<pcc>>
| CLEN
| XLEN
| ✔
| No
| **{cheri_int_mode_name}**

| 1
| 1
| Instruction's capability operand
| CLEN
| CLEN
| ✔
| Yes
| **{cheri_cap_mode_name}**
|==============================================================================

^1^ Authorizing capability for memory access instructions.

^2^ Whether accesses to <<zicsr-section-default,new CHERI CSRs>> are permitted
or raise illegal instruction exceptions. If permitted, then the bit width of
the CSR read/write with <<CSRRW>> is indicated.

^3^ The bit width of accesses to <<zicsr-section-default,extended CHERI CSRs>>
using <<CSRRW>>.

^4^ Whether CHERI instructions are permitted or raise illegal instruction
exceptions.

^5^ See xref:legacy_mnemonics[xrefstyle=short] for a list of remapped
instructions.

^6^ <<pcc>>.<<m_bit,m>> is irrelevant when <<section_cheri_disable,CRE>>=0.

^7^ The hart is fully compatible with standard RISC-V when
<<section_cheri_disable,CRE>>=0 provided that <<pcc>>, <<mtvecc>>, <<mepcc>>,
<<stvecc>>, <<sepcc>>, <<vstvecc>>, <<vsepcc>> and <<ddc>>  hold the
<<infinite-cap>> capability.
