Permissions::
ifdef::cap_atomic[]
Requires the authorizing capability to be tagged and not sealed.
+
Requires <<r_perm>> and <<w_perm>> in the authorising capability.
+
If <<c_perm>> is not granted then store the memory tag as zero, and load `cd.tag` as zero.
+
If the authorizing capability does not grant <<lm_perm>>, and the tag of `cd` is 1 and `cd` is not sealed, then an implicit <<ACPERM>> clearing <<w_perm>> and <<lm_perm>> is performed to obtain the final permissions on `cd` (see <<LC>>).
+
(_This tag clearing behaviour may become a data dependent exception in future._)
endif::[]
ifndef::cap_atomic[]
Requires <<r_perm>> and <<w_perm>> in the authorising capability.
endif::[]
+
Requires all bytes of the access to be in capability bounds.

Exceptions::
All misaligned atomics cause a store/AMO address misaligned exception to allow software emulation (if the Zam extension is supported, see cite:[riscv-unpriv-spec]), otherwise they take a store/AMO access fault exception.
+
When these instructions cause CHERI exceptions, _CHERI data fault_
is reported in the TYPE field and the following codes may be
reported in the CAUSE field of <<mtval>> or <<stval>>:

<<<

[%autowidth,options=header,align=center]
|==============================================================================
| CAUSE                 | Reason
| Tag violation         | Authority capability tag set to 0, or has any reserved bits set
| Seal violation        | Authority capability is sealed
| Permission violation  | Authority capability does not grant <<r_perm>> or <<w_perm>>, or the AP field could not have been produced by <<ACPERM>>
| Invalid address violation  | The effective address is invalid according to xref:section_invalid_addr_conv[xrefstyle=short]
| Length violation      | At least one byte accessed is outside the authority capability bounds, or the capability has <<section_cap_malformed,malformed>> bounds
|==============================================================================

:!cap_atomic:
