<<<

[#ACPERM,reftext="ACPERM"]
==== ACPERM

ifdef::cheri_v9_annotations[]
NOTE: *CHERI v9 Note:* The implementation of this instruction changes
because the permission fields are encoded differently in the new
capability format.

NOTE: *CHERI v9 Note:* this instruction was called CANDPERM.
endif::[]

include::new_encoding_note.adoc[]

Synopsis::
Mask capability permissions

Mnemonics::
`acperm cd, cs1, rs2`

Encoding::
include::wavedrom/acperm.adoc[]

Description::
ACPERM performs the following operations:

. Convert the AP and SDP fields of capability `cs1` into a bit field with the
format shown in xref:acperm_bit_field[xrefstyle=short].
. Calculate the bitwise AND of the bit field with the mask `rs2`.
. If the AP and <<m_bit>> field in `cs1` could not have been produced by <<ACPERM>> then
clear all AP permissions, and the <<m_bit>> to {CAP_MODE_VALUE}. Skip the next step.
.. If <<cheri_levels_ext,{cheri_levels_ext_name}>> is implemented then also set <<sl_perm>> to 0 (_local_).
. Clear AP permissions as required to meet the rules below.
. Encode the AP permissions for RV32 according to <<cap_perms_encoding32>>.
. Copy `cs1` to `cd`, and update the AP and SDP fields with the newly calculated versions.
. Set `cd.tag=0` if `cs1` is sealed or if any reserved fields of `cs1` are set.

The rules from <<acperm_rules>> must be followed when removing permissions.

[#acperm_rules]
.ACPERM common rules
[%autowidth,float="center",align="center",cols="2,3,3",options="header"]
|===
| Rule | Permission   | Only valid if
|  1   | <<c_perm>>   | <<r_perm>> or <<w_perm>>
3+| See <<acperm_rules_rv32>> for rules 2-5 (RV32 only)
|  7   | <<sl_perm>>  | <<w_perm>> and <<c_perm>>
|  8   | <<el_perm>>  | <<c_perm>> and <<r_perm>>
|  9   | <<lm_perm>>  | <<c_perm>> and <<r_perm>>
| 10   | <<asr_perm>> | <<x_perm>>
| 11   | <<m_bit>>    | <<x_perm>>
3+| See <<acperm_rules_rv32>> for rule 12 (RV32 only)
|===

The behaviour of currently illegal combinations from <<acperm_rules>> is to clear the permission if invalid (or in the case of <<sl_perm>> set it to 0 (_local_)).

* For RV64 all such combinations may be redefined by future extensions.
* For RV32 none of these combinations are possible.

RV32 needs additional rules as some combinations which are legal on RV64 are not possible on RV32.
These rules are specifically to meet the encoding requirements for <<cap_perms_encoding32>>, or
<<cap_perms_encoding_levels32>> if <<cheri_levels_ext,{cheri_levels_ext_name}>> is implemented.

[#acperm_rules_rv32]
.ACPERM RV32 additional rules
[%autowidth,float="center",align="center",cols="2,2,3",options="header"]
|===
| Rule | Permission   | Only valid if
|  2   | <<c_perm>>   | <<r_perm>>
|  3   | <<x_perm>>   | <<r_perm>>
|  4   | <<w_perm>>   | not(<<c_perm>>) or (<<c_perm>> and not(<<lm_perm>>))
|  5   | <<x_perm>>   | <<w_perm>> or <<c_perm>>
|  6   | <<x_perm>>   | <<c_perm>> == <<lm_perm>> == <<el_perm>>
| 12   | <<asr_perm>> | All other permissions are set.
|===

In all cases invalid permissions from <<acperm_rules_rv32>> are cleared.

.Capability permissions bit field
[#acperm_bit_field]
include::../img/acperm_bit_field.edn[]

NOTE: The <<el_perm,EL>>, <<sl_perm,SL>> and <<section_cap_level,CL>> fields are only defined if the implementation supports <<cheri_levels_ext,{cheri_levels_ext_name}>>.

NOTE: Even though being included here <<section_cap_level,CL>> is not considered an architectural permission.

Exceptions::
include::require_cre.adoc[]

Prerequisites::
{cheri_base_ext_name}

Operation::
+
--
TODO: Sail does not have the new encoding of the permissions field.
--
