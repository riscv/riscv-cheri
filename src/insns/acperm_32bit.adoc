<<<

[#ACPERM,reftext="ACPERM"]
==== ACPERM

ifdef::cheri_v9_annotations[]
NOTE: *CHERI v9 Note:* The implementation of this instruction changes
because the permission fields are encoded differently in the new
capability format.

NOTE: *CHERI v9 Note:* this instruction was called CANDPERM.
endif::[]

include::new_encoding_note.adoc[]

Synopsis::
Mask capability permissions

Mnemonics::
`acperm cd, cs1, rs2`

Encoding::
include::wavedrom/acperm.adoc[]

Description::
ACPERM performs the following operations:

. Convert the AP and SDP fields of capability `cs1` into a bit field with the
format shown in xref:acperm_bit_field[xrefstyle=short].
. Calculate the bitwise AND of the bit field with the mask `rs2`.
. If the AP and <<m_bit>> field in `cs1` could not have been produced by <<ACPERM>> then
clear all AP permissions, and the <<m_bit>> to {CAP_MODE_VALUE}. Skip the next step.
. Clear AP permissions as required to meet the rules below.
. Encode the AP permissions for RV32 according to <<cap_perms_encoding32>>.
. Copy `cs1` to `cd`, and update the AP and SDP fields with the newly calculated versions.
. Set `cd.tag=0` if `cs1` is sealed or if any reserved fields of `cs1` are set.

The rules from <<acperm_rules>> must be followed when removing permissions.

[#acperm_rules]
.ACPERM common rules
[%autowidth,float="center",align="center",cols="3,3,3",options="header"]
|===
| Rule            | Permission   | Only valid if
|  1  (RV32 only) | <<asr_perm>> | All other permissions are set.
|  2              | <<c_perm>>   | <<r_perm>> or <<w_perm>>
|  3  (RV32 only) | <<c_perm>>   | <<r_perm>>
|  4  (RV32 only) | <<x_perm>>   | <<r_perm>>
|  5  (RV32 only) | <<w_perm>>   | not(<<c_perm>>) or <<lm_perm>>
|  6  (RV32 only) | <<x_perm>>   | <<w_perm>> or <<c_perm>>
|  7              | <<el_perm>>  | <<c_perm>> and <<r_perm>>
|  8              | <<lm_perm>>  | <<c_perm>> and <<r_perm>>
|  9  (RV32 only) | <<x_perm>>   | <<c_perm>> == <<lm_perm>> == <<el_perm>>
| 10              | <<sl_perm>>  | <<c_perm>>
| 11              | <<asr_perm>> | <<x_perm>>
| 12              | <<m_bit>>    | <<x_perm>>
|===

The behaviour of currently illegal combinations from <<acperm_rules>> is to clear the permission if invalid (or in the case of <<sl_perm>> set it to 0 (_local_)).

* For RV64 all such combinations may be redefined by future extensions.
* For the RV32 only rules none of these combinations are possible to meet the encoding requirements for <<cap_perms_encoding32>>, or
<<cap_perms_encoding_levels32>> if <<cheri_levels_ext,{cheri_levels_ext_name}>> is implemented. In all cases invalid permissions are cleared.

.Capability permissions bit field
[#acperm_bit_field]
include::../img/acperm_bit_field.edn[]

NOTE: The <<el_perm,EL>>, <<sl_perm,SL>> and <<section_cap_level,CL>> fields are only defined if the implementation supports <<cheri_levels_ext,{cheri_levels_ext_name}>>.

NOTE: Even though being included here <<section_cap_level,CL>> is not considered an architectural permission.

Exceptions::
include::require_cre.adoc[]

Prerequisites::
{cheri_base_ext_name}

Operation::
+
--
TODO: Sail does not have the new encoding of the permissions field.
--
